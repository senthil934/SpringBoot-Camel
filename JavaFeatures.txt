Java Versioning
    - There is new java release coming in every 6 month, this is recent development, because of this there are 2 java release every year 

1. JDK1.0 in Jan1996 and there is subsequent release of JDK 2,3,4 after that major release was JDK5

2. J2SE5.0 in sep 2004 and there are 5 releases in almost 8 years 

3. The next major release is JavaSE 8(LTS-Long Term Support) on march 2014 which is most important Java release which bought functional programming, Lambda, Streams

4. Java SE9 in sep 2017 and again 4 release in 13 yrs (from 2004 to 2017 from 5 to 9 version)

5. Java SE10 in mar 2018 which is time based release versioning which means the release will happen for every 6 months and wht are features are ready that would be the part of that specific release

8. JavaSE 11(LTS) on sep 2018
        Java11 is paid versions, only for corporate users it is paid versions and for individual development it is free version. Oracle people have given open jdk for all members and use it

https://jdk.java.net/11/ - just download and extract u get jdk-11, no need to install jre separately and set the path 
9. Java SE 12 on mar 2019 etc
10. JavaSE 16 on mar 2021

Previously there is huge difference between each Java releases however from Java 10 onwards the new features introduced are far less as it coming in every 6 months. Java prefer to use long term support release because they have support for very long time.

Java new features
1. J2SE5.0 - Enhanced forloop,Generics, Enums, Autoboxing
2. Java SE8(LTS) - Functional programming
3. Java SE9 - Modularization(Java Platform Module System)
     Where Modularization of Java is introduced, where entire JDK is now modularized into multiple modules, not only that u can also build appl in modularized way
4. Java SE10 - Local variable type Inference - variable declaration is really complex, java can automatically infer the type of local variable in Java10
5. Java SE14 - Switch expression (Preview in 12 and 13)
      - Instead using switch as statement, from java 14 we can use switch as expression
6. Java SE 15 - Text blocks(Preview in 13)
      - If we want to write complex piece of text having multiple lines with ",', escape characters in Java is very difficult and text blocks make it easier
7. Java SE16 - Record classes (Preview in 14 and 15)
      - We have created many Java beans in previous versions with getter, setter, constructor, toString, equals  etc. In Java 16 we have record classes which makes it easy to create this type of bean classes 
8. All Java versions - There are new api is introduced and almost every version of Java has performance improvements expecially in Garbage collection
    

1. List,Set,Map copyOf method

Java 10 features
1. Local Variable Type Inference
      - Declaring local variable without type
      - Whenever we declare any variable we have to provide its datatype so only Java is called statically typed language, but Angular, Python, Javascript and all is called as dynamically typed one because depending upon the value its datatype is fixed 
     - So from JDK10 we can define any variable with "var" keyword, so compiler will understand depending upon the value it will take up datatype. 
 var a=1234; - So at compile time it will infers as int
After compile time variable "a" becomes of type int
   var b="hello"; //b infers as string at compilation

Limitations
   1. Only local variable will be declared with "var"
   2. var is reserved keyword
   3. var is not allowed in method, constructor arguments, method return types
   4. We cant assign null to var type, because null is generic (ie) it can be any object 
   5. var should be with declaration and initialization
      var a = 10;  //correct

      var a;
      a=10;  //wrong

Example:
public class Sample { PSVM {
    List<String> l1=List.of("One","two");
    List<String> l2=List.of("three","four");
    
    var names=List.of(l1,l2);
    names.stream().forEach(System.out::println);
    //whatever methods avaiable in List will now available in names also. Even when we make some mistake in methods also it will show
}

   -Java compiler infers the type of the variable at compile time
   - Introduced in Java10
   - You can add final if you want, but by default it is not final 
      final var names=List.of(l1,l2);
   - var can also be used in loops
        for(var name:names)
            System.out.println(name);
   - You cannot assign to null
            var abc=null;
   - var is not a keyword
   - Improved readability for chained expression
   var filter=List.of("one","two:).stream().filter(s->s.length()<5);
      filter.forEach(System.out::println);


2. API for creating unmodifiable Collection
     - From util package there are many methods introduce to support unmodifiable collection
     - List.copyOf, Set.copyOf, Map.copyOf used to create immutable list of values from existing list or set or map which cant be changed. If map we are passing is already immutable then it will return map back, it wont create copy
     - New methods toUnmodifiableList, toUnmodifiableSet, toUnmodifiableMap have been added to the Collectors class in stream package, which allow the elements of a stream to be collected into an unmodifiable collection

List<Integer> li=Arrays.asList(1,2,4,6,8);
List<Integer> l1=List.copyOf(li); //creates immutable object
SOP(l1); //[1,2,4,6,8]
l1.add(10); //throws UnsupportedOperationException

Stream<String> s2=Stream.of("a","b","c","d");
List<String> l2=s2.collect(Collectors.toUnmodifiableList());
Set<String> s=s2.collect(Collectors.toUnmodifiableSet());

Java 11 Features  
https://www.youtube.com/watch?v=gjr92jxiEd8
    
1. JRE Updates
      - From JDK11 onwards there is no jre install in the user machines. When u install JDK, JRE was getting install in our machines. But now onwards we wont get any JRE. So JDK and JRE are together installed. 
     - JDK itself contains Java development software and JRE 
     - In windows and Mac OS, installing the JDK in previous releases optionally installed JRE, this is no longer an option. Because Java is gradually moving towards Modularization we can create modules using JLink and we can reduces the size of software and ship that software to client  
     - Mainly JRE is install in client machine and top of that Java software is installed. Using JLink we can create small packages and u can ship that one 
     - Using JPackage also we can create exe files for windows so that the software can simply install in client machine. We can make exe file from jar file and install that jar into our client machine without any JRE

    1. Upto Java10 version, we need to compile and execute the java program. From Java11 version onwards we can execute java file directly without compiling 
   > java Test.java
  Whenever we give "java Test.java" internally first compilation perform then execution will take place, so in case any compilation failed it will show error also, which is some what similar to python execution like "python Test.py"

   2. In single java program, when we provide more than one class with main method, then JVM will search for main() in the order in which we provided from top to bottom, in which class JVM identifies main() first time then JVM will treat that class as the actual main class and JVM will execute that main class

Test.java
class C { PSVM  {
   SOP("C-Main");
}}
class A { PSVM  {
   SOP("A-Main");
}}
class B { PSVM  {
   SOP("B-Main");
}}
>java Test.java
Output: C-Main

No class file will be generated, it means which class is loaded and the respective other class are compiled but not loaded in memory
   Java11 provide backward compatibility (ie) here also we can compile and execute as previous version also 

Rules:
  1. We not have .class file for this Java file inside the folder
public class Test {
   PSVM {
      SOP("Hello world");
   }
}
>java Test.java
>java -verbose Test.java
     To check complete functionality of JVM, first it will load all classes into JVM and then at last we can see our class. JVM background uses compiler to do check

  2. If main() is not present in java file it will throw error
public class Test {
   
}
>java Test.java

  If in this folder we have .class file and if we run java Test.java then it will show error, so in Java11 we need only java file should be present
   This feature provide slow execution since both compilation and execution got combined so it is not used in production env, only for beginners or new learners we can use this. 

  3. We must place main method in first class in Java, because Java11 executes from top to bottom, so main class should be first class otherwise it will show compiler error
class Test { PSVM {
   SOP("Test-Main");
}}
public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
class B {
    static void m2() {  SOP("m2"); }
}
>java Test.java
Test-Main

  4. No need to be class name and java file name to be same, even if it is public. So u can create filename any and class name any. Because java command not verifying the class and java file same or not. We given this java file going into the file and check first class contain main method or not, if it is available it will execute 

class C{ PSVM {
   SOP("C-Main");
}}
public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
class B {
    static void m2() {  SOP("m2"); }
}
>java Test.java
C-Main

  5. Even if we have multiple main method in call, no problem JVM will execute the first main method 

class C { PSVM {
   SOP("C-Main");
   A.m1();
   B.m2();
   A.main(new String[0]);
}}
public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
class B {
    static void m2() {  SOP("m2"); }
}

>java Test.java
C-Main
m1
m2
A Main

  6. Even in single program, we have multiple classes to be public
  7. In single java program, we have multiple classes but when we run it will execute only main class, other classes will not load into JVM until u call those classes, to check that
    > java -verbose Test.java
Now we can it will load only C class into JVM
[class,load] C source: __JVM Defines___
  In case, if we call A.m1() inside main(), then if we check u can see C as well as A classes will be loaded in JVM 
   In source file, we can define multiple classes then first class should contain main() to launch the class, then when u running this java file we can have multiple classes compiler will compile all classes if no mistake are there it will generate the byte code and give to JVM. JVM making all this classes store in buffer, it is not loading in memory and storing somewhere in buffer. So whichever class we are accessing that class from buffer is loading in JVM 
   Previously the buffer is nothing but .class file that it is in harddisk, whenever we access the class that time class loading from harddisk to JVM and executed. But harddisk cannot be used thats why it uses internal RAM level buffer it uses, so RAM level buffer stores all this classes bytecode whenever we access methods from the class then at that time it load class to JVM.

    8. Now we copy class A separately into another java file
Test.java
class C { PSVM {
   SOP("C-Main");
   A.m1();
   B.m2();
   A.main(new String[0]);
}}
class B {
    static void m2() {  SOP("m2"); }
}  

A.java

public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}

>java Test.java
    - It will show error

But we can access other program if it has a class file 
>javac A.java
   - It creates A.class
Now we can execute 
>java Test.java
    It will execute main class, but when we try to access A.m1() it will show an IllegalAccessError. So if u want to access any class outside means it should be present in a package   

package p1;
public class A {
   public static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
>javac -d . A.java

Test.java
class C { PSVM {
   SOP("C-Main");
   p1.A.m1();
   B.m2();
   A.main(new String[0]);
}}
class B {
    static void m2() {  SOP("m2"); }
}  

>java Test.java
C main
A m1
B m2

We cannot access another java file classes, but we can access the classes which are already compiled and has .class with package 

CommandLine argument
>java Test.java 10 20 30

2. No language translations for Java release - From JDK11 onwards java releases available only in english

3. Updated packaging format for Windows has changed from .tar.gz to .zip and for MacOS it is changed from .app to .dmg

4. JavaFx, Java Mission Control(JMC) is shipped separately
     - Previously these where part of JDK itself, JavaFx is updates related to flash works, java effects api 

5. Deployment stack for applets, webstart apps deprecated in Java9 and now it is remove from Java 11

2. Launch single file programs without compilation 
       - When new developer want to start developing a program, he have study so many thing how to compile and execute the program
       - Here developer can write simple file and execute that single file without compiling (ie) without generating .class file we can execute the program
        >java sample.java
Without giving .class file we can run our file. Here java interpreter enhanced to take the responsbility of compilation without generating .class file. So internally maintaining some stack so directly running java file and give the output 

3. java.util.Collection - toArray(intFunction)

ArrayList<String> list=new ArrayList<>();
list.add("one");
list.add("two");

list.stream().toArray(s->new String[s]); //old version

String a[]=list.toArray(size->new String[size]);
SOP(Arrays.toString(arr));

Previously we have to create stream object and pass but now we can dynamically pass some lambda expr and generate the array 

String a[]=list.toArray(String[]::new); //using method refernece
SOP(Arrays.toString(arr));

4. Local Variable syntax for Lambda parameters
      -You either define the type var on all the parameters or none

interface Example {
    int operation(int a,int b);
}

Example e=(int a,int b) -> a+b;
Example e=(var a,var b) -> a+b;

(var a,var b) -> a+b;  //correct
(var a,b) -> a+b; //wrong
(a,var b) -> a+b; //wrong
(var a,String b)-> a+b; //wrong
var a -> a; //wrong,we have to use the parenthesis

5. String API changes
      - certain enhancement in String API
isBlank() - check whether string is blank or not
lines() - based on \n extract list of strings. From multi line string if we want to extract substring of each line
strip() - removes leading and trailing spaces
stripLeading()
stripTrailing()
   In general both method removes leading and trailing spaces from string. However the difference comes when we work with unicode charaters or multilingual features.New method strip which is added in java 11 usage this Character.isWhitespace(int) method to cover wide range of white space characters and remove them.

repeat() - repeat string for particular times

Example2: 

String a=" Welcome ";
SOP(a.isBlank()); //false
String a1="    ";
SOP(a.isBlank()); //true since it emply spaces

String b= "one \n"
         + "two \n"
         + "three \n";
a.lines().forEach(System.out::println);

String c="welcome"
SOP(c.repeat(5)); //welcome will repeat 5 times


SOP(" ".isBlank()); //true
SOP(" L R ".strip().replace(" ","@")); //L@R
SOP(" L R ".stripLeadig().replace(" ","@")); //L@R@
SOP(" L R ".stripTrailing().replace(" ","@")); //@L@R
"Line1\nLine2\nLine3\nLine4".lines().forEach(System.out::println);

String string = '\u2001'+"String    with    space"+ '\u2001';
   System.out.println("Before: \"" + string+"\"");
   System.out.println("After trim: \"" + string.trim()+"\"");
   System.out.println("After strip: \"" + string.strip()+"\"");
   }
}

//take specific set of string and transform it
SOP("UPPER".transform(s->s.substring(2))); //PER

//takes string and format it
SOP("My name is %s. My age is %d.".formatted("Ram",24));

//additional info for NullPointerException
String str=null;
System.out.println(str.isBlank()); //In Java14 it gives additional info about the NPE 

Example2:
public class Sample { PSVM {
  String name="";
  sop(name.isEmpty()); //true
  String name1=" ";
  sop(name1.isEmpty()); //false
  String name2=" ";
  sop(name2.isBlank()); //true
  String name3="";
  sop(name3.isBlank());  //true

  String name4="One\nTwo";
  List<String> l=name4.lines().collect(Collectors.toList());
  sop(l);  //[one,two]

  String s="test string\u205F";
  String s1=s.strip();
  sop(s1+"*****");
  String t1=s.trim();
  sop(t1+"*****");

  String n5=" Ram Kumar ";
  sop(n5.strip()); 
  String n6=" Ram Kumar ";
  sop(n6.stripLeading()); 
  String n7=" Ram Kumar ";
  sop(n7.stripTrailing()); 
  sop(n7.repeat(4));

6. Optional.isEmpty()
       - to check whether optional class is empty or not
       - If we want to do something if value is absent, in that case we use negation. It wont make it very readable. Normally ifPresent() gives value if value is present so for negation purpose we use !ifPresent() so for that we can use isEmpty()

 
Optional o=Optional.of("hello");
o=o.empty();
o.ifPresent(s->System.out.println(s));
SOP(o.isEmpty());  //true

7. Files read string and write string
     - When we write something to text files or read from file, we use BufferedReader, BufferedWriter, FileWriter etc. From Java11 onwards oracle introduce few methods which made easy to write few context and read from text file 
     - read and write string data from files - writeString(), readString(), isSameFile()-compare the contents of 2 file

Program 1:
var uri="C:\\data.txt";
try{
  Files.writeString(Path.of(uri),"hello",StandardOpenOption.APPEND);

  String data=Files.readString(Path.of(uri));
  System.out.println(data);
}
catch(IOException e){
    e.printStackTrace();
}

Now the data will be appended into file and prints the data

Program 2:
1. Create sample.txt inside resources folder
Sample
Line 2
Line 3
2. Now we read the content from file and write to another file

Path path=Paths.get("./resources/sample.txt");
String f=Files.readString(path);
System.out.println(f);
String n=f.replace("Line","Lines");
Path n1=Paths.get("./resources/sample1.txt");
Files.writeString(n1,n);

8. HTTP Client API
       - used to give post, get and delete request 
       - Alternate to HttpURLConnection,  we are using HttpURLConnection to deal with http connection, to read and perform operation on HTTP protocol. Now we use HTTP Client API to do all this things 
       - The advantage is it can perform sync and async operations and can handle multiple urls at same time on Http 1 as well as Http2

String uri="https://postman-echo.com/get?uname=java&pwd=121";
HttpRequest req=HttpRequest.newBuilder().uri(URI.create(uri)).GET().version(Version.HTTP_2).build();

HttpClient client=HttpClient.newBuilder().build();
try{
  HttpResponse<String> res=client.send(req,BodyHandlers.ofString());
   SOP(resp.statusCode());
   SOP(resp.body());
}
catch(IOException | InterruptedException e) {
   e.printStackTrace();
}

Example 2: synchronous get request 
public class Sample { 
//create http client with http version 1.1
private static final HttpClient httpClient=HttpClient.newBuilder()
          .version(HttpClient.Version.HTTP_1_1)
          .connectTimeout(Duration.ofSeconds(10))
          .build();

     PSVM() throws Exception {
   //Synchronous get request 
   HttpRequest req=HttpRequest.newBuilder()
                   .GET()
                   .uri(URI.create("https://httpbin.org/get"))
                   .setHeader("User-Agent","Java 11 HttpClient")
                   .build();

//using httpclient send the request 
HttpResponse<String> res=httpClient.send(req,HttpResponse.BodyHandlers.ofString());

HttpHeaders headers=res.headers();
headers.map().forEach((k,v)->System.out.println(k +":"+v));
   System.out.println(res.statusCode());
   System.out.println(res.body());

}
}

Example 3: For Asynchrounous GET request 
public class Sample { 
//create http client with http version 2
private static final HttpClient httpClient=HttpClient.newBuilder()
          .version(HttpClient.Version.HTTP_2)
          .connectTimeout(Duration.ofSeconds(10))
          .build();

     PSVM() throws Exception {
   //Synchronous get request 
   HttpRequest req=HttpRequest.newBuilder()
                   .GET()
                   .uri(URI.create("https://httpbin.org/get"))
                   .setHeader("User-Agent","Java 11 HttpClient")
                   .build();

CompletableFuture<HttpResponse<String>> res=httpClient.sendAsync(req,HttpResponse.BodyHandlers.ofString());

String result=res.thenApply(HttpResponse::body).get(5, TimeUnit.SECONDS);
System.out.println(result);
}
}

Example 4: we can send multiple request at same time

public class Sample {
   private static final ExecutorService exe=Executors.newFixedThreadPool(3);

private static final HttpClient httpClient=HttpClient.newBuilder()
          .executor(exe)
          .version(HttpClient.Version.HTTP_2)
          .connectTimeout(Duration.ofSeconds(10))
          .build();
PSVM() throws Exception  {
   List<URI> targets = Arrays.asList(
       new URI("https://httpbin.org/get?name=ram"),
       new URI("https://httpbin.org/get?name=kumar"),
       new URI("https://httpbin.org/get?name=sam"));

List<CompletableFuture<String>> res=target.stream().
       map(url->httpClient.sendAsync(
           HttpRequest.newBuilder(url)
             .GET()
             .setHeader("User-Agent","Java HttpClient")
             .build(),
         HttpResponse.BodyHandlers.ofString())
        .thenApply(HttpResponse::body))
        .collect(Collectors.toList());

for(CompletableFuture<String> f:res) {
     sop(f.join());
  {
}
}

9. Predicate.not
      - Returns a predicate that is the negation of the supplier predicate 

public class Sample {
    public static boolean isEven(Integer number) {
         return number%2==0;
    }
    public static void main(String[] a){
        List<Integer> l=List.of(3,4,5,67,89,88);
    //Predicate<Integer> p1=n->n%2==0;
    //l.stream().filter(p1).forEach(System.out::println);  //4, 88
    //l.stream().filter(p1.negate()).forEach(System.out::println);  //3,5,67,89

   l.stream().filter(Predicate.not(Sample::isEven)).forEach(System.out::println); //4 88


10. Nested based access control
       - This is the feature 

Example 1:

public class Main {
    static class Blog {
         private String name;
    }
    PSVM {
      Blog b=new Blog();
      Field bName=Blog.class.getDeclaredField("name");
      bName.set(b,"hello world");
      SOP(b.name);
   }
}

Example 2:

public class Test {
     private static int x=5;
     public static class NestedTest {
         public static void doSomething() {
             System.out.println(x);
         }
     }
}

>javac Test.java
>javap -v Test.class

Before Java11 we we compile such type of file,here we can see extra method will be added for nested class called static int access$000(). This is the private bridge created between two classes, when we compile a class which contains another class so for that 2 class file will be created, one for outer and one for inner, so there should be some bridge between the outer class can access the method of another .class file 

>javap -v Test$NestedTest.class

Here we can see when we invoke doSomething(), it have provide like Test.access$000(), stating the outerclass can access this method by specifying the bridge between  both of the classes

But from Java11 onwards another access control is introduced which is "nest" and in nest we have nestHost and nestMembers. Basically outer class is nest host and inner classes are nest members or nest mate of that class
  When we compile the code in Java11 and see
>javac Test.java
>javap -v Test.class
    Here we have static int access$000() which will act as bridge between outer and inner class so that we can access private members of the outer class. So in Java11 onwards we have nesthost and nestmembers, so the outer class contains nest members as "Test$NestedTest.class"
    When we try to access inner class
>javap -v Test$NestedTest.class
    Here we can see nest host as "class Test" which is outer class 

So basically in this feature there is no impact on development or enduser but just enhancement on JVM level. 

Basically, the nest term defines a new access control context that allows classes that are logically part of the same code entity, but which are compiled with distinct class files, to access each others private members without the need for compilers to insert accessibiltity bridge methods
   Earlier version to access private members of class we need to specify the brigding method, but from java11 onwards no need to specify in compiled class instead we need to mention nesthost and nest members


11. TimeUnit Conversion
       - used to convert DAY, HOURS, MINUTES 

TimeUnit c=TimeUnit.DAYS;
c.convert(Duration.ofHours(24));
Output: 1 //convert 24hrs to day

TimeUnit c1=TimeUnit.MINUTES;
c1.convert(Duration.ofHours(60));
Output: 3600

13. Pattern recognizing method
      - used to generate the pattern and test against the string 

asMatchPredicate() - will create a predicate if pattern matches with input string 



14. Java Flight Recorder
       - Used tool for running Java appl and capturing diagnostic for further analysis. So when ur appl crashes or not perform as expected, u can monitor or troubleshoot it using the data collected by flight recorder
       - It is used for black box analysis as it continuously save state data into circular buffer and this information can be accessed when a problem is detected. You can use JFR for unexpected events.
       - For example if we get OutOfMemoryError in ur code or VM crashes, we can get all details and root causes with help of JFR

Introduction to Flight Recorder
   1. JFR provides best possible visibility into the JVM since it is build into JVM itself
   2. JFR has low performance overhead when used in heavily loaded production appl. We have overhead when we have profilers because profilers are attached to JVM and they consume heaps and create their own threads. When we use in production system u should carefully choose which event u should use with profiling
   3. It is event based profiling engine, when we say event that could be garbage collection or CPU load increase by threshold value or heap space consume more than 90%. JFR collects data from more than 500 events and we can create custom events also 
   4. JFR has binary recordings and we cant open and look into them. Events are written in binary formats, all the recordings are .jfr extension 
   5. We have Java API also to load and read data through Java code, you can trigger events through Java API calls. Java API is introduced in Java9 in jdfk.jfr package 

Events
   - Event occurs in JVM at specific point in time. Each event has name, timestamp and optional payload(the data associated with event)
   - For eg, CPU usage or Java heap size before and after the event or thread id 

3 types of events
   1. Duration events
   2. Instant events
   3. Sample events

Removed Features
1. Removal of com.sun.awt.AWTUtilities class
2. Removal of appletviewer launcher
3. Removal of Thread.destroy() and Thread.stop() methods
4. Removal of JVM-Managemebt-MIB.mib
5. Removal of Java Deployment Technologies like Java plugins, Java webstart, JRE 
6. Removal of JAVA FX from Oracle JDK
7. Remove JavaEE and CORBA Modules

Migration to Java 11
1. Eclipse : Photon 4.9RC2 with Java 11 plugin
Maven :3.5.0
Compiler plugin: 3.8.0
surefire and failsafe:2.22.0



Java 12 features
1. Compact Number Format 
     - Compact number formatting refers to the representation of a number in a short or human readable form
     - For eg, 1000 can be represent as 1k, 100000 can be represent as 1L, depending on the style specified by NumberFormat.Style
     - The compact number formats are defined by LDML(Local Data Markup Language) specification
     - NumberFormat adds suppory for formatting a number in its compact form

NumberFormat fmt=NumberFormat.getCompactNumberInstance(Locale.US,Style.SHORT);
String s=fmt.format(1000);
SOP(s); //output: 1K

String s1=fmt.format(100000000);
SOP(s1); //output: 100M

String s=fmt.format(100000000000000L);
SOP(s); //output: 1OOT

String s=fmt.format(9999);
SOP(s); //output: 10K - will display the nearest value 

2.  Switch Expression
       - new form of switch statement, normally we cant return value directly from switch stmt, instead we can go for switch expr
       - Syntax:  label -> logic
       - break is not required here
       - If we want to return multiple value we can use yeild keyword
   
class Sample {  PSVM {
   String msg=perOfDailyTask("SATURDAY");
   System.out.println(msg);
}

public static String perOfDailyTask(String day) {
     String msg=null;
     msg= switch(day) {
        case "MONDAY" -> {
                      System.out.println("hii");
                      yield "A";
                      }
        case "TUESDAY" -> "B";
        case "WEDNESDAY" -> "C";
        case "THURSDAY" -> "D";
        case "FRIDAY" -> "E";
        case "SATURDAY" -> "F";
        default -> "wrong input";
        };
    return msg;
}
}
Output: F

We can have multiple case in single line 

public static String perOfDailyTask(String day) {
     String msg=null;
     msg= switch(day) {
        case "MONDAY" -> {
                      System.out.println("hii");
                      yield "A";
                      }
        case "TUESDAY","WEDNESDAY","THURSDAY" -> "B";
        case "FRIDAY" -> "E";
        case "SATURDAY" -> "F";
        default -> "wrong input";
        };
    return msg;
}


Java 13 features - https://github.com/greenlearner01/Java13/tree/master/CommandLine

1. Text Blocks
       - A text block is a multi line literal. Avoids the need for most escape sequences automatically formats the string in a predictable way 

String email="hello welcome,\n"
             + " to java \"bean\"....\n"
             + "welcome\n"
             + "hello world\n";

email="""
        hello welcome,
        to Java "bean"....
        welcome
        hello world
      """;

   String s="""
       Line 1: %s
       Line 2: %s
       Line 3
       Line 4
       """.formatted("Some value","Some other value");
   SOP(s);

  - u cannot have text block in single line
      String s="""abcejjdjd"""; 

2. Z Garbage Collector Enhancement in JKD13
      - It is about returning unused memory to the os
      - It is introduced in Java11, to enhance the performance of the application by returing the unused memory to the OS and efficiently clearing the garbage 
      - Z Garbage collector is low latency garbage collector (ie) it takes more time  
      - ZGC performs all expensive works concurrently, without stopping the execution of appl threads for more than 10ms, so 10ms is threshold or max time 

Java 14 features

https://programmingtechie.com/2020/03/20/java-14-new-features/

1. Helpful NullPointerException 
     - Whenever we write big code in java, and when this code throws NullPointerException, it can become difficlt to know from where the exception originates.
     - Gives developers control over the format when desired
     - Aims to improve the readability of NullPointerExceptions, generated by JVM, by describing which variable is null
     - By providing -XX:+ShowCodeDetailsInExceptionMessages in VM Options 

2. Pattern matching for instanceOf
      - instanceOf operator is enhanced to support pattern matching 
      - Normally when u dealing with type Object which is from java.lang package, we will cast it to our required type by checking its type using instanceof keyword, then we will cast object to our required type, then will cast the object 
      - But will pattern matching feature we dont need to cast the object explicitly, we have to provide corresponding variable along with type to instance object and the variable will bound to casted value 

Object obj="hello";

//lower version
if(obj instanceOf String) {
    String str=(String)obj;
    System.out.println(str.toUpperCase());
}

//latest version
if(obj instanceOf String str) {
    System.out.println(str.toUpperCase());
}

3. Records 
     - Eliminate verbosity in creating Java Beans - public accessor methods, constructor, equals, hashcode, toString are automatically created 
     - Records improves developer productivity by providing a compact syntax for declaring classes which act as transparent carriers for immutable data 
     - new class called record, it is final class not abstract and all of its field are final
     - The record will automatically generate the tedious constructors, getter methods, equals, hashCode, toString during compile time. No setter methods for record class 
     - So whenever we create immutable class we have to provide constructors, getter methods, equals, hashCode, toString, instead we can use record class for creating immutable class 

public class RecordDemo {
  record UserRecord(String firstName, String lastName, int userId){ }
  public static void main(String[] args){
     UserRecord u=new UserRecord("ram","kumar",1234);
     UserRecord u1=new UserRecord("ram","kumar",1234);
     System.out.println(u.firstName()); //ram
     System.out.println(u.equals(u1)); //true
  }
}

Internally if we decompile java class, compiler will provide methods related to fields provided 
   - We cant set the data as all fields are final. Inside  record we cant create instance variable but we can create static variable 

   - Compact constructors are only allowed in Records

public class Sample {
    record Person(String name, String email,String phone) {
         int number; //error instance variable
         static int num;
     Person {
         if(name==null) {
             throw new IllegalArgumentException("Name is null");
     }

     //instance method error
     /* public String name() {
                return "hello";
       } */
}
PSVM {
    Person p1=new Person("Ram","ram@gmail.com","34444");
    System.out.println(p1.name());
 }
}

  - You can add static fields, static initializer and static methods. But you cannot add instance variable.

4. Packaging tool
     - Creates Platform specific installers out of jar files, so we know installing java on machine is prerequiste whenever we want to run any java appl
     - With help of JPackage, no need to install Java on client machine to run any Java appl
     - JPackage tool to package java appl into a platform specific package 
     - To execute any software we need any exe file and exe file will be executed in windows. In Java we have java and class files and we package into jar file and those jar file will be executed only in Java env.
     - Any client who dont have java software cannot execute those jar files 
     - Now java came with new packaging tool called JPackage so that we can convert our jar files into env specific. For MacOS, we can convert jar file into pkg and dmg file so that it can install in client machine. In windows we can convert jar file into msi or exe file and in linux as deb and rpm file 

1. Create java project with simple java program
2. Create executable jar file
   src>jar -cfe Sample.jar com.pack.Sample com/pack/*.class
3. copy the jar file inside another folder and in that we create exe file
3. Install Wix(Windows Installer XML tool) 3.0 from wixtoolset.org wix311-binaries
set wix311-binaries path in env variable
4. Use JPackage tool 
newfolder>jpackage --input . --name SampleApp --main-jar Sample.jar --main-class com.pack.Sample --type exe --java-options '--enable-preview' --win-shortcut
5. Install into exe and check how it is working


5. Text blocks 
   - Which is released as preview feature for 2nd time, it was originally introduced in Java 13
   - With text blocks we can use multi line string in java without using string concatention
   - When u want to store any HTML, JS and SQL code inside string in Java,we want to manually use string concatentation to construct them. With Text blocks we can just multiline string with """ and indentation of string is preseved by Java
   - Change in Java14 is we can add trailing (\) in one of line inside multi line string which tells the Java compiler to ignore the next coming line break

public class Sample { PSVM  {
   String html="<html>\n" +
               "  <body>\n" +
               "    <p>Hello world</p>\n"+
               "  </body>\n" +
               "</html>";
   String java13="""
                <html>
                   <body>
                      <p>Hello world</p>
                   </body>
                </html>""";
   String java14="""
                  <html>
                   <body>\
                      <p>Hello world</p>\
                   </body>
                </html>""";
System.out.println("Before Java 13");
System.out.println(html);
System.out.println("From Java 13");
System.out.println(java13);
System.out.println("From Java 14");
System.out.println(java14);
}}

Output:
Before Java 13
 <html>
    <body>
       <p>Hello world</p>
    </body>
 </html>

From Java 13
 <html>
    <body>
       <p>Hello world</p>
    </body>
 </html>

From Java 14
 <html>
    <body> <p>Hello world</p> </body>
 </html>


6. General JVM Improvements

1. G1 Garbage collector Improvements
       - Default garbage collector in Java which was introduced in Java9 
       - In Java14, this GC has been made NUMA aware(Non uniform memory access)
       - Goal is to improve performance of GC over lareg machines
       - Can be enabled by -XX+UseNUMA flag

2. Z Garbage Collector
      - Introduced in Java11 and in Java14, the pause time of GC is reduced to under 10ms. This was originally available only for Linux but with Java14 their ports avialable for Mac and windows 

3. CMS(Concurrent Mark Sweep) GC completely removed from Java14 




Java Mission Control 
https://github.com/cameronmcnz/Java-Mission-Control-Tutorial/tree/main/projects

1. Mission Control Plugin in Eclipse
       - If ur in eclipse, only plugin u can install is version 6 which is oracles which requires a commercial license. So we use open source AdoptOpenJDK plugin installed so u dont need that commercial license at all.
     In Eclipse Market Place, we can search Java Mission Control, but it is license version. So we get the latest version of JMC which build it from OpenJDK. 

1. Goto https://github.com/openjdk/jmc and try to clone to the jmc repo inside a folder
2. folder> git clone https://github.com/openjdk/jmc.git
    It created a folder jmc
3. Goto jmc/releng/third-party folder, where we can see bunch of third party lib that u need to build in order to get Java Mission Control and Java Flight Recorder plugin working
    Open gitbash inside third-party folder 
thirdparty>mvn p2:site
   - Which will set up whole website that going to host a maven repo with all these third party libraries.
    
4. After build success, Now hosts this site on jetty 
thirdparty>mvn jetty:run
This is all configured to host maven repo on localhost:8080 which is going to give the core build of JMC JFR eclipse plug-in access to the 3rd party libraries that it needs
    Let the prompt runs on Jetty server

5. Now go to jmc/core folder and open gitbash and need to build again
jmc/core> mvn clean install
    - compiles the code, run some test and then package all of the core stuff into appropriate jar file 

6. Now in same gitbash go to jmc folder
jmc/core>cd..
jmc> mvn package
    - So everything build in previous maven install will package it up into various jar files, one of jar file is java flight recorder maven plugin 

7. Once build sucess, under jmc folder we can see the folder called application.
  Inside that goto org.openjdk.jmc.updatesite.ide/target/ we can see the plugin for Java flight recorder
  org.openjdk.jmc.updatesite.ide-8.0.0.SNAPSHOT.zip

8. Now we need to install that plugin in Eclipse

Goto Eclipse - Help - Install New Software - Click Add - Click Archive - select the zip file from jmc/application/org.openjdk.jmc.updatesite.ide/target/  folder
  - Click Add - Select all checkboxes 
  - Click Next - Accept the agreement - Click Finish 
  - Restart eclipse ide

9. In eclipse we can see Java Mission Control icon in top
Under Local - Select Jetty server running - Start Flight Recording - click Finish 

localhost:8080/site/ - to see all available server running 

Which open Flight recording in that we can select memory, garbage collection , Threads(all class loading the thread that were in use and were blocked the memory the file socket, io etc)

2. Java Mission Control Overview
     We going to download it and install it and show you how to connect to an existing JVM and then do a Java Flight Recorder and take a look at some of the memory used and some of the cpu usage 
    To work with JMC u have to download it, it dosent come packaged with JDK anymore. 

1. Goto https://adoptopenjdk.net/jmc.html and download 
org.openjdk.jmc-8.0.0-win32.win32.x86_64.zip
    Extract it - Inside client jmc.exe file to start JMC
   Once started,it will load all the JVM's which is running on my local system, one of which is Jetty server which is already running.
   Under JVM browsing Tab we can see jvms running on the machine, under that we select Jetty server, under that we can see MBean Server and Flight Recorder
   Mbean server gives feedback on how your jvm is running right now, we got jetty server as we already running jetty server 
   Now if we refresh localhost:8080/site/, we can see needle moving as increase in memory 

2. Now we do flight recording
Right click Flight Recorder - Start Flight Recording - Finish 
    It gathers bunch of info about this jvm hosting, when u click refresh on jetty server we can see some sort of load and number of megs being used is increasing. This is MBean server this is giving us some live feedback on howour jvm is behaving. We will get JMC report once flight recorder is completed
   This will show information about the threads, memory, garbage collection all sorts of info about just what happened during that run. You can see little bit of cpu peaking  


3 ways to Start Java Flight Recorder in Eclipse

First way:
1. Configure DoSomething project in eclipse
2. Right click project - Run as Java application
3. Goto JVM Browser tab - Right click Flight Recorder - Start Flight Recording 
   Recording Time: 10s - Click Finish
4. Once recording is compelted, it show the result in JMC which provide info abt memory, abt thread and in Automated Analyse Result it show the completed result 
   Under Environment - Click ^ - we can see the number of completing resources running on my computer  

Second way:
1. In the same project we can provide Launchers, in that we use DoNothing Auto Record.launch, in this launcher we set some JVM arguments like flight recorder arguments
    We specify that the recordings starts after 5sec delay and 20s duration and the file would be saved in DoNothing folder 
2. Run as Java Application - Select Launcher - click ok
    It will start the recording for 20s duration, once complete, u just refresh the project 
    You can see the recording file, just double click it will open automated analysis of that appl with threads, memory and with feedback 

Third way:
1. Right click project - Run as Java application
2. Goto package of DoSomething.java - Right click package - show in local terminal 
  > jcmd 
which displays process id of that appl

>jcmd 1886 JFR.start duration=10s filename=recording.jfr 

It will take 10s to create the recording. Once done, just refresh the project, u can see the recording. Just double click the recording which generates the flight recording of the application.

LinkedList vs HashSet Performance Problem in JMC 
    - Here we see difference between LinkedList and HashSet when we have large number of elements in Java Collection. Now we see difference in performance between a linked list versus HashSet by using example

http://missioncontrol.mcnz.com/2020/12/10/Java_LinkedList_vs_HashSet_Performance.html

public class HotJavaMethodRunner implements Runnable {
	
	private static final int NUMBER_OF_THREADS = 8;

	public static void main(String[] args) throws Exception {
		ThreadGroup threadGroup = new ThreadGroup("Workers");
		Thread[] threads = new Thread[NUMBER_OF_THREADS];
		for (int i = 0; i < threads.length; i++) {
			threads[i] = new Thread(threadGroup, new HotJavaMethodRunner(), "Worker Thread " + i);
			threads[i].setDaemon(true);
			threads[i].start();
		}
		System.out.print("Press enter to quit!");
		System.out.flush();
		System.in.read();
	}
	
	public void run() {
		while (true) {
			WorkEvent event = new WorkEvent();
			Collection<Integer> firstBunch = new LinkedList<>();
			Collection<Integer> secondBunch = new LinkedList<>();
			
			//Collection<Integer> firstBunch = new HashSet<>();
			//Collection<Integer> secondBunch = new HashSet<>();
			
			event.begin();
			
			initialize(firstBunch, 3);
			initialize(secondBunch, 2);
			int intersectionSize = countMatches(firstBunch, secondBunch);
			
			event.setIntersectionSize(intersectionSize);
			event.commit();
			Thread.yield();
		}
	}
	
	public void initialize(Collection<Integer> collection, int modulus) {
		collection.clear();
		for (int i = 1; i < 100000; i++) {
			if ((i % modulus) != 0)
				collection.add(i);
		}
	}
	
	public int countMatches(Collection<Integer> first, Collection<Integer> second) {
		int count = 0;
		for (Integer i : first) {
			if (second.contains(i)) {
				count++;
			}
		}
		System.out.println(count);
		return count;
	}
	
}


1. In the above example we create 2 collection firstBunch and secondBunch which contains collection of Integers. FirstBunch is numbers from 1 to 100000 and mod by 3 and secondbunch is between 1 to 100000 and mod by 2 using initialize() method
   Once we got those two collection of numbers that are linkedlist initialized,we want to find the intersection (ie) how many numbers are same between first list and second list using countMatches()
    This example causes lot of computation and we are going to run this with JFR and take a look at how cpu and memory behaves. This kicks off 8 threads in my example and every time a thread kicks off we create a new work event 

import jdk.jfr.*;

@Label("Work")
@Category("02_JFR_HotMethods")
@Description("Data from one loop run in the worker thread")
public class WorkEvent extends jdk.jfr.Event {
	@Label("Intersection Size")
	@Description("The number of values that were the same in the two collections")
	private int intersectionSize;

	public int getIntersectionSize() {
		return intersectionSize;
	}

	public void setIntersectionSize(int intersectionSize) {
		this.intersectionSize = intersectionSize;
	}
}


We created a work called "Work", we started at the beginning of run() as event.begin() and we terminate at the end, this will keep track of how long it takes to actually run all of these  methods

2. Run the main class, we have Launcher confgiured here which will automatically run JFR and we made recording to save inside Recording folder, just refresh u can see  the recording 
  You click the recording and u can see it displays 

3. Instead of LinkedList we use HashSet. In linkedlist the larger the list is more difficult it is to process and bigger the performance implication. Hashset tends to have linear performace
Collection<Integer> firstBunch = new HashSet<>();
Collection<Integer> secondBunch = new HashSet<>();

4. Run the application, now u can see it was taking very less time to process compare to LinkedList 
   Now look at flight recorder in Recording folder, now it says high CPU load because my threads are running so quickly 





Soap UI
   - It is open source tool to perform any kind of API testing related to SOAP request as well as RETS request 
   - SOAP is used by large cooperation like Apple, Microsoft, Cisco, Oracle, HP, NASA, ebay, MasterCard, Intel, FedEx etc, so SOAP is basically made for large enterprise appl
   - It basically provides an easy interface and provides couple of drag and drop operations which will definitely help to create any kind of API, collection of worl with api testing
   - It is preferred for both SOAP and REST api 
   - SOAP Ui is a  heavy full fledged tool providing facility of data driven testing, since it supports programming language like Groovy  where u have more leverage over the tool
   - If u r not starter or u have advance level of knowledge expecially related to apis definitely go with SOAP UI and again totally depend on ur company level

Postman
   - It is not api testing tool, it is api development suite and it provides lot of different features like sharing your collection(set of apis), performing api testing, monitoring, documentation  of apis 
   - Easy for sharing reports, it is not made for large appl, it is considered to be work only with rest apis most of the time, but it will support soap request also in postman 
   - Postman is mostly made for small based companies 

			SoapUI			Postman
1. REST API testing	  yes			   yes
2. Soap API Testing	  yes			   no
3. Scripting lang	Groovy,js           Javascript


SoapUI 

What is SOAPUI?
   - API Testing Tool
   - For manual and automation testing of SOAP and REST APIs
   - Cross-platform tool
   - Built entirely over Java platform
   - uses Swing for GUI

Why to use SoapUI
1. To create quick and efficient API tests
2. To create API functional, performance and security tests
3. To create API Testing automation framework


Downloads and Installation
1. https://www.soapui.org/downloads/latest-release/
   - Download SOAP UI Open scource
2. create empty project
3. Right click project - Click New Rest Service From URI
4. Under URI: http://thomas-bayer.com/sqlrest/CUSTOMER/10
   Click OK
We can see Request Editor and Response editor
5. Click Run (green color icon) - we can see the response on response editor, where we can see response in xml, json and html format 
6. In the down we can see log section 


OCP - 1Z0-819 

To create jar file 
   >jar -cvf myFile.jar

To run Jar file
   >java -cp ".;c:\folder\myFile.jar" Animal(mainclass name)


package packagea;
public class ClassA{

}

package packageb;
import packagea.ClassA;
public class ClassB{
   PSVM(){
     ClassA a;
     System.out.println("Got it");
   }
}

>mkdir classes
   - create classes folder

>javac -d classes packagea/ClassA.java packageb/ClassB.java
   -Move class file to classes folder

To run :
>java -cp classes packageb.ClassB
           or
>java -classpath classes packageb.ClassB
           or
>java --class-path classes packageb.ClassB


Options u need to know for exam while compile:  javac

Option		          Description
1. -cp               Location of classes needed to --classpath compile
--class-path

2. -d <dirname>      Directory to place generated class file

3. -m <modulename>   Module name to compile
--module <name>

4. -p <path>         Location of jars in module prg
--module-path <path>

5. --module-source-path   Specify the location of module source files


Options u need to know for exam while running: java

Option 				Description
1. -cp <classpath>       Location of classes needed to run the program
-classpath <classpath>
--class-path <classpath>

2. -p <path>        Location of Jars in modular prg
--module-path <path>

3. -m <name>        Module name to run
--module <name>

4. -d              Describe the details of a module
--describe-module

5.--list-modules   List observable modules without running the program

6.--show-module-resolution      Shows module when running program


Option u need to know for exam for archieving: jar

Option 				Description
1. -c                 Create new JAR file
  --create

2. -v		      Prints details when working with jar
   --verbose

3. -f <filename>           JAR filename
--file <filename>

4. -C <directory>        Directory containing files to be used to create JAR

5. -d               Describe the details of module
--describe-module


Stack - methods, local variable, reference variables
Heap - Object, string pool


We can store char in any datatype

Datatype:

boolean b1=true;  

byte b=1;
b='a';  //97

short s=1;
s='a';
s=b;
b=s;   //error

int i=1;
i='a';
i=b;
i=s;
b=i;  //error
s=i;  //error


8E2 * 0 + 8E1 * 1 + 7E1 * 1
64 * 0 + 8 * 1 + 7 * 1 = 15

Literal and Underscore character
   Add underscore except
  1. at the beginning of literal
  2. end of literal
  3. right before decimal point 
  4. right after decimal point

int million=1_000_000; //1000000
int million=_1000.00;  //error
int million=1000.00_;  //error
int million=1000_.00;  //error
int million=1000._00;  //error
int million=1_00_0.0_0;  //1000.0

Identifier
    - name of variable, method, class, interface, pkg
    - must begin with letter, $ or _
    - Include numbers but not start with them
    - single underscore is not allowed
    - no keyword
    - Method and variable names are written in camelCase with first letter in lowercase
    - Class and interface are written with CamelCase
    - Constant, enum,static, final are capitial case

long l1=1;
l1=2147483648l;
l1='a';

float f=1;
f=2147483648L;  //2.14748365E9
f=3.14f;
f='a';

double d=1;
d=2147483648L;   //2.14748365E9
d=3.14f;
d=3.14;
d='a';

char c='a';
c=1;


Autoboxing - convert primitive to wrapper class
Unboxing - convert wrapper class to primitive

Order of Precedence
POST
PRE
Unary
Multi Div
Add Sub
Shift Relational Equalto Logical Shortcirucit Ternary Assignment

public class Primitive {

    //autoboxing in primitive types is allowed in literals
    long primitive() {
        boolean bo = true; //false

        byte b = (byte) 1;
        b = (short) 1;
        b = 1;//int (-128 to 127)
        b = (int) 1L;
        b = (int) 1.2345f;
        b = (int) 1.245;
        b = 'a'; //97

        short s = (byte) 1;
        s = (short) 1;
        s = 1; //int (-32,768 to 32,767)
        s = (int) 1L;
        s = (int) 1.2345f;
        s = (int) 1.245;
        s = 'a';

        s = b;
//        b = s;

        int i = (byte) 1;
        i = (short) 1;
        i = 1; //(-2,147,483,648 to 2,147,483,647)
        i = (int) 1L;
        i = (int) 1.2345f;
        i = (int) 1.245;
        i = 'a';

        i = b;
        i = s;
//        b = i;
//        s = i;

        long lo = (byte) 1;
        lo = (short) 1;
        lo = 1;
        lo = 2147483648L;
        lo = (long) 3.14f;
        lo = (long) 3.14;
        lo = 'a';

        float f = (byte) 1;
        f = (short) 1;
        f = 1;
        f = 2147483648L;//2.14748365E9
        f = 3.14f;
        f = (float) 3.14;
        f = 'a';

        double d = (byte) 1;
        d = (short) 1;
        d = 1;
        d = 2147483648L;//2.14748365E9
        d = 3.14f;
        d = 3.14; //double
        d = 'a';

        char c = 'a'; //97
        c = (byte) 1;
        c = (short) 1;
        c = 1; //int (0 to 65,535)
        c = (short) 1L;
        c = (short) 3.14f;
        c = (short) 3.14;
        return 1L;
    }

    public Long wrapper() {
        Boolean bo = false; //Autoboxing
        boolean boo = Boolean.valueOf(true); //unboxing

        //Before Java 5.0
        bo = Boolean.valueOf(true);
        bo = Boolean.valueOf("FALSE");

        boo = Boolean.parseBoolean("false");

        Byte b = (byte) 1;
        b = (short) 1;
        b = 1; //int
        b = (byte) 1L;
        b = (short) 1.2345f;
        b = (int) 1.245;
        b = 'a';

        Short s = (byte) 1;
        s = (short) 1;
        s = 1;
        s = (int) 1L;
        s = (int) 1.2345f;
        s = (int) 1.245;
        s = 'a';

        Integer i = 1;
        i = (int) 1L;
        i = (int) 1.2345f;
        i = (int) 1.245;
        i = (int) 'a';

        Long lo = (long) 1;
        lo = 1L;
        lo = (long) 3.14f;
        lo = (long) 3.14;
        lo = (long) 'a';

        Float f = (float) 1;
        f = 3.14f;
        f = (float) 2147483648L;//2.14748365E9
        f = (float) 3.14;
        f = (float)'a';

        Double d = (double)1;
        d = (double) 1L;
        d = (double)3.14f;
        d = 3.14;
        d = (double)'a';

        Character c = 'a';
        c = 1; //int (0 to 65,535)
        c = (int)1;
        c = (byte) 1L;
        c = (short) 3.14f;
        c = (char) 3.14;

        return 1L;
    }
}

boolean monkey = true == 3; //error
boolean ape = false != "Grape";  //error
boolean a = 10.2 == "koko"; //error


String and StringBuilder

https://github.com/mhussainshah1/HandleStrings/blob/master/StringPool.jsh

String Pool - intern pool
    There are 2 parts of memory, stack and heap. Stack is part of memory which loads the method data in form of stack one on the other 
    So first method load in stack is main(), in main() if we initialize any local variable or make any object, then local variable will go to stack and object in heap
    Consider we have 3 string objects like
String name="Fluffy";
String name1="Fluffy";
String name2=new String("Fluffy");

       Stack                                 Heap
      100 - name                                          String Pool
      100 - name1                  Object                 100 - Fluffy
      201 - name2                  201 - 100

100,201 - memory address
   So object reference name  will stay in stack and value will store in heap 
   So whenever we create string without  new keyword it goes in the string pool and string pool is a location in JVM contains reusable literal values and constants for fast memory processing.
       String name="Fluffy";
       String name1="Fluffy";
   So benefit of this if we make another string object and it has same value so instead of creating a new object it goes and check the string pool, if it is there then it provides the memory address to this reference, so both these objects point to same location in the memory 

  String name2=new String("Fluffy");
     So whenever we use a new keyword, compiler creates an new object in the memory for name2 and it first checks the string pool and if that string value is present it  copy the address of that string in that object as value and provide its memory address to the reference variable in the stack.

String name="Fluffy";
String name1="Fluffy";
String name2=new String("Fluffy");
name == name1;  //true
name == name2; //false

But at time of concatentation, consider we have

String  name3="Fluf"+"fy";
String name4="Fluf";
name4 += "fy";

So name3 and name4 will have same string "Fluffy" but one is pointing to String pool and other created the object.
   name3 is determine at the compile time, the complete string is "Fluffy" and stored in string pool as address 100 will be stored (ie) to name.
   But for name4, first time it is Fluf and Fluf goes to string pool, then we added "fy" and store back to name4 which is same like calling concat() which return string, so whenever we call a method so it creates a new object so name4 is not same because name4 created new object rather than going to string pool

String name3="Fluf"+"fy";
String name4="Fluf";
name4 += "fy";
name==name3; //true
name==name4; //false

String x="Hello World";
String y=" Hello World".trim();
x==y; //false
   Because first x will store in string pool and y is called with trim() so it create new object so it refers different object 


String s1="hello world";
String s2=new String("hello world");
s2=s2.intern(); //hello world, because it checks with string pool whether value already present so it copy the address of that value

s1==s2; //true

String s3="rat"+1;  //rat1 stored in string pool
String s4="r"+"a"+"t"+"1"; //rat1 stored in string pool
String s5="r"+"a"+"t"+new String("1"); //rat1 but new object created

s3==s4; //true
s3==s4.intern(); //true
s3==s5; //false
s3==s5.intern(); //true


Local Variable Type Inference - Var
    - It introduced in Java10 and purpose is to infer datatype at compile time. We can only use them in constructor, method and initializer block 
    - var is keyword used as local variable in constructor, method, initializer block, loops. The value of var can change but type cannot change 
    - var will check the value and assign the related datatype

Important notes:
    1. var can't declare without initial value. It is always initialized on same line or statment where it is declared
    2. var can be declared in first like and initialized in next line, because it is compile of two lines however it is 1 statement 
    3. var cannot be initialized with null value without a type 
    4. var is not permitted in multiple variable declartion
    5. var cannot be used to initialize array
    6. var cannot be used if return type is void 

public class Main {
    {
        var num = 1.0;
    }
    Main(){
        var name = "Main";
    }
    public static void main(String[] args) {
       var size = 7;

       for (var i = 0; i < 10; i++) {

       }

        for (var arg: args) {

        }

        size = 4;
       //size = "five"; //error we cant change its datatype

        //Can't do
        //1. Same line
//        var question;
/*        question =1;
        var answer;
        if(size == 4){
            answer = 2;
        } else {
            answer =3;
        }*/

        //Note 2
        var silly
                = 1;


        //Note 3
        //var n = null;  //error
        var o = (String) null;    //here we specify type before null

        var n = "my string";
        n = null;

        var m = 4;
        //m = null;  //error

        //Note 4 Compound Declaration
//        var a = 2 , b = 3;
//        int a, var b =3;

        //Note 5 Array
//        var prices = {9.95, 8.86};
    }
}


    6. var cant be used in parameters, return type and fields

public class VarKeyword {
/*    var name = "Hello";
    static var counter =0; //error
    public VarKeyword(var name) {  //error
        this.name = name;
    }
    public var getName() {  //error
        return name;
    }
    public var setName(var name) { //error
        this.name = name;
    }*/
}

    7. var is reserved type name but not reserved word (ie) it can used as an identifier except as a class interface or enum name
public class Var {
    public void var(){
        var var = "var";
    }
    public void Var(){
        Var var = new Var();
    }
}

/*class var{}
interface var{}
enum var{}*/

Important Points

1. Choose a variable name that provides useful information

public class Guideline1 {
    public static void main(String[] args) {
        List<String> result = List.of("hello", "how", "are", "you", "?");

        var stringsList = List.of("hello", "how", "are", "you", "?");

    }
}

2. Minimize the scope of local variable 

3. Consider var when the initializer provides sufficient information, so  here in below example right side provide sufficient information 

public class Guideline3 {
    public static void main(String[] args) throws IOException {
        var outputStream = new ByteArrayOutputStream();
        var reader = Files.newBufferedReader(Path.of(""));
        var list = List.of("a", "b", "c");

    }
}

4. Consider var to split chained or nested expression

 List<String> strings = List.of("hello", "hello", "how", "are", "you", "?");

    public Optional<String> getMaxEntry() {
        return strings.stream()
          .collect(groupingBy(s -> s, counting()))
                .entrySet()
                .stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey);


public class Guideline4 {
    List<String> strings = List.of("hello", "hello", "how", "are", "you", "?");

    public Optional<String> getMaxEntry() {
        var collect = strings.stream()
                .collect(groupingBy(s -> s, counting()));
        var max = collect
                .entrySet()
                .stream()
                .max(Map.Entry.comparingByValue());
        return max
                .map(Map.Entry::getKey);


    }
}

5. Do not worry too much programming to the interface with local variable 

public class Guideline5 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list = new CopyOnWriteArrayList<>();
        list = new LinkedList<>();

        var list1 = new ArrayList<>();
//        list1 = new CopyOnWriteArrayList<>();
//        list1 = new LinkedList<>();
    }
}

6. Take care using var with diamond or generic methods 

public class Guideline6 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        var list1 = new ArrayList<>();//since we didnt give it ArrayList<Object>()
        var list2 = new ArrayList<String>();

        var list3 = new ArrayList<>(list);//since we pass list which is ArrayList<String>(), so list3 is ArrayList<String>()
    }
}

7.Take care var with literals 

public class Guideline7 {
    public static void main(String[] args) {
        //No issue with Boolean, character, long, String and Floating Point
        var ready = true;//boolean
        var ch = '\ufffd';//char
        var sum = 0L;//long
        var label = "wombat";//String
        var f1 = 1.0f;//float
        var d1 = 3.0;//double

        //Whole number inferred as integer
        byte flags = 0;
        short mask = 0x7fff;
        long base = 17;

        var flags1 = 0; //int
        var mask1 = 0x7fff;//int
        var base1 = 17;//int

        var flags2 = (byte)0; //byte
        var mask2 = (short)0x7fff;//short
        var base2 = (long)17;//long
    }
}

var in Lambda Expression 
    - Lambda expr can also be implicitly typed with var syntax
           (var num) -> num+1;

public class LambdaExpression {
    public static void main(String[] args) {
        Function<Integer,Integer> f = (var num) -> 1;

//        var f1 = (var num) -> 1;

        BiFunction<Integer,Integer,String> f2 = (@Notnull var a,var b) -> "Hello";
    }
}
    - var can be used with annotation 
           (@NotNull var a,var b) -> a+b;
    - var can be used for non-denotable (anonymous class and intersection)

public class NonDenotable {
    public static void main(String[] args) {
        //Anonymous Class
        var productInfo = new Object() {
            String name = "Apple";
            int total = 0;
        };
        System.out.println("name = " + productInfo.name + ", total = " + productInfo.total);

}}

Cant do
1. you cant mix var and non var parameters
        (var a,Integer b)-> true;  //error
        (var a,var b)-> true; //correct
        (String x,var y,Integer z)->true; //error
        (var x,var y,var z)->3.14159; //correct

2. you cant mix var and explicit type parameters
        (var x, y) -> "goodbye"; //error
3. you cant omit parenthesis for single var parameter
        var w-> 99;  //error


Lambda Expression and Functional programming

Deferred Execution - in lambda object will not be created unless we call the implementation of method


Anonymous class			                 Lambda
1. It is an inner class                     1. Lambda is static 
It has an instance in memory                method in memory

2. keyword this represent inner             2. keyword this 
anonymous class                                represent enclosing class

3. It can have more than                    3. only one method
one method 

public class ConvenienceMethod {
    public static void main(String[] args) {
        //Predicate
        Predicate<String> egg = str -> str.contains("egg");
        Predicate<String> brown = str -> str.contains("brown");

//        Predicate<String> brownEggs = str -> str.contains("egg") && str.contains("brown");
        Predicate<String> brownEggs = egg.and(brown);
        System.out.println(brownEggs.test("eggbrown"));

//        Predicate<String> otherEggs = str -> str.contains("egg") && !str.contains("brown");
        Predicate<String> otherEggs = egg.and(brown.negate());

        //Consumer
        Consumer<String> c1 = x -> System.out.print("1: " + x);
        Consumer<String> c2 = x -> System.out.println(",2: " + x);
        Consumer<String> combined = c1.andThen(c2);
        combined.accept("Annie");

        //Function
        Function<Integer, Integer> before = x -> x + 1;
        Function<Integer, Integer> after = x -> x * 2;
        Function<Integer, Integer> combined2 = after.andThen(before);
        System.out.println(combined2.apply(3));//( 3 x 2) +1 = 7

        combined2 = after.compose(before);
        System.out.println(combined2.apply(3));//(3 + 1) x 2 = 8
    }
}


Variable in lambda expression

1. Parameter list

What is type of x in below code?

Predicate<String> p=x->true;   //string
---------------------------------------------------
public void whatAmI(){
   test((var x)->x>2,123);   //x is integer
}
public void test(Predicate<Integer> c,int num){
   c.test(num);
}
---------------------------------------------------
public void counts(List<Integer> list){
   list.sort((var x,var y)->x.compareTo(y));  //x is integer
}


2. Local variable inside lambda body
       Cannot create a local variable with the same name as one already declared in scope

(a,b) -> { int c=0; return 5;}  //correct
(a,b) -> { int a=0; return 5;}  //error

public void variables(int a){   //error 
    int b=1;
   Predicate<Integer> p1=a->{
             int b=0;
             int c=0;
             return b==c;};
}

3. Variable Reference from Lambda body
    Rules for accessing a variable from a lambda body inside a method

Variable Type				Rule
Instance Variable			Allowed
Static variable 			Allowed
Local variable			Allowed if effectively final
Method parameter                Allowed if effectively final
Lambda parameter		        Allowed

Effectively final - value cannot change and dont need to explicitly declare final

public class Closure {
    private static String staticVariable;
    private String instanceVariable;

    public void instanceMethod(final String parameter) {
        final String localVariable = "local";
        staticVariable ="allowed";

        Predicate<String> p = str -> (instanceVariable + parameter + localVariable + staticVariable).length() == 10;

//        parameter ="not allowed";
//        localVariable ="not allowed";

        staticVariable ="allowed";
        instanceVariable ="allowed";
    }
}


Optional class

public class MyOptional {

    public static Optional<Double> average(int... scores) {
        if (scores.length == 0)
            return Optional.empty();

        int sum = 0;
        for (int score : scores) {
            sum += score;
        }
        return Optional.of((double) sum / scores.length);
    }

    public static void main(String[] args) {
        System.out.println(average(90, 100));
        System.out.println(average());

        Optional<Double> opt = average(90, 100);
        if (opt.isPresent())
            System.out.println(opt.get());

        //or
        opt.ifPresent(System.out::println);

        opt = average();
//        System.out.println(opt.get());//NoSuchElementException

        String value = "";
        Optional o = (value == null) ? Optional.empty() : Optional.of(value);
        //or
        o = Optional.ofNullable(value);

        opt = average();
        System.out.println(opt.orElse(Double.NaN));
        System.out.println(opt.orElseGet(Math::random));// () -> Math.random()
//        System.out.println(opt.orElseThrow());//NoSuchElementException
//        System.out.println(opt.orElseThrow(IllegalAccessError::new));//() -> new IllegalAccessError()
//        System.out.println(opt.orElseGet(IllegalStateException::new));//Does not compile

        opt = average(90, 100);
        System.out.println(opt.orElse(Double.NaN));
        System.out.println(opt.orElseGet(Math::random));
        System.out.println(opt.orElseThrow());
    }
}


Stream API
    Sequence of data, it can be used only once
Types:  Finite and infinite

Lazy evaluation: delay execution until necessary - we pass lambda expr/method reference in the function and processor calls the method at its own

https://www.rapid7.com/blog/post/2017/01/13/java-8-lazy-argument-evaluation/

public class EagerVsLazyEvaluation {

    static boolean compute(String str) {
        System.out.println("executing...");
        // expensive computation here
        return str.contains("a");
    }

    static String eagerMatch(boolean b1, boolean b2) {
        return b1 && b2 ? "match" : "incompatible!";
    }

    static String lazyMatch(Supplier<Boolean> a, Supplier<Boolean> b) {
        return a.get() && b.get() ? "match" : "incompatible!";
        //call function here - if first part returns false then other doesn`t execute
    }

    public static void main(String[] args) {
        System.out.println(eagerMatch(compute("bb"), compute("aa")));//call function
        System.out.println(lazyMatch(() -> compute("bb"), () -> compute("aa")));
    }
}

When we call eagerMatch() it prints 
executing...
executing...
incompatible!
But when we call lazyMatch() it prints
executing...
incompatible!

When it comes to lazyMatch(), we call a.get() goes to compute() and get false and && which is short circuit operator, so if one is false it wont execute the next one. So in eagerMatch() we have 2 method calls but in lazyMatch() it is 1 method call  and it happens only at execution 

Intermediate vs Terminal operation
Scenario		Intermediate     Terminal
1. can exist multiple	    yes		    no
times in pipeline

2. Return type is stream    yes	 	    no

3. Executed upon method     no              yes
call

4. Stream valid after       yes             no
call


Advanced Stream Pipeline Concept

1. Linking streams to the underlying data

public class Linking {
    public static void main(String[] args) {
        var cats = new ArrayList<String>();
        cats.add("Annie");
        cats.add("Ripley");

        var stream = cats.stream();
        cats.add("KC");
        System.out.println(stream.count());
    }
}

2. Chaining Optional - calls one optional to another optional 

public class ChainingOptionals {
    public static void main(String[] args) {
        threeDigit_Java7(Optional.empty());
        threeDigit_Java7(Optional.of(4));
        threeDigit_Java7(Optional.of(123));

        threeDigit_Java8(Optional.empty());
        threeDigit_Java8(Optional.of(4));
        threeDigit_Java8(Optional.of(123));

        Optional<String> optional = Optional.of("123");
        Optional<Integer> result = optional.map(String::length);
        System.out.println(result.get());

        Optional<Optional<Integer>> result1 = optional.map(ChainingOptionals::calculator);
        System.out.println(result1.get().get());

        Optional<Integer> result2 = optional.flatMap(ChainingOptionals::calculator);
        System.out.println(result2.get());
    }

    private static Optional<Integer> calculator(String s) {
        return Optional.of(s.length());
    }

    private static void threeDigit_Java8(Optional<Integer> optional) {
        optional.map(n -> "" + n)
                .filter(s -> s.length() == 3)
                .ifPresent(System.out::println);
    }

    private static void threeDigit_Java7(Optional<Integer> optional) {
        if (optional.isPresent()) {
            Integer num = optional.get();
            String string = "" + num;
            if (string.length() == 3) {
                System.out.println(string);
            }
        }
    }
}

3. Collecting Results - used to group the results

1. Collecting using Basic Collectors
public class CollectingCollectors {
    public static void main(String[] args) {
        String result = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.joining(","));
        System.out.println(result);

        Double results = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.averagingInt(String::length));
        System.out.println(results);

        Set<String> result1 = Stream.of("lions","toads", "tigers", "bears")
                .filter(s -> s.startsWith("t"))
                .collect(Collectors.toSet());
        System.out.println(result1);

        TreeSet<String> result2 = Stream.of("lions", "toads", "tigers", "bears")
                .filter(s -> s.startsWith("t"))
                .collect(Collectors.toCollection(TreeSet::new));
        System.out.println(result2);
    }
}

2. Collecting into Maps using toMap()
       To create map we need to specify 2 functions
1). How to create key
2). How to create value 

public class CollectingMaps {
    public static void main(String[] args) {
        Map<String, Integer> map = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.toMap(s -> s, String::length));
        System.out.println(map);

        //reverse key into values
        Map<Integer, String> map1 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.toMap(String::length, s -> s, (s1, s2) -> s1 + "," + s2));
        System.out.println(map1);
        System.out.println(map1.getClass());

        TreeMap<Integer, String> map2 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.toMap(String::length,
                        s->s,
                        (s1, s2) -> s1 + "," + s2,
                        TreeMap::new));
        System.out.println(map2);
        System.out.println(map2.getClass());
    }
}

3). Grouping - group all the elements of the stream into Map using groupingBy()
   groupingBy(Function f)
   groupingBy(Function f, Collector c)
   groupingBy(Function f, Supplier s,Collector c)

public class Grouping {
    public static void main(String[] args) {
        Map<Integer, List<String>> map = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length));
        System.out.println(map);

        Map<Integer, Set<String>> map1 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length, Collectors.toSet()));
        System.out.println(map1);

        TreeMap<Integer, Set<String>> map2 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length, TreeMap::new, Collectors.toSet()));
        System.out.println(map2);

        TreeMap<Integer, List<String>> map3 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length, TreeMap::new, Collectors.toList()));
        System.out.println(map3);
    }
}

4. Partitioning - splitting list into 2 parts - true and false
      partitioningBy(Predicate p)
      partitioningBy(Predicate p, Collector c)

public class Partitioning {
    public static void main(String[] args) {
        Map<Boolean, List<String>> map = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.partitioningBy(s -> s.length() <= 5));
        System.out.println(map);

        map = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.partitioningBy(s -> s.length() <= 7));
        System.out.println(map);

        Map<Boolean, Set<String>> map1 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.partitioningBy(s -> s.length() <= 7, Collectors.toSet()));
        System.out.println(map1);

        Map<Integer, Long> map3 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length, Collectors.counting()));
        System.out.println(map3);

    }


Interface

1. Interface contains public static final constant variable
2. Interface contains abstract method
3. Interface contains default,static method from Java8
4. Interface contains private, private static method from Java9

public /*abstract*/ interface InterfaceSummary {
    /*public static final*/ int CONSTANT = 1;

    /*public abstract*/ int abstractMethod();

    /*public*/ default int defaultMethod(){abstractMethod(); privateMethod();staticMethod();  privateStaticMethod();return CONSTANT; }

    private int privateMethod(){abstractMethod();defaultMethod();staticMethod();privateStaticMethod();return CONSTANT;}

    /*public*/ static int staticMethod(){ privateStaticMethod(); return CONSTANT; }

    private static int privateStaticMethod(){ return CONSTANT;}

}

Instance method in interface can access static method
   - abstract
   - default
   - non static private

Class/static method in interface cant access instance method (ie) static and static private 

Interface Member access
1. Accessible from default and private methods within interface defination
    constant variable - yes
    abstract method-yes
    default method - yes
    private method - yes
    static method - yes
    private static method - yes

2. Accessible from static methods within interface defination
    constant variable - yes
    abstract method-no
    default method - no
    private method - no
    static method - yes
    private static method - yes

3. Accessible from instance methods implementing or extending the interface - Refer WithInterface.java
     constant variable - yes
    abstract method-yes
    default method - yes
    private method - no
    static method - yes
    private static method - no

4.Accessible outside interface without an instance of interface - Refer WithoutInterface.java
     constant variable - yes
    abstract method-no
    default method - no
    private method - no
    static method - yes
    private static method - no


public class WithInterface implements InterfaceSummary{
    @Override
    public int abstractMethod() {
        defaultMethod();
        InterfaceSummary.staticMethod();
        return CONSTANT;
    }
}


public class WithoutInterface {
    public int instantMethod() {
        InterfaceSummary.staticMethod();
        return InterfaceSummary.CONSTANT;
    }
}


Create and use Enumeration
     - It is type of class that mainly contains constants or fixed set of values
     - It implicitly extends from abstract class java.lang.Enum
     - It is implicitly final (ie) it cannot extend but implements interface
     - It provides type-safe checking, invalid enum value introduce compiler error


public enum Day /*implements MyInterface*/{
    SUNDAY,
    MONDAY,
    TUESDAY ,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY;
}
interface MyInterface{

}

/*public enum ExtendedEnum extends Day{
}*/


public class Main {
    public static void main(String[] args) {
        Day d = Day.TUESDAY;
        //Day d=2;  //error
        Day d1 = Day.valueOf("TUESDAY");
      // d1 = Day.valueOf("tuesday"); //compiler error because no enum tuesday

        System.out.println(d == d1);
        System.out.println(d.equals(d1));
        System.out.println(Day.SUNDAY);
        System.out.println(d.toString());

        for (Day day: Day.values() ) {
            System.out.println(day.name() + " " + day.ordinal());
        }

        /*if (Day.THURSDAY == 4){    //compiler error

       }*/
}


Important notes
1. Values are declare first
2. Values end with semicolon,if there is anything besides value show compiler error

public enum Day {
    int i=4; //compiler error

    SUNDAY,
    MONDAY,
    TUESDAY ,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY;
   
    private String temparature; //correct but previously u should end with semicolon
}

3. A non final enum method can be overridden by any enum value

public enum Day {
    int i=4; //compiler error

    SUNDAY {
      public void printTemperature(){            System.out.println(75);
    }},
    MONDAY,
    TUESDAY ,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY;
   
    private String temparature; 

    public void printTemperature(){                     System.out.println(65);
    }
}
So sunday have overridden method and rest of days have default value 

public class Main {
    public static void main(String[] args) {
       d.printTemperature();  //prints 65
       Day.SUNDAY.printTemperature(); //prints 75
    }
}

4. If we have abstract method then it should be implemented 

public enum Day {
    int i=4; //compiler error

    SUNDAY {
      public void printTemperature(){            
           System.out.println(75);
    }},
    MONDAY{
      public void printTemperature(){            
           System.out.println(65);
    }},
    TUESDAY{
      public void printTemperature(){            
           System.out.println(75);
    }} ,
    WEDNESDAY{
      public void printTemperature(){            
           System.out.println(85);
    }},
    THURSDAY{
      public void printTemperature(){            
           System.out.println(65);
    }},
    FRIDAY{
      public void printTemperature(){            
           System.out.println(75);
    }},
    SATURDAY{
      public void printTemperature(){            
           System.out.println(85);
    }};
   
    private String temparature; 

    public abstract void printTemperature();
}


Constructor
  - Implicitly private 
  - Called once in the beginning to create enum values.


public enum Day{
    SUNDAY("High"){ public void printTemperature(){ System.out.println(75); }},
    MONDAY ("Moderate"){ @Override public void printTemperature() {System.out.println(65);}},
    TUESDAY ("High"){ @Override public void printTemperature() {System.out.println(75);}},
    WEDNESDAY("High") { @Override public void printTemperature() {System.out.println(85);}},
    THURSDAY ("Moderate"){ @Override public void printTemperature() {System.out.println(65);}},
    FRIDAY ("High"){ @Override public void printTemperature() {System.out.println(75);}},
    SATURDAY ("High"){ @Override public void printTemperature() {System.out.println(85);}};

    private String temperature;

    /*private*/ Day (String temperature){
        this.temperature = temperature;
    }

    public  abstract void printTemperature();

}

5. Enum can also used in switch

switch (d){
            case SUNDAY:
                System.out.println("Go to beach");
                break;
            case MONDAY:
                System.out.println("Go back to work");
                break;
            case TUESDAY://Error- Day.TUESDAY: , 2
                System.out.println("I am at work");
                break;
            default:
                System.out.println("Are you at work?");
        }


Compiler error
   Code will not compile if 
     1. Values are not declared first
     2. Constructor contains public or protected modifier
     3. Switch block - contains case as Enum.TYPE
     4. extends an enum
     5. compare enum value with integer


Multithreading - Concurrency

Thread 
   It is smallest unit of execution that can schedule by OS

Process
   It is group of one or more threads that are run in shared env

Shared Environment
   Multiple threads run in the same memory space an d talk to each other directly. If they are not in shared env, two threads cannot talk 

Single Threaded Process
   It is process that have exactly one thread
Multi Threaded Process
   It is process that have more than one thread 

Consider we have a process and let say its a java program and then any process that is run by OS will have a memory associated with it where it stores all info that needs to run the program. Let say this program has multiple threads in it, so all the thread will use this memory that is reserved for the process. When the threads has to do some computation it needs CPU and to get CPU it takes the help of OS thread scheduler, thread scheduler is build in OS, which is used to find a CPU that is available for a given thread 

2 types of Thread
1. System Thread 
      It is threads that we do not interact directly with. For example when we run a java program there are some background threads running (ie) Garbage collector that cleans up memory periodically and as a programmer we dont directly deal with garbage collector, so JVM takes care of it and runs in backend
2. User defined thread 
      It is the thread that we will create in our program. Every java program that we run are multithreaded program and we didnt dealt with system thread directly and jvm creating other threads and the program we have written in the main() is just one of the thread that jvm controls

Thread concurrency
     We know OS thread scheduler is sitting between thread and CPU's so that scheduler uses an algorithm to decide which threads get the CPU time
1. Round Robin Scheduling in which a fixed amount of time is given to each thread and as soon as that time amount is over the thread is taken out of CPU and the next thread is put in for the computation. OS goes in round robin fashion starting with thread one to last thread and comes back again to thread one and so on

2. Priority based scheduling
      OS scheduler will always pick a thread which is of higher priority, so priority which is associated with the thread represent as integer number, if scheduler sees higher priority coming in it moves out the lower priority thread out of CPU and gives CPU with higher priority thread 
      The process where the OS takes out a thread from CPU and puts a new thread is known as context switching

Polling
   Eventhough multithreaded program allows u to run tasks in parallel there is often a situation where one thread needs to wait for another thread, we can do using polling
   Polling is a process where one thread constantly checks if the other thread is done before it continues 

Polling using static variable
     We create main thread and that main thread will start another thread, lets call that new thread as IncrementNumber which has static variable called counter, and static variable will be accessed by both the threads. 
     So IncrementThread will keep on incrementing the counter variable and main thread will keep constantly checking the value of counter as soon as the value goes above defined value, the main thread will continue with its process

public class CheckResult {
    private static int counter=0;
    PSVM throws InterruptedException{
        new Thread(() -> {
           for(int i=0;i<500;i++) {
              CheckResult.counter++;
           }
        }).start();
  
      while(CheckResult.counter < 400){
         System.out.println("Not reached, keep waiting");
         Thread.sleep(1);
      }
       System.out.println("End of main thread");
   }
}


Single Thread Executor 
    We have seen 2 ways to create thread, but as the program gets bigger and bigger it becomes bit complex to do all the thread managment tasks manually. Java have concurreny API to handle the complicated work of managing threads

ExecutorService Interface
   It defines the operation that can done on thread, since this is an interface we need a concrete class that will have the implementation and concurrency api provides a way to get that concrete class.
   We can get instance of single thread executor using below code, once we get hold of executor we can ask to execute as many task using execute() and then we need to shutdown the executor so if we do not shutdown then program keep on going

  ExecutorService e=Executors.newSingleThreadExecutor();
   e.execute(task);
   e.shutdown();

In the above code we are creating thread executor service that will manage only one thread so if we ask to execute multiple tasks all those tasks will be executed synchronously (ie) in sequence one after the other but those tasks will happen in parallel to the main thread 

Consider we create thread with task1 which prints simple statement and task2 which print from 0 to 4. Now we create instance of SingleThreadExecutor and execute task1,task2,task1 and finally shutdown the executor

public class Main { PSVM {
    System.out.println("Start of Main thread");
    Runnable task1=() -> {
               System.out.println("Task 1: Simple print");
    };
    Runnable task2=() -> {
           for(int i=0;i<5;i++){
               System.out.println("Task 2:i="+i);
           }
    };

    ExecutorService e=null;
    try { 
       e=Executors.newSingleThreadExecutors();
       e.execute(task1);
       e.execute(task2);
       e.execute(task1);
    }
    finally {
       if(e!=null) {
          e.shutdown();
       }
    }
    System.out.println("End of main thread");
   }
}

Start of Main thread
Task 1: Simple print
Task 2:i=0
Task 2:i=1
Task 2:i=2
Task 2:i=3
Task 2:i=4
Task 1: Simple print
End of main thread

Here we can see each task will execute sequentially because we use SingleThreadExecutor which happend in sequence and in parallel to main thread 

Shutting down Executor service
    - e.shutdown() does not actually stop any task  that have been submitted to thread executor, it will wait for all the tasks to finish and then shutdown the executor 
    - e.shutdownNow(), let say we have given multiple tasks to the executor service, at any given point there will be some tasks that already have been finished, there will be some tasks that are in process at that particular time and there will be tasks in queue that are still to be executed. When shutdownNow() is hit the tasks that are currently in process, the executor service  attempts to stop them and tasks that are not yet started those tasks will not be executed and returns list of runnable tasks that are never executed  

public class Main { PSVM {
    System.out.println("Start of Main thread");
    Runnable task1=() -> {
               System.out.println("Task 1: Simple print");
    };
    Runnable task2=() -> {
           for(int i=0;i<5;i++){
               System.out.println("Task 2:i="+i);
           }
    };

    ExecutorService e=null;
    try { 
       e=Executors.newSingleThreadExecutors();
       e.execute(task1);
       e.execute(task2);
       e.execute(task1);
    }
    finally {
       if(e!=null) {
          List<Runnable> t=e.shutdownNow();
          System.out.println(t.size()+"tasks never got run");
       }
    }
    System.out.println("End of main thread");
   }
}

Start of main thread
Task 1: Simple Print
2 tasks never got run
End of main thread 

Now it will exexute task1 and by the time it got shutdownNow request so it didnt execute the other 2 tasks 

Concurrency - submit,invokeAll/any
    We have seen how to ask executor service to run tasks in a thread, we have used execute() but we not assigned the output of execute() to any variable because execute dosent return anything. This way of doing job is called fire and forget where u ask someone to do the task and dont care when it is finished or it finished successfully.
   But if task returns some value and we want to get hold of that then we use submit(). The main difference between execute() and submit() is that submit() returns a Future object, this object represent the task and we can get the state of the task at any given point of time

ExecutorService method
1. void execute(Runnable task) - Takes Runnable task but does not return anything and task is executed some point in the future

2. Future submit(Runnable task) - Takes Runnable task and returns Future object representing the task. 

3. Future submit(Callable task) - Takes Callable task as input 
   Callable is similar to Runnable, Callable will return something back. This submit() return Future object and we can use the Future object to get the value returned from the Callable

4. List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException
    It takes list of Callable tasks and wait for all of them to finish. This call is blocking call which means unless all the tasks are finished the control in the  code will not move forward and once the tasks are finished the method will return a list if future in the same order in which we gave the list of  tasks to it to execute

5. T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException
    It takes a list of Callable tasks and wait for at least one to finish, it returns the result of finished task, when anyone of task is finished then it cancels the remanining unfinished tasks 

Future interface
   - Used to get more information about the given tasks

1. boolean isDone()
      This method returns true if task is completed, completion may be due to normal termination that is task completed successfully or the task could have thrown exception or task would have been cancelled in all cases this method will return true 

2. boolean isCancelled()
      Returns true if this task was cancelled before it completed normally

3. boolean cancel(boolean b)
      Attempts to cancel a task, return true if its successfully cancelled, false if it could not be cancelled or its already finished

4. V get()
      Waits if necessary for the computation to complete, and then retrieves its result that return from task. This method will wait until the task is complete no matter how long the task takes 

5. V get(long timeout, TimeUnit unit)
      We give timeout and say that if the task has finished then return the result of the task but if it does not finish in provided time period then return back without getting the result 


Example:
   Here we create ExecutorService using newSingleThreadExecutor and submit a runnable task which just increment number from 1 to 500 and return the output of submit() to Future called result and we make result to wait for 10sec (ie)maximum time waiting for result. If the task completes successfully then it comes to print statement within 10sec, if the task dosent complete within 10sec then it will throw an exception 

public class Main {
   private static int counter=0;
   PSVM() throws ExecutionException, InterruptedException {
      ExecutorService service=null;
   try {
     service = Executors.newSingleThreadExecutor();
     Future<?> result=service.submit(() -> {
         for(int i=0;i<500;i++) {
             Main.counter++;
         }
     )};
     result.get(10,TimeUnit.SECONDS);
     System.out.println("Task Completed");
   }
   catch(TimeoutException e){
      System.out.println("Not completed task");
   }
   finally {
       if(service!=null){
           service.shutdown();
       }
   }
  }
}


Callable Interface
   @FunctionalInterface
   public interface Callable {
       V call() throws Exception;
   }

We create AddData class which add two numbers in a separate thread and return back to main thread, since we returning result we cannot use Runnable we use Callable.
    Here we create ExecutorService using newSingleThreadExecutor and submit a task as callable to it and in this task we simply add 2 numbers and return the response  as Future. Here we didnt give timeout so the call will wait for the callable task to finish and move on and no matter how long callable task takes 

public class Main {
   PSVM() throws ExecutionException, InterruptedException {
      System.out.println("Start of main thread");
      ExecutorService service=null;
   try {
     service = Executors.newSingleThreadExecutor();
     Future<?> result=service.submit(() -> 1+2);
     System.out.println("Result ="+result.get());
   }
   catch(TimeoutException e){
      System.out.println("Not completed task");
   }
   finally {
       if(service!=null){
           service.shutdown();
       }
   }
   System.out.println("End of main thread");
  }
}

So here get() waits until Callable task is finished 


Submitting Multiple tasks using invokeAll/invokeAny
    We create Callable task which return the string,and create ExecutorService. Now we call invokeAll which takes list of callable task and we give same task 3 times and finally return List<Future>. We use for loop to print the output of each callable 

public class Main {
   PSVM() throws ExecutionException, InterruptedException {
      System.out.println("Start of main thread");
      Callable<String> task=()->"Return from the thread";
      ExecutorService service=null;
   try {
     service = Executors.newSingleThreadExecutor();
     List<Future<String>> result=service.invokeAll(Arrays.asList(task,task,task));

     for(Future result:results){
          System.out.println(result.get());
     }
   }
   finally {
       if(service!=null){
           service.shutdown();
       }
   }
   System.out.println("End of main thread");
  }
}

Output:
Start of main thread
Result from the thread
Result from the thread
Result from the thread
End of main thread

So here invokeAll() only return back when all 3 tasks that we gave to it finished.

invokeAny:
   It will return the result of the task that is completed 

public class Main {
   PSVM() throws ExecutionException, InterruptedException {
      System.out.println("Start of main thread");
      Callable<String> task=()->"Return from the thread";
      ExecutorService service=null;
   try {
     service = Executors.newSingleThreadExecutor();
    String result=service.invokeAny(Arrays.asList(task,task,task));
          System.out.println(result);
     
   }
   finally {
       if(service!=null){
           service.shutdown();
       }
   }
   System.out.println("End of main thread");
  }
}

Output:
Start of main thread
Return from the thread
End of main thread

Even though we asked to run 3 callable task, it just run anyone of task and whichever finishes the earliest it returns the response back and cancels the other 2 tasks 

Waiting for result: 
     ExecutorService service=null;
   try {
     service = Executors.newSingleThreadExecutor();
     Future<?> result=service.submit(() -> {
         for(int i=0;i<500;i++) {
             Main.counter++;
         }
     )};
     result.get(10,TimeUnit.SECONDS);
     System.out.println("Task Completed");
   }
   In the previous example we have submitted runnable task and then we use Future object to wait  on the task to finish, we have another way to achieve this functionality ExecutorService awaitTermination() and we give timeout until when we want the executor to wait for the task to finish

public class Main {
   private static int counter=0;
   PSVM() throws ExecutionException, InterruptedException {
      ExecutorService service=null;
   try {
     service = Executors.newSingleThreadExecutor();
     Future<?> result=service.submit(() -> {
         for(int i=0;i<500;i++) {
             Main.counter++;
         }
     });
   }
   finally {
       if(service!=null){
           service.shutdown();
       }
   }
   if(service!=null){
      service.awaitTermination(10,TimeUnit.SECONDS);
      if(service.isTerminated()){
         SOP("Task Completed");
      } else {
         SOP("Atleast one task is still running"):
       }
     }
   }
  }
}


How to schedule a task using Concurrency API?
     Consider we want to create a job which runs at every 5min and check the status of another program thats running or we want to generate and send a report at the end of day. For these type of scenarios we want the task to happen at regular intervals and concurreny api provides a way to do that
     Concurrency API has an interface called ScheduledExecutorService for this purpose and this interface extends ExecutorService 

ScheduledExecutorService e=Executors.newSingleThreadScheduledExecutor();

Methods:
1. public ScheduledFuture<?> schedule(Runnable task, long delay, TimeUnit t)
    This method will run the task that we provided with delay of time we provided and return type is ScheduledFuture
   ScheduledFuture is an interface which extends Delayed and Future interface 
   Delayed interface has method long getDelay(TimeUnit t) and returns the time that is left for the task to run 
 
2. public ScheduledFuture<?> schedule(Callable task, long delay, TimeUnit t)
    It takes callable and we see Runnable dosent return anything and Callable returns value from thread so depends on scenario we can use any method

3. public ScheduledFuture<?> scheduleAtFixedRate(Runnable task, long initialDelay,long period, TimeUnit t)
     Used to run the task at regular provided interval, previous 2 methods will only fire the task only once 

4. public ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, long initialDelay,long period, TimeUnit t)
    The difference between the above method is the delay that we provide, time period will only counts when the previous job is done. Say we have long running job, say the job that u run takes 2min and delay we give is 1min, in this case job will run for 2 min and there will be delay after first job is finished and then again the job will be kicked which will take another 2 min 
   Whereas in previous method it dosent care about if ur job is finished, whenever the time period we have given expires it schedules another job

Example 1:
   We create Callable task which return string value, we create ScheduledExecutorService and we call schedule() which takes the task and run the task after 5sec 

public class Main {
    PSVM() throws ExecutionException, InterruptedException {
    Callable<String> task=()->"Returned from thread";
    ScheduledExecutorService service=null;
    try {
        service=Executors.newSingleThreadScheduledExecutor();
ScheduledFuture future=service.schedule(task,5,TimeUnit.SECONDS);
System.out.println(future.get());
}
finally {
   if(service!=null){
       service.shutdown();
   }
}
}}

When we run it will wait for 5sec timeout and then it will print the output 

Example 2: We use Runnable

public class Main {
    PSVM() throws ExecutionException, InterruptedException {
    Runnable<String> task=()->System.out.println("Returned from thread");
    ScheduledExecutorService service=null;
    try {
        service=Executors.newSingleThreadScheduledExecutor();
ScheduledFuture future=service.schedule(task,5,TimeUnit.SECONDS);
}
finally {
   if(service!=null){
       service.shutdown();
   }
}
}}

When we run it will wait for 5sec timeout and then it will print the output

Example 3:
   Here we give initial delay of 5sec and once time expires we want the job to run every second. In case of scheduleAtFixedRate or scheduleAtFixedDelay we dont shutdown executor because if u shutdown then it will stop working 

public class Main {
    PSVM()  {
    Runnable<String> task=()->System.out.println("Returned from thread");
    ScheduledExecutorService service=null;
    
        service=Executors.newSingleThreadScheduledExecutor();
ScheduledFuture future=service.scheduleAtFixedRate(task,5,1,TimeUnit.SECONDS);
}}

First it will wait for initial 5sec delay after that it will run thread for every 1 sec

If we want executor to shutdown then we need to write extra logic so here we sleep for 10sec and then shutdown the executor and after sleep we will cancel the task

public class Main {
    PSVM() throws InterruptedException {
    Runnable<String> task=()->System.out.println("Returned from thread");
    ScheduledExecutorService service=null;
    try {
        service=Executors.newSingleThreadScheduledExecutor();
        ScheduledFuture future=service.scheduleAtFixedRate(task,5,1,TimeUnit.SECONDS);
        Thread.sleep(10000);
        future.cancel(true);
    }
    finally {
   if(service!=null){
       service.shutdown();
   }
}
}}

Here we ask ScheduledExecutorService to schedule the task, then main thread will sleep for 10sec after that we cancel the task using cancel() after that goes to finally block and stops the executor 

Example 4:
  Now we want the task to some time to execute by using sleep()

public class Main {
    PSVM()  {
    Runnable<String> task=()->{
         System.out.println("Start of task");
         try {   Thread.sleep(5000); }
         catch(InterruptedException e){ }
         System.out.println("End of task");
    };
    ScheduledExecutorService service=null;
    
        service=Executors.newSingleThreadScheduledExecutor();
ScheduledFuture future=service.scheduleAtFixedRate(task,5,1,TimeUnit.SECONDS);
}}

First program will wait for 5sec initial delay and now task is started but it is long running task and then task ended and next task is already started. The reason next task immediately starts was it has already passed that 1sec period, so 1sec period starts as soon as task is kicked off. Since the task ran longer than our time period the next task ran immediately after that.
   In case if we want a gap between first and second task then we use scheduleWithFixedDelay is used


public class Main {
    PSVM()  {
    Runnable<String> task=()->{
         System.out.println("Start of task");
         try {   Thread.sleep(5000); }
         catch(InterruptedException e){ }
         System.out.println("End of task");
    };
    ScheduledExecutorService service=null;
    
        service=Executors.newSingleThreadScheduledExecutor();
ScheduledFuture future=service.scheduleWithFixedDelay(task,5,1,TimeUnit.SECONDS);
}}

First it waits for initial 5sec delay, the thread is started since its long running we are waiting for it to finish and thread finished. Next we can see a gap inbetween start of next one and end of previous one and this gap is due to 1sec period we gave 


Thread Pools
    We has created a main thread and that starts execution and at some point its going to create ExecutorService using newSingleThreadExecutor() which will handle only one thread . Now if main() want to execute a task it will ask ExecutorService to execute the task in a different thread, since this is singleThreadExecutor it gives the task to one thread it manages and the task gets executed.
    Now the main thread gives 4 tasks to the executor then the ExecutorService makes use of 1 thread it has to execute those tasks, now the tasks will be executed one after the other in sequence, they do happen in parallel to the main thread but there is no concurrency within the task itself. If you want to these 4 tasks to be run in parallel thats where Thread pool is used

Introduction to Thread Pool
    We will start the main thread and at some point in main thread we create ExecutorService which handle 4 threads. Now let say main thread wants the 4 tasks to be executed, then its going to handover those 4 tasks to the executor service and ask to execute into the threads. ExecutorService will take each task and assign a thread to the task, since ExecutorService have 4 different threads that its managing all 4 threads will execute those tasks in parallel along with main, so main is 5th thread in this case 

How to get Thread Pool Executors?
3 methods
1. ExecutorService newFixedThreadPool(int)
       This method will return ExecutorService which will manage a fixed number of threads and that number of threads will be determined by parameters that we pass 

2. ExecutorService newCachedThreadPool()
       We are not passing integer number which means we are not predefining the number of threads so ExecutorService will create threads on demand so as soon as it receives a task it creates a thread and does that task, if it receives multiple tasks in parallel that means if one task is running and before it finishes, it receives another task then it will create a second thread so once the task is finished, the thread stays for 1min and if no new tasks coming then thread will discarded 

3. ScheduledExecutorService newScheduledThreadPool(int)
      Used to get ScheduledExecutorService which schedule the task at sometime in future and it can be recurring task, to get a scheduledExecutorService which manages more than one thread we use newScheduledThreadPool and pass an integer 

Example 1:
   In main() we create Runnable task and print thread id using Thread.currentThread.getId() which will assigned by default to each thread with sleep of 5 sec.
   Now create ExecutorService which  manage 4 different threads , now we submit the task 4 times (ie) we give 4 tasks to thread executor to run 

public class Main { PSVM {
   Runnable task = () -> {
       System.out.println("Start of task with id="+Thread.currentThread().getId());
     try {  Thread.sleep(5000); }
     catch(InterruptedException e){ }
   };
  
  ExecutorService service=Executors.newFixedThreadPool(4);
  try {
       service.submit(task);
       service.submit(task);
       service.submit(task);
       service.submit(task);
  }
  finally {
      if(service!=null)
          service.shutdown();
  }
 }
}

Now we can see all 4 task will be started in parallel and once 5sec sleep is over it ends the task and all 4 tasks taking exactly 5sec

Example 2:
  Instead of giving fixed sleep of 5sec to all task, we give random sleep by using Random class. So it will return intefer number between 0 to 20, when we submit 4 tasks all tasks will have different sleep times  

public class Main { 
    private static Random random=new Random();
   PSVM {
   Runnable task = () -> {
       int sleepTime=random.nextInt(20);
       System.out.println("Start of task with id="+Thread.currentThread().getId()+" "+sleepTime+"seconds");
     try {  Thread.sleep(sleepTime+1000); }
     catch(InterruptedException e){ }
   };
  
  ExecutorService service=Executors.newFixedThreadPool(4);
  try {
       service.submit(task);
       service.submit(task);
       service.submit(task);
       service.submit(task);
  }
  finally {
      if(service!=null)
          service.shutdown();
  }
 }
}

Now we can see different task taking different time to run.

Example:
   Now we use newCachedThreadPool(), so in this case when executor starts it dosent have any thread but as we submit the task it actually creates a new threads on fly 

public class Main { 
    private static Random random=new Random();
   PSVM {
   Runnable task = () -> {
       int sleepTime=random.nextInt(20);
       System.out.println("Start of task with id="+Thread.currentThread().getId()+" "+sleepTime+"seconds");
     try {  Thread.sleep(sleepTime+1000); }
     catch(InterruptedException e){ }
   };
  
  ExecutorService service=Executors.newCachedThreadPool();
  try {
       service.submit(task);
       service.submit(task);
       service.submit(task);
       service.submit(task);
  }
  finally {
      if(service!=null)
          service.shutdown();
  }
 }
}

We can see 4 tasks in parallel with random delays and once all 4 of them finishes, the program ends

Example:
  Now we provide newScheduledThreadPool() which return ScheduledExecutorService and we can schedule the first task 5 sec later and schedule second task 6sec later, 3rd task 7sec later and 4th task 8sec later

public class Main { 
    private static Random random=new Random();
   PSVM {
   Runnable task = () -> {
       int sleepTime=random.nextInt(20);
       System.out.println("Start of task with id="+Thread.currentThread().getId()+" "+sleepTime+"seconds");
     try {  Thread.sleep(sleepTime+1000); }
     catch(InterruptedException e){ }
   };
  
  ScheduledExecutorService service=Executors.newScheduledThreadPool(4);
  try {
       service.schedule(task,5,TimeUnit.SECONDS);
       service.schedule(task,6,TimeUnit.SECONDS);
       service.schedule(task,7,TimeUnit.SECONDS);
       service.schedule(task,8,TimeUnit.SECONDS);
  }
  finally {
      if(service!=null)
          service.shutdown();
  }
 }
}

First it will wait for initial delay for each task and one by one it will schedule all 4 tasks with random sleep and all 4 tasks running in parallel


Understanding the problem of Thread Safety
     We create static variable and then we create 10 different threads and ask each thread to increment and print the number

public class Main {
  private static Integer counter=0;
  PSVM() {
    ExecutorService service=Executors.newFixedThreadPool(10);
    try {
       for(int i=0;i<10;i++) {
          service.submit(() -> {
             System.out.println(++counter+" ");
          });
       }
    } finally {
        if(service != null) 
           service.shutdown();
      }
   }
}

Here each thread would go and get the counter, increment the counter to its next value and it should print from 1 to 10. But when we run it is very different.

Problem with the code we wrote
1. Duplicity
2. Missing Number (only incremented number until 8 not 10)
3. Output are not in sequence 

   So when the program starts we have created counter static variable and in main thread once the execution starts we create ExecutorService and then submit 10 tasks to it to increment 1 number. Since ExecutorService managing 10 different threads so it will use each thread to increment the counter once,due to parallel task that we are running we have this problem 


Increment Operation using Atomic class
     Since all classes are thread safety in Atomic class we dont want to worry about thread safe 

public class Main {
  private static AtomicInteger counter=new AtomicInteger();
  PSVM() {
    ExecutorService service=Executors.newFixedThreadPool(10);
    try {
       for(int i=0;i<10;i++) {
          service.submit(() -> {
             System.out.println(counter.incrementAndGet()+" ");
          });
       }
    } finally {
        if(service != null) 
           service.shutdown();
      }
   }
}

Now all 10 threads have incremented the variable exactly once and print the number from 1 to 10 but not in order 

3 Atomic class 
    1. AtomicInteger
    2. AtomicLong
    3. AtomicBoolean 
All are used to do operations in thread safe way

Common Atomic Methods
1. get() - get the value
2. set() - set the value 
3. getAndSet() - used to set new value that is passed in and method returns old value that was stored in the variable 
4. incrementAndGet() - equivalent to pre increment
5. getAndIncrement() - equivalent to post increment
6. decrementAndGet() - equivalent to pre decrement
7. getAndDecrement() - equivalent to post increment


Writing Thread Safety Code using Synchronized Block
      Previously we saw Atomic classes to achieve thread safety in increment operation. Now we have a requirement that we want to print all the variables in sequence which means that one thread not only should increment the variable but also we want to print the number before the other threads can access it
    
Synchronized block
    //some code
    synchronized(someinstance) {
        //This code will be accessed by one and one 
        //only thread at given time
    }
    //More code

Synchronized block will have synchronized keyword and have an instance in the argument with start and end curly braces, any code that goes within these curly braces can be accessed by one and only one thread at any given time, the instance provided in parenthesis can be any object 
    Consider we have 2 threads thread1 and thread2, they both running code in parallel. Say thread1 reaches the synchronized block first, it uses that instance that we provided in the argument to acquire the lock. When thread1 has a lock and other thread reaches, then they have to wait to get the lock, thread1 will release the lock only when it reaches closing curly braces of synchrozied block, until that thread2 will keep on waiting for the lock.
   Thread2 will acquire the lock on the instance and then start executing that code within the block and once the thread2 reaches to the end of block then it release the lock for other threads to acquire it, so using this process we will ensure that code that is written within curly brace will always run by one thread at any given point of time and since the synchronzied block is run sequentially within the thread to improve the performance, this block should be as small as possible 

Example:
   Here we use synchronized block in place where we define the task, so here we use service as instance  that the threads will get locked on 
    
public class Main {
  private static Integer counter=0;
  PSVM() {
    ExecutorService service=Executors.newFixedThreadPool(10);
    try {
       for(int i=0;i<10;i++) {
          service.submit(() -> {
              synchronized(service) }
             System.out.println(++counter);
            }
          });
       }
    } finally {
        if(service != null) 
           service.shutdown();
      }
   }
}
We can see the output where all numbers will be printed in sequence because print statement is also synchronized so until one thread increments and prints the value, it dosent give access of counter to second thread 

Reentrant Lock 
    We have seen synchronized block as if one thread acquires the lock, the other threads cannot access the code written in synchronized block and keeps waiting until the first thread has finished 
    If we want the thread2 to first check if it can acquire a lock and if it cannot for now, we want to  do something else and then try again after sometime, that way thread2 dosent have to wait while thread1 is executing the synchronized block.
    In case if thread1 never releases the lock then thread2 will wait there forever, to address this problem concurrency API have lock framework where we can get more control on acquiring the lock and for that we use Lock interface 
    Its is similar to synchronization block, the only difference is instead of synchronizing on any object we can only lock on the object that implements the lock interface. We can get concrete implementation of lock interface using ReentrantLock class 
     
    Lock lock=new ReentrantLock();
    try  {
        lock.lock();
    }
    finally {
        lock.unlock();
    }

First we create an instance of ReentrantLock class and then use lock() to get the lock and then do the work that cannot be run in parallel and when we done with work we release the lock using unlock(), releasing the lock is important otherwise other thread will not get the lock forever and also we can only release the lock that we have acquired 

Example:

public class Main {
  private static Integer counter=0;
  PSVM() {
    ExecutorService service=Executors.newFixedThreadPool(10);
  Lock lock=new ReentrantLock();
    try {
       for(int i=0;i<10;i++) {
          service.submit(() -> {
              try { lock.lock();
             System.out.println(++counter);}
            finally { lock.unlock(); }
            }
          });
       }
    } finally {
        if(service != null) 
           service.shutdown();
      }
   }
}
We can see the output where all numbers will be printed in sequence

Example:
    We see what happens if we do not unlock 

public class Main {
  private static Integer counter=0;
  PSVM() {
    ExecutorService service=Executors.newFixedThreadPool(10);
  Lock lock=new ReentrantLock();
    try {
       for(int i=0;i<10;i++) {
          service.submit(() -> {
              try { lock.lock();
             System.out.println(++counter);}
            finally { //lock.unlock(); }
            }
          });
       }
    } finally {
        if(service != null) 
           service.shutdown();
      }
   }
}

The program hangs because thread comes in it get the lock, it prints the value but never releases it and the thread finishes and other threads are still waiting to get the lock, so always we need to unlock in case of Lock framework

Methods in Lock interface
1. void lock() - requests lock and blocks until uts acquired. It is blocking call which means whatever method is calling the lock method will actually block its execution until it acquires the lock 
2. void unlock() - Releases the lock
3. boolean tryLock() - Requests the lock and return immediately, the return value will tell if the lock  was acquired or not
4. boolean tryLock(long,TimeUnit) - Requests the lock and blocks for specified time. The return value will tell if the lock is acquired or not 

Example:
   We create acquireLock() which takes lock as argument and it will simply get the lock and release the lock 
   In main(), we create instance of Lock and we create a another new thread which run parallel to main thread and then task that new thread will do is simply get and release the lock. And we use tryLock() to get the lock and if we get and we print 

public class Main {
  PSVM() {
  Lock lock=new ReentrantLock();
  new Thread(()->acquireLock(lock)).start();
  if(lock.tryLock()){
     SOP("Lock acquired by main thread");
     lock.unlock();
  }
  else {
     SOP("Lock cannot acquired by main thread");
  }
 }
  public static void acquireLock(Lock lock){
    try {
        lock.lock();
    }
    finally {
        lock.unlock();
    }
  }
}

Output: Lock cannot acquired by main thread
   The reason is when main thread try to acquire the lock using tryLock(), at that time the other thread that we created has that lock, so main thread did not wait to get the lock 

Example:
public class Main {
  PSVM()throws InterruptedException {
  Lock lock=new ReentrantLock();
  new Thread(()->acquireLock(lock)).start();
  Thread.sleep(2000);
  if(lock.tryLock()){
     SOP("Lock acquired by main thread");
     lock.unlock();
  }
  else {
     SOP("Lock cannot acquired by main thread");
  }
 }
  public static void acquireLock(Lock lock){
    try {
        lock.lock();
    }
    finally {
        lock.unlock();
    }
  }
}

Output: Lock acquired by main thread
   The reason is by 2 sec the additional thread that we created it already acquire the lock and release it, so now main thread able to acquire the lock 

1. Without locking the thread, if we unlock then the program throws IllegalMonitorStateException
public class Main {
  PSVM() {
  Lock lock=new ReentrantLock();
        lock.unlock();
  }
}

2. Lock framework will keep the count of how many times have we locked 
public class Main {
  PSVM() {
  Lock lock=new ReentrantLock();
        lock.lock();
        lock.lock();
        lock.unlock();
        lock.unlock();

     new Thread(()->System.out.println(lock.tryLock())).start();
  }
}
Output: True
   The reason is new thread we create is able to get the lock because main thread already released the lock


Cyclic Barrier
    Consider we have cage which has some lions in it  and the task that we want to achieve is to clean the cage. At high level this is how the sequence would be so we will remove all lions from cage, we will clean the cage and once its clean we will put back all the lions.
    Conside zoo has only 1 employee, the employee will remove all the lions in the cage one after the other, once all the lions are removed that employee goes into the cage and cleans, comes back out and put back all lions in cage. If we have one employee  then we do not have any problem, we do not need any orchestration the employee is doing what he suppose to do.
   Now say we have 4 employees and we want to use all 4 employees to do as much work as possible in parallel, so that the work as whole is done in a greater speed, given that they all 4 different human beings all of them will have a different caliber and hence they might work in a different speed, so there is possibility that employee1 removes the lion and goes into cage to clean it even before the other 3 lions are removed (ie) employee1 is much faster than other 3. But we have problem that employee1 is in cage with 3 lions in it which might not end well.
   What we want is eventhough employee1 is fast we need to ask him to wait until all other 3 lions are  removed from the cage, and once they are then all 4 employees will go in cage, they all will clean the cage and all of them do their part of the job and all 4 employees are back out of cage, then we will bring all 4 lions into cage 
   So in multithreading, think 4 employees as 4 different threads, we need some kind of orchestration which would communicate between the threads, so eventhough 1 thread is faster than other we want it to wait until other 3 threads done that unit of task and only after all 4 threads have done the task they will move on to the next unit. This orchestration of task can be done using cyclic barrier 

Example:
   We create ZooManager class with removeLion() which just print some statement along with id of thread. We create another method cleanCage() which just print some statement along with id of thread. We create another method addLion() which just print some statement along with id of thread. Next we create performTasks() which call all previous that we created      
   Next we create main class inside we create ExecutorService with 4 different threads, next we create instance of ZooManager class, next we submit the task and task will be doing all three different  task we defined 

public class ZooManager {
  public void removeLion() {
      SOP(Thread.currentThread().getId()+"Removing lion");
  }
  public void cleanCage() {
      SOP(Thread.currentThread().getId()+"Cleaning cage");
  }
  public void addLion() {
      SOP(Thread.currentThread().getId()+"Adding lion");
  }
  public void performTasks(CyclicBarrier c1, CyclicBarrier c2) {
     try { removeLion();
      c1.await();
      cleanCage();
      c2.await();
      addLion();
     }
     catch(InterruptedException | BrokenBarrierException e) {
        System.out.println(e);
     }
  }
}

public class Main { PSVM  {
   ExecutorService service=Executors.newFixedThreadPool(4);
   ZooManager manager=new ZooManager();
   CyclicBarrier c1=new CyclicBarrier(4);
   CyclicBarrier c2=new CyclicBarrier(4,()->System.out.println("Cage cleaned"));
   try {
       for(int i=0;i<4;i++) {
          service.submit(()->manager.performTasks(c1,c2));
    }
   finally {
      if(service != null){
          service.shutdown();
      }
   }
}

await() is going to stop the execution of threads until a counter has been reached and that counter is the number that we gave in the constructor when we created Cyclic Barrier 

JDBC -  https://github.com/mhussainshah1/JDBC11

Bind Variables
   The placeholder that lets u specify  the actual values at runtime

Can:
  - set parameters out of order
  - set the different parameter and skip similar in updating multi times

public class UpdateMultiples {
    public static void main(String[] args) throws SQLException {
        var sql = "INSERT INTO names VALUES (?, ?, ?)";
        try(Connection conn = DriverManager.getConnection("jdbc:derby:zoo");
            var ps = conn.prepareStatement(sql)){

            ps.setInt(1, 20);
            ps.setInt(2, 1);
            ps.setString(3, "Ester");
            ps.executeUpdate();

            ps.setInt(1,21);
            ps.setString(3, "Elias");
            ps.executeUpdate();
        }
    }
}

Java is smart enough, it will take 2nd bind variable from the previous one so output to be 20,1,Ester and 21,1,Elias

Cant:
   - set more or less values than u have as bind variable

//error
public static void registerMore(Connection conn, int key, int type, String name) throws SQLException {
        var sql = "INSERT INTO names VALUES (?, ?)";
        try (var ps = conn.prepareStatement(sql)) {
            ps.setInt(1,key);
            ps.setInt(2,type);
            ps.setString(3,name);

            int result = ps.executeUpdate();
            System.out.println(result);
        }
    }

//error
    public static void registerLess(Connection conn, int key, int type, String name) throws SQLException {
        var sql = "INSERT INTO names VALUES (?, ?, ?)";
        try (var ps = conn.prepareStatement(sql)) {
            ps.setInt(1,key);
            ps.setInt(2,type);

            int result = ps.executeUpdate();
            System.out.println(result);
        }
    }
   - cant Work if u dont set them in between PreparedStatement and ResultSet

public class BindVariables {
    public static void main(String[] args) throws SQLException {
        Connection conn = DriverManager.getConnection("jdbc:derby:zoo");
        var sql = "SELECT id FROM exhibits where name = ?";

        try(var ps = conn.prepareStatement(sql)){

            ps.setString(1, "Zebra");//set in between ps and rs

            try(var rs = ps.executeQuery()){
                while (rs.next()){
                    int id = rs.getInt("id");
                    System.out.println(id);
                }
            }
        }

    }
}



public class BadCode {
    public static void main(String[] args) throws SQLException {
        Connection conn = DriverManager.getConnection("jdbc:derby:zoo");
        var sql = "SELECT COUNT(*) AS count FROM EXHIBITS";
        /*try (var ps = conn.prepareStatement(sql);
             var rs = ps.executeQuery()) {
            if (rs.next()) {
                var count = rs.getInt("total");//SQLException: Column 'total' not found.
                System.out.println(count);
            }
        }*/

        /*sql = "SELECT * FROM EXHIBITS WHERE name = 'Not in table'";
        try (var ps = conn.prepareStatement(sql);
             var rs = ps.executeQuery()) {
            rs.next();
            rs.getInt(1);//SQLException: Invalid cursor state - no current row.
        }*/

        /*sql = "SELECT COUNT(*) FROM EXHIBITS";
        try (var ps = conn.prepareStatement(sql);
             var rs = ps.executeQuery()) {
            if (rs.next()) {
                var count = rs.getInt(0);//SQLException:  Column '0' not found.
                System.out.println(count);
            }
        }*/

        sql = "SELECT name FROM EXHIBITS";
        try (var ps = conn.prepareStatement(sql);
             var rs = ps.executeQuery()) {
            if (rs.next()) {
                rs.getInt("badColumn");//SQLException:  Column 'badColumn' not found.
            }
        }

    }
}

Closing Database Resources
   - Closing a Connection also closes PreparedStatement or CallableStatement and ResultSet
   - Closing a PreparedStatement or CallableStatement and ResultSet
   - JDBC automatically close a ResultSet when u run another SQL statement from same statement

public class TryCatchResources {
    public static void main(String[] args) throws SQLException {

        var url = "jdbc:derby:zoo";
        var sql = "SELECT COUNT(*) FROM names WHERE id = ?";
        try (var conn = DriverManager.getConnection(url);    //1 - open conn
             var ps = conn.prepareStatement(sql)) {     //2 - open ps
            ps.setInt(1, 1);

            var rs1 = ps.executeQuery();
            while (rs1.next()) {                                        //3 - open rs1
                System.out.println("Count: " + rs1.getInt(1));
            }

            ps.setInt(1, 2);
            var rs2 = ps.executeQuery();
            while (rs2.next()) {                                        //4 - close rs1  , 5 - open rs2
                System.out.println("Count: " + rs2.getInt(1));
            }
            rs2.close();                                                //6 - close rs2
        }                                                               //7 - close ps
                                                                        //8 - close conn
    }
}


Localization

https://github.com/mhussainshah1/Localization

Date Formatting

public class FormatDateTime {
    public static void main(String[] args) {
        LocalDate date = LocalDate.of(2020, Month.NOVEMBER, 10);
        LocalTime time = LocalTime.of(19, 23);
        LocalDateTime dt = LocalDateTime.of(date, time);

        //format
        //buit-in formatter
        System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE));
        System.out.println(time.format(DateTimeFormatter.ISO_LOCAL_TIME));
        System.out.println(dt.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));

//        System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_TIME));
//        System.out.println(time.format(DateTimeFormatter.ISO_LOCAL_DATE));

        //custom formatter
        var formatter1 = DateTimeFormatter.ofPattern("MM/dd/yyyy hh:mm:ss");
        System.out.println(dt.format(formatter1));

        var formatter2 = DateTimeFormatter.ofPattern("MM_yyyy_-_dd");
        System.out.println(dt.format(formatter2));

        var formatter3 = DateTimeFormatter.ofPattern("h:mm z");
//        System.out.println(dt.format(formatter3));

        System.out.println(formatter1.format(dt));

        //Add custom text
        var f = DateTimeFormatter.ofPattern("MMMM dd, yyyy 'at' hh:mm");
        System.out.println(dt.format(f));

        var f1 = DateTimeFormatter.ofPattern("MMMM dd, yyyy");
        var f2 = DateTimeFormatter.ofPattern("hh:mm");
        System.out.println(dt.format(f1) + " at " + dt.format(f2));

        var g1 = DateTimeFormatter.ofPattern("MMMM dd, yyyy 'Party''s at' hh:mm");
        System.out.println(dt.format(g1));

        var g2 = DateTimeFormatter.ofPattern("'System format, hh:mm' hh:mm");
        System.out.println(dt.format(g2));

        var g3 = DateTimeFormatter.ofPattern("'New!' yyyy ',yay!!'");
        System.out.println(dt.format(g3));

//        DateTimeFormatter.ofPattern("Time is: hh:mm:ss");
//        DateTimeFormatter.ofPattern("'Time is: hh:mm:ss");

        //In java 7
        DateFormat s = new SimpleDateFormat("MMMM dd, yyyy 'at' hh:mm");
        System.out.println(s.format(new Date()));
    }
}

Internationalization
   Designing ur program so it can ve adapted. This involves placing strings in a properties file and ensuring the proper data formatters are used

Locale: specific geographical, political or cultural region

Localization - supporting multiple locales or geographic regios. It includes translating strings to different languages. Output the dates and numbers in the correct format for that locale

Locale class - java.util.* package
  Locale language - fr
  Locale language,country - en_US

Select Built-in Locale
1. constants - Locale.GERMAN

2. Constructor
       new Locale("fr");
       new Locale("en","US");

Invalid identifier
   EN - langugae must be lowercase
   US - cannot have country without language
   enUS - Missing Underscore
   US_en - The country and language are reversed

3. Builder design pattern
     Locale l1=new Locale.Builder()
        .setLanguage("en").setRegio("US").build();

Methods:
   1. public static Locale getDefault()
   2. public static void setDefault(Locale newLocale)
   3. public static void setLocale(Locale.Category l,Locale newLocale)

public class MyLocale {
    public static void main(String[] args) {
        Locale locale = Locale.getDefault();
        System.out.println(locale);//en_US

        //Select Locale
        System.out.println(Locale.GERMAN);//de
        System.out.println(Locale.GERMANY);//de_DE

        //2
        System.out.println(new Locale("fr"));//fr
        System.out.println(new Locale("ur","PK"));//ur_PK
        System.out.println(new Locale("xx","XX")); //prints but dosent behave as Locale

        //3
        Locale l1 = new Locale.Builder()
                .setLanguage("hi")
                .setRegion("IN")
                .build(); //hi_IN

        Locale l2 = new Locale.Builder()
                .setRegion("IN")
                .setLanguage("hi")
                .build(); //hi_IN

        //set local
        locale = new Locale("fr");
        Locale.setDefault(locale);
        System.out.println(Locale.getDefault());
    }
}

Localizing Dates - package java.time.format

1. For formatting dates - DateTimeFormatter.ofLocalizedDate(dateStyle)

2. For formatting times - DateTimeFormatter.ofLocalizedTime(timeStyle)

3. For formatting dates and times - DateTimeFormatter.ofLocalizedDateTime(dateStyle,timeStyle)
DateTimeFormatter.ofLocalizedDateTime(datetimeStyle)

public class LocalizingDates {

    public static void print(DateTimeFormatter dtf, LocalDateTime dateTime, Locale locale){
        System.out.println(dtf.format(dateTime) + ", " + dtf.withLocale(locale).format(dateTime));
    }
    public static void main(String[] args) {
        Locale.setDefault(new Locale("en","US"));
        var italy = new Locale("it","IT");
        var dt = LocalDateTime.of(2020, Month.NOVEMBER,12,19,23,55);

        print(DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT),dt,italy);
        print(DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT),dt,italy);
        print(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT,FormatStyle.SHORT),dt,italy);
    }
}

Localizing Number - package java.text

1. General purpose formatter 
     - NumberFormat.getInstance()
     - NumberFormat.getInstance(locale)

2. Same as getInstance
     - NumberFormat.getNumberInstance()
     - NumberFormat.getNumberInstance(locale)

3. For formatting monetary amounts
     - NumberFormat.getCurrencyInstance()
     - NumberFormat.getCurrencyInstance(locale)

4. For formatting percentages
     - NumberFormat.getPercentInstance()
     - NumberFormat.getPercentInstance(locale)

5. Rounds decimal values before displaying
     - NumberFormat.getIntegerInstance()
     - NumberFormat.getIntegerInstance(locale)

public final String format(double num) - change number to string

public Number parse(String source) throws ParseException - change String into Number


public class LocalizingNumbers {
    public static void main(String[] args) throws ParseException {
        //formatting
        //numbers
        int attendeesPerYear = 3_200_000;
        int attendeesPerMonth = attendeesPerYear / 12;

        var us = NumberFormat.getInstance(Locale.US);
        System.out.println(us.format(attendeesPerMonth));//266,666

        var gr = NumberFormat.getInstance(Locale.GERMANY);
        System.out.println(gr.format(attendeesPerMonth));//266.666

        var ca = NumberFormat.getInstance(Locale.CANADA_FRENCH);
        System.out.println(ca.format(attendeesPerMonth));//266 666

        //currency
        Locale.setDefault(new Locale("en","GB"));
        double price =40;
        var myLocale = NumberFormat.getCurrencyInstance();
        System.out.println(myLocale.format(price));//£40.00

        //parsing
        //number
        Locale.setDefault(new Locale("en","US"));
        String s ="40.45";
        var en =NumberFormat.getInstance();
        System.out.println(en.parse(s));
        var fr =NumberFormat.getInstance(Locale.FRANCE);
        System.out.println(fr.parse(s));

        //currency
        String income = "$92,807.99";
        var cf = NumberFormat.getCurrencyInstance();
        double value = (Double)cf.parse(income);
        System.out.println(value);

        //Custom Formatting
        //number
        double d = 1234567.467;
        NumberFormat f1 = new DecimalFormat("###,###,###.0");
        System.out.println(f1.format(d));//1,234,567.5

        NumberFormat f2 = new DecimalFormat("000,000,000.00000");
        System.out.println(f2.format(d));//001,234,567.46700

        //currency
        NumberFormat f3 = new DecimalFormat("$#,###,###.##");
        System.out.println(f3.format(d));//$1,234,567.47

    }
}

Custom Number formatter
    public DecimalFormat(String pattern)

# - Omit the position if no digit exist for it
0 - Put O in the position if no digit exists for it

Specifying Locale Category
   Locale.Category enum is a nested element, support distinct locales for displaying and formatting data
1. DISPLAY - Category used for displaying data about the locale
2. FORMAT - Category used for formatting dates,numbers or currencies

public class LocaleCategory {
    public static void print(Locale locale, double money){
        System.out.println(locale.getDisplayLanguage() + ", " + NumberFormat.getCurrencyInstance().format(money));
    }

    public static void main(String[] args) {
        var spain = new Locale("es" , "ES");
        var money = 1.23;

        Locale.setDefault(Locale.US);
        print(spain, money);

        Locale.setDefault(Locale.Category.DISPLAY, spain);
        print(spain, money);

        Locale.setDefault(Locale.Category.FORMAT, spain);
        print(spain, money);

    }
}

Loading properties with ResourceBundle
    ResourceBundle contains locale-specific objects to be used by a program. It is like a map with keys and values. The resource bundle is commonly stored in a properties file
   Properties file is a text file in a specific format with key/value pairs

public class MyResourceBundle {
    public static void main(String[] args) {
        var us = new Locale("en","US");
        var fr = new Locale("fr", "FR");
        print(us);
        print(fr);

        var rb1 = ResourceBundle.getBundle("Zoo" , us);
        rb1.keySet().stream()
                .map(k -> k +": " + rb1.getString(k))
                .forEach(System.out::println);
    }

    private static void print(Locale locale) {
        var rb = ResourceBundle.getBundle("Zoo" , locale);
        System.out.println(rb.getString("hello") + ", " + rb.getString("open"));
    }
}

Zoo_en.properties
hello=Hello
open=The zoo is open
name=en

Zoo_fr.properties
hello=Bonjour
open=Le zoo est ouvert
name=fr   


Without Requested Locale, by default is en_US

Zoo_en_US.properties
name=en_US
text=The Zoo
helloByName=Hello, {0} and {1}

With Requested Locale

Zoo_fr_FR.properties
name=fr_FR
visitors = French Visitors

public class PickingResourceBundle {
    public static void main(String[] args) {
        Locale.setDefault(new Locale("en","US"));//default locale
        Locale locale = new Locale("fr","FR"); //requested locale

        var rb = ResourceBundle.getBundle("Zoo");
        System.out.println(rb.getString("name"));
        /**
         * Zoo_en_US
         * Zoo_en
         * Zoo
         */

        rb = ResourceBundle.getBundle("Zoo" ,locale);
        System.out.println(rb.getString("name"));
        /**
         * Zoo_fr_FR
         * Zoo_fr
         * Zoo
         *
         * if requested locale(language,country) not present
         * ------------------------------------------------
         * Zoo_en_US
         * Zoo_en
         * Zoo
         */

        rb = ResourceBundle.getBundle("Zoo" ,locale);
        System.out.print(rb.getString("hello"));
        System.out.print(".");
        System.out.print(rb.getString("text"));
        System.out.print(" ");
        System.out.print(rb.getString("open"));
        System.out.print(" ");
        System.out.print(rb.getString("visitors"));


    }
}

Zoo.properties - No locale at all - default bundle
name=no locale
text=France Zoo


Formatting Message
MessageFormat - package java.text
  - Support parametrized String values that take input values
  - public static String format(String pattern,Object...arg)

public class FormattingMessages {
    public static void main(String[] args) {
        var us = new Locale("en" , "US");
        var rb = ResourceBundle.getBundle("Zoo",us);
        String format = rb.getString("helloByName");
        System.out.println(MessageFormat.format(format,"Muhammad","Shah"));
    }
}

If still not found throws MissingResourceException



Java 9
   Java8 introduced in Mar 18th 2014, so almost after 3yrs, Java 9 introduced in Sep 21st 2017.
   Until Java7, java is considered very powerful but after jav7 other languages are dominating Java like Python, Scala, Ruby, then only Java 8 came with so many new features

Features:
1. JShell 
   - To learn java in the beginning stage without difficult some tool is required called JShell

>jshell PRINTING
Jshell> print("Hello world");
jshell> 10+20
jshell> 10<20

2. JPMS(Java Platform Module System)
       Java8 introduced in 2014 and Java9 in 2017, but JPMS concept development was started from 2005      
      JPMS (ie) from Java9 everything is modularized. In Java9, this JPMS concept came as part of project Jigsaw. 

    Until Java1.8, we have to develop multiple classes, interfaces, enums and convert these things inside packages and all these packages will be convert into jar files, by placing jar files in classpath we can run our application. So until Java8 our appl development is jar file based, by keeping all jar files in classpath we can execute our appl. From Java9 onwards instead of jar, a new construct is used called module. Modules also group of packages but it contains configuration information inside a file called module-info.java. So modules will contains group of package and module-info.java, by mistake if we not write module-info.java, then JVM will never consider as module 
    From Java9, JDK itself is modularized. In Java8 we have rt.jar,tools.jar etc all this are applicable only from Java8, from Java9 onwards no more rt.jar,tools.jar everything is remembered. So total JDK itself is divided into several modules, all predefined Java classes from rt.jar in Java8 are divided into several modules in Java9 something like 98 modules like java.base, java.rmi, java.logging, java.desktop, java.sql modules. Inside JDK9 folder we cant see jre, instead we have jmods folder where we can see all modules

java.base module - contains commonly used package like java.lang,java.util and its subpackage,java.io etc
java.sql module - contains java.sql, javax.sql packages
java.rmi module - contains java.rmi package
java.desktop module - contains awt, swing packages

To return which class in which module, we use
class Test { PSVM {
     System.out.println(String.class.getModule()); //java.base
     System.out.println(Connection.class.getModule()); //java.sql
     System.out.println(ArrayList.class.getModule()); //java.base
}}

    Until java8 everything is jar file based in Java, the problem with jar file approach is
    1. If JVM unable to identify required .class file then we get NoClassDefFoundError  in middle of program
    2. Version conflict, if two jar files contains class with same name, maybe at runtime JVM may pick wrong version
    3. security problem, since anyone can access from jar file
    4. To execute simple hello world program we required to maintain almost 400mb jre in client machine. So JDK and JRE have monolithic structure and bigger size 

All these problem related to jar file is called Jar Hell or classpath hell. To overcome these problems, Java9 comes with JPMS concept. 
    - So in modular programming JVM will check in the beginning only that all dependent modules are available or not, if anything is missing immediately JVM says so and so module is missing, so NoClassDefFoundError in modular programming
    -  In modular programming contains modules which has collection of packages,and contain a configuration file called module-info.java, where we specify which class is required in which module, so choosing wrong file by JVM wont occur 
    - Which u want to export only that package will available to outside world, so security problem so wont be there
    - In JRE, rt.jar is divided into several modules, which module is required only that module my JRE is going to use, so size of JRE by default is small   

Difference between jar file and modules

Jar file								Modules
1. Jar is a group of packages                1. Module is also group of packages
and each package contains several classes     and each package contain several                                               classes.Module can also contain                                                module-info.java to hold module specific                                             dependencies and configuration info

2. In jar file, there is no way to specify  2. For every module we have to maintain dependent jar files information	               module-info.java to
				               specify module dependencies

3. There is no way to check all jar file    3. JVM will check all module dependencies at the beginning only. So in      dependencies at the beginning only                                                  with the help of module-                                                           info.java. If any dependent
the middle of program execution there may     module is missing then JVM wont start                                               its execution, so no
be a chance of NoClassDefFoundError           chance of NoClassDefFoundError

4. In the classpath the order of jar files    4. In the module-path order is not                                                important. JVM will 
important and JVM will always considers from   always check from the dependent                                                 module only for the 
left to right for the required class files.    required class files. Hence there is                                                no chance of version
If multiple jars contains same .class file    conflicts and abnormal behaviour of                                               the application
then there may be a chance of version 
conflicts and result to abnormal behaviour
of our application

5. In jar file there is no mechanism to	     5. In module there is a mechanism to                                                 control access to the 
control access to packages. Everything present  packages. Only exported packages                                                 are visible to other
in jar file is public to everyone, any person   modules, hence there is no chance                                                 of security problem
is allowed to access any component from the jar
file. Hence there may be a chance of security
problems

6. Jars follows monolithic structure and appl  6. Modules follow distributed                                                 structure and appl will become 
will become heavy weight and not suitable      light weight and suitable for small                                                devices
for small devices

7. Jar files approach cannot be used for IOT  7. Used for IOT device and                                                  microservice 
devices and microservices

     
What is module?
    - Module is group of package, each package will contain group of class file, every module should complusorly contain module-info.java which hold dependency, security related information

How to write module-info.java?
   - We have to use keyword "module" followed by modulename(any name)
    module modulename {
      //module specific dependency like which represents
      //1. what other modules requried by this module
         requires moduleA;
         requires moduleB;
      //2. What packages exported by this module
         exports pack2; //so this package is available for other modules
         exports pack3;
}
 
Steps to create module:
1. create moduleA folder
2. Inside moduleA,create module-info.java
     module moduleA {
  
     }
3. Create pack1 folder inside moduleA folder
4. Inside pack1 folder, create Test.java

package pack1;
public class Test {
   public static void main(String args[]){
      System.out.println("Hello world");
   }
}

5. Copy moduleA folder inside src folder
6. compile module
   c:>javac --module-source-path src -d out -m  moduleA
-Complier will compile moduleA and find moduleA inside src folder, after compilation generate .class file inside out folder 
  - Creates out folder with .class file
7. Run the program using
  >java --module-path out -m moduleA/pack1.Test
  
Case 1:
   If module-info.java is not available then the code wont compile and we will get error. Hence module-info.java is mandatory for every module

Case 2:
   Every class inside module should be part of some package, otherwise we will get compile time error saying "unnamed package is not allowed in named modules"

Case 3:
    The module name should not end with digits(like module1, module2 etc), then we will get warning message at compile time 

Various ways to compile module
1. javac --module-source-path src -d out -m moduleA

2. javac --module-source-path src -d out --module moduleA

3. javac --module-source-path src -d out src/moduleA/module-info.java src/moduleA/pack1/Test.java

4. javac --module-source-path src -d out c:/training/src/moduleA/module-info.java c:/training/src/moduleA/pack1/Test.java
 
Various ways to run a module
1. java --module-path out -m moduleA/pack1.Test

2. java --module-path out --module moduleA/pack1.Test

3. java --module-path out --add-modules moduleA pack1.Test
      - used in multiple modules from different location


Optional dependencies
     - If dependent module should be available at compile time and optional at runtime, then such type of dependency is called optional dependency. We can specify optional dependency using static keyword

Syntax: requires static 'modulename'

module moduleA {

}

module moduleB {
   requires moduleA;   //mandatory
   requires static moduleC;   //optional
}

module moduleC {

}

At compile time moduleB and moduleC is compulsorly available but at runtime moduleC is optional 

Cyclic dependencies
    If moduleA depends on moduleB and moduleB depends on moduleA, such type of dependency is called cyclic dependency
    Cyclic dependencies between the modules are not allowed in Java9.

module moduleA{
   requires moduleB;
}

module moduleB{
   requires moduleA;
}

>javac --module-source-path src -d out -m moduleA,moduleB
   - compilation error

In all predefined modules there is no chance of cyclic dependency.

Qualified exports
     Sometimes a module can export its package to specific module instead of every module. Then the specified module only can access. Such type of exports are called Qualified Exports

Syntax: export pack1 to module1, module2....

module exporterModule {
   exports pack1; //export pack1 to all modules
   exports pack1 to moduleA; //export pack1 to only moduleA
   exports pack1 to moduleA, moduleB; //export pack1 to both moduleA, moduleB
}

exportermodule:

module-info.java
module exportermodule {
    exports pack1;
    exports pack2 to moduleA;
    exports pack3 to moduleA, moduleB;
}


A.java
package pack1;
public class A  {  }

B.java
package pack2;
public class B  {  }

C.java
package pack3;
public class C  {  }

moduleA:

Test.java
package packA;
import pack1.A;
import pack2.B;
import pack3.C;
public class Test {
  public static void main(String args[]) {
     System.out.println("Qualified export");
  }
}

module-info.java
module moduleA {
   requires exportermodule;
}

For moduleA, all 3 packages are available. Hence we can compile and run moduleA successfully.
  >javac --module-soure-path src -d out -m exportermodule,moduleA
  >java  --module-path out -m moduleA/packA.Test

moduleB:
module-info.java
module moduleB {
   requires exportermodule;
}

Test.java
package packB;
import pack1.A;
import pack2.B;  //compiler error 
import pack3.C;
public class Test {
  public static void main(String args[]) {
     System.out.println("Qualified export");
  }
}

>javac --module-soure-path src -d out -m exportermodule,moduleB
   - Compiler error 

Note:
- requires used only for modules, exports used only for packages
- requries and exports can be used only for one modules and packages respectively, if we want to use for multiple then we create separete requires and exports 

Which of the following directives are valid inside module-info.java?
requires moduleA;  --correct
requires moduleA,moduleB; --error
requires moduleA.pack1; --error
requires moduleA.pack1.A; --Error
requires static moduleA; --correct
requires transitive moduleA; --Correct
exports pack1; --Correct
exports pack1,pack2; --error
exports moduleA; --error
exports moduleA.pack1.A; --error
exports pack1 to moduleA; --Correct
exports pack1 to moduleA,moduleB; --Correct

Module Graph
   - The dependencies between the modules can be represented by using special graph called Module Graph
   - All predefined modules requires java.base module either directly or indirectly, hence this module acts as BASE module for all java modules

Rules for Module Graph
   - Two modules with the same name is not allowed
   - Cyclic dependency is not allowed between the modules and hence Module Graph should not contain cycles

Observable modules
   - The modules which are observed by JVM at runtime are called Obervable modules
   The modules we are specifying with --module-path option with java command are observed by JVM and hence these are observable modules.
   >java --module-path out -m moduleA/pack1.Test

Aggregator module
    Sometimes a group of modules can be reused by multiple other modules. Then it is not recommended to read each module individually. We can group those common modules into a single module, and we can read that modules directly. This module which aggregates functionality of several modules into a single module is called Aggregator module. If any module reads aggregator module then automatically all its modules are by default available to that module.

module aggregatorModule {
   requires transitive moduleA;
   requires transitive moduleB;
   requires transitive moduleC;
}

Aggregator module not required to contain single class file, just it "requires transitive" of all common modules
   If any module reads aggregatorModule automatically all 3 modules are by default available to that module also

module useModule {
   requires aggregatorModule;
}

Now useModule can use functionality of all 3 modules moduleA, moduleB, moduleC

1. moduleA:

module-info.java:
  module moduleA {
     exports pack1;
  }

A.java
package pack1;
public class A {
   public void m1() {
     System.out.println("moduleA method");
   }
}

2. moduleB:

module-info.java:
  module moduleA {
     exports pack2;
  }

B.java
package pack2;
public class B {
   public void m2() {
     System.out.println("moduleB method");
   }
}
 
3. moduleC

module-info.java:
  module moduleC {
     exports pack3;
  }

C.java
package pack3;
public class C {
   public void m3() {
     System.out.println("moduleC method");
   }
}

4. aggregatorModule

module-info.java:
  module aggregatorModule {
     requires transitive moduleA;
     requires transitive moduleB;
     requires transitive moduleC;
  }

4. useModule:

module-info.java:
  module useModule {
     requires aggregatorModule;
  }

Test.java
package packA;
import pack1.A;
import pack2.B;
import pack3.C;
public class Test{
   public static void main(String args[]) {
     System.out.println("Aggregator module demo");
     A a=new A();
     a.m1();
     B b=new B();
     b.m2();
     C c=new C();
     c.m3();
   }
}

>javac --module-source-path src -d out -m moduleA,moduleB,moduleC,aggregatormodule,useModule

>java --module-path out -m useModule/packA.Test

Packaging naming Conflicts
   Two jar files can contain a package with same name, which may creates version conflicts and abnormal behavior of the program at runtime
   But in Java9 module system, two modules cannot contain a package with same name, otherwise we will get compile time error. Hence in module system, there is no chance of version conflicts and abnormal behavior of the program

1. moduleA

module-info.java:
  module moduleA {
     exports pack1;
  }

A.java
package pack1;
public class A {
   public void m1() {
     System.out.println("moduleA method");
   }
}


2. moduleB

module-info.java:
  module moduleB {
     exports pack1;
  }

B.java
package pack1;
public class B {
   public void m1() {
     System.out.println("moduleB method");
   }
}

3. useModule

Test.java
package packA;
public class Test { PSVM {
    System.out.println("Packaging name conflicts");
}}

module-info.java
  module useModule {
     requires moduleA;
     requires moduleB;
  }

>javac --module-source-path src -d out -m moduleA,moduleB,useModule
   - compiler error 

Module Resolution Process
    In the case of traditional classpath, JVM wont check the required .class files at the beginning. While executing program if JVM required any .class file, then only JVM will search in the classpath for the required .class file. If it is available then it will be loaded and used and if ir is not avialable then at runtime we will get NoClassDefFoundError which is not at all recommended.
   But in  modular programming, JVM will search for the required modules in the module-path before it starts execution. If any module is missing at the beginning only JVM will identify and wont start its execution. Hence in modular programming there is no chance of getting NoClassDefFoundError in the middle of program execution.

>java --module-path -d out --show-module-resolution -m useModule/packA.Test


Transitive dependency
   - Consider myModuleA requires myModuleB and myModuleB requires myModuleC. M2 class of myModuleB contains a method and that method returns reference of type M3 class of myModuleC. The method is M2 class which return reference of type M3 is called by main() of M1 class

1. myModuleC

module-info.java:
   module myModuleC {
      exports myPack3;
   }

M3.java:
package myPack3;
public class M3 {
   public void methodM3(){
       System.out.println("methodM3");
   }
}

2. myModuleB

module-info.java:
  module myModuleB {
      requires myModuleC;
      exports myPack2;
  }

M2.java:
package myPack2;
import myPack3.M3;
public class M2 {
    public M3 methodM2() {
      System.out.println("methodM2");
      M3 m=new M3();
      return m;
    }
}

3. myModuleA

module-info.java:
   module myModuleA {
      requires myModuleB;
   }

M1.java:
package myPack1;
import myPack2.M2;
import myPack3.M3;
class M1 { PSVM {
     M2 m=new M2();
     M3 c=m.methodM2();
     c.methodM3();
   }
}

>javac --module-source-path src -d out -m myModuleA,myModuleB,myModuleC
   - compilation error 

Dependency on myModuleA on myModuleC is called transitive dependency. To use myModuleB then myModuleA also need to require myModuleC. Even if myModuleA is intended to use only myModuleB, but for using myModuleB, myModuleA need to require to use myModuleC, this is called transitive dependency 

In module-info.java of myModuleB, we use

module myModuleB {
      requires transitive myModuleC;
      exports myPack2;
  }
  



3. JLINK(Java Linker) - to create our own customize jre, so Java is suitable for portable devices, microservices, iot devices. The size of Java env is reduced using JLink
       We develop helloworld program and in order to run we need JRE in client machine which contain rt.jar which is around 60mb size which contain 4300+ classes. So huge memory is needed to run java appl with JRE. 
      But from JDK1.9 we can create our own JRE only with required things, so we can use Java for portable devices, IOT devices 

4. Previously we send http request through browsers but from Java appl if we want to send http request to web server then we use HTTP/2 client 
     Until Java8 if we want to send http request, we use HttpUrlConnection which introduced in 1997. It is difficult to use and per TCP/IP connection we can send only one request so performance is down, it provide support only for text, it works only in synchronous mode. Later developers use 3rd party like Apache HttpClient and Google HttpClient to communicate 
    Finally Http/2 client is used from JDK9, it is easy to use and we can send multiple request, it supports both text and binary based, can work in sync and async mode 

5. Process API updates, where we can communicate to processor from Java9 
    Until Java8, it is very difficult to communicate from Java appl to processor, we required to write lengthy code and 3rd party library 
    If we run java program, JVM is going to run, JVM itself is one process, so how to get a process ID of the current running process, create my own process from Java program, we want to destroy already existing process, we want to list out complete information of ur process (ie) who is owner, by which command these process got started, which is parent process, child process etc.
   If we want to print current process id, then we use 
     long pid=ProcessHandle.current().pid();

6. Private methods inside interface for code reusability

Need for private methods
     If several default methods having same common functionality, then there may be a chance of duplicate code, so we can define that common code in private method and call that in default method which required that functionality 

Advantage:
       So without affecting implementation class, if we want to  get code reusability we can use private methods 
       We can expose only intended methods to implementation class, because interface private methods are not visible to implementation class 

interface A {
   public abstract method;       - until JDK1.7
   public static final variable;  - until JDK1.7
           +
   default methods                - until JDK1.8
   static methods                 - until JDK1.8
           +
   private methods                 - until JDK1.9
}

Why default methods in JDK8?
     Whenever we implement an interface, that class should override the methods declared in interface. But for single interface we can have multiple implementation of classes available
     Now we want to add new method to an interface, then all implementation classes would be affected, so we introduced default methods (ie) without affecting implementation classes we can add new methods to an interface 

static method - If my functionality is no way related to object (ie) static method, instead of defining in class we can define in interface 



7. try with resources enhancement
       In jdk1.7, resources will be closed automatically once control reaches the end of try block, no need to use finally block so readability is also improved
       Until JDK1.8, whatever resources u r using it should be part of try block, we cant declare outside try block (ie) or we have to create new reference variable

try(FW fw=new FW("a.txt");FR fr=new FR("b.txt");){
---
}
try(FW fw1=fw;FR fr1=fr;){
---
}
    But in JDK1.9, we can use the resources which is already created 
FW fw=new FW("a.txt");
FR fr=new FR("b.txt");
try(fw;fr){
---
}

Example:

class MyResource implements AutoCloseable {
    MyResource() { SOP("Resource creation"); }
    public void doProcess() { SOP("Resource opening"); }
    public void close(){ SOP("Resource closing"); }
}

Java6:
public class Test {
 public static void java6(){
     MyResource r=null;
   try {
       r=new MyResource();
       r.doProcess();
   }
   catch(Exception e){
       SOP("Exception caught");
   }
   finally {
       if(r!=null){
           r.close();
       }
   }
}

public static void java7(){
   try(MyResource r=new MyResource();)
   {
         r.doProcess();
   }
   catch(Exception e){
       SOP("Exception "+e);
   }
}

public static void java9(){
   MyResource r=new MyResource();
   try(r)
   {
         r.doProcess();
   }
   catch(Exception e){
       SOP("Exception "+e);
   }
}

//We can define multiple resources in Java9 also :
public static void multiResource() {
 MyResource r1=new MyResource();
 MyResource r2=new MyResource();
 MyResource r3=new MyResource();
 MyResource r4=new MyResource();
   try(r1;r2;r3;r4)
   {
         r1.doProcess();
         r2.doProcess();
         r3.doProcess();
         r4.doProcess();
   }
   catch(Exception e){
       SOP("Exception "+e);
   }
}
public static void main(String[] args){
    java6();
    java7();
    java9();
    multiResource();
 }
}

Problem with JDK7:
    1. The resource reference variables which are create doutside of try block cannot be used directly in try with resources 


8. Factory method to create unmodifiable collection
        Until JDK1.8, we create an unmodifiable collection using 
    List<String> l=new ArrayList<>();
        l.add("one");
        l.add("two");
    List<String> l1=Collections.unmodifiableList(l);
  But in JDK1.9, if we want to create immutable collection object then we use
     List<String> l3=List.of("One","two","three");

Set s=Set.of("one","two");
Map m=Map.of()
Map m=Map.ofEntries();

List.of() - empty list
List.of("A") - list with 1 elt
List.of("A","B") - list with 2 elt
.
.
List.of(---) - list of 10 elt overloaded method are available
List.of(E...e) - more than 10 elts we use varargs


Set.of() - empty set
Set.of("A") - list with 1 elt
Set.of("A","B") - list with 2 elt
.
.
Set.of(---) - list of 10 elt
Set.of(E...e) - more than 10 elts

Map.of() - empty map
Map.of(k,v) - map with 1 key value
Map.of(k1,v1,k2,v2) - map with 2 key value
.
.
Map.of(---) - map of 10 key value pair

eg: Map<Integer, String> map = Map.of(101, "PP", 102, "QQ", 103, "RR");

Map.ofEntries(E...e) - more than 10 key value 

eg: Map<Integer, String> map = Map.ofEntries(
		entry(101, "PP"),
		entry(102, "QQ"),
		entry(103, "RR")
	);

1. It is used to create unmodifiable collection and we perform any operation then it raise UnsupportedOperationException
2. In all factory methods we are not allowed to use null, then we get NullPointerException
3. If we use duplicate objects in Set and duplicate keys in Map, then we get IllegalArgumentException

9. Stream API enhancement
       - default methods like takeWhile() and dropWhile()
       - static method called Stream.iterate() with 3 args with conditional check 
Stream.iterate(1,x->x<5,x>x+1).forEach(System.out::println);
       - static method called Stream.ofNullable() to check NPE
List l=Stream.ofNullable(100).collect(Collectors.toList());
sop(l); //100

List l=Stream.ofNullable(null).collect(Collectors.toList());
sop(l); //[]

List<String> l=new ArrayList<>();
l.add("A");
l.add("B");
l.add(null);
l.add("C");
l.add("D");
l.add(null);
System.out.println(l);

List<String> l3=l.stream().flatMap(o->Stream.ofNullable(o)).collect(Collectors.toList());
sop(l3);

Map<String,String> hm=new HashMap<>();
hm.put("A","Apple");
hm.put("B","Banana");
hm.put("C",null);
hm.put("D","Dog");
hm.put("E",null);

List<Stream> l2=m.entrySet().stream().flatMap(e->Stream.ofNullable(e.getValue())).collect(Collectors.toList());
sop(l2);

10. Diamond operator enhancement
       From JDK1.5, <> is applied for normal classes. But from JDK1.9 onwards <> can applied to anonymous inner classes

Iterator<String> itr=new Iterator<>(){
  ---
}

11. safevarargs annotation
       If one type of object(like String) pointing to another type of object(like Integer) at runtime, then it throws ClassCastException, this typeof scenario is called Heap Pollution problem 
     eg: Student s1=customerObject;
       This annotation introduce in Java7. To suppress warning related to heap pollution problem we use SafeVarargs.
       If we use varargs with generics, there may be problem of heap pollution problem,then compiler will show warning message. So if u want to suppress those warnings then we use Safevarargs annotation
        Until Java1.8, SafeVarargs used in static method, final method and constructor, but from Java9 it can use it for private methods 

public class Test {
   @SafeVarargs
   public Test(List<String>...l){ }
   @SafeVarargs
   public static void m1(List<String>...l){ }
   @SafeVarargs
   public final void m2(List<String>...l){ }
   @SafeVarargs
   private void m3(List<String>...l){ }
}

public class Test {
    public static void main(String[]args){
       List<String> l1=Arrays.asList("A","B");
       List<String> l2=Arrays.asList("C","D");
    }
    //@SafeVarargs
    public static void m1(List<String>...l){
         for(List<String> l3:l) {
            System.out.println(l3);
         }
    }
 }
}
    So when we compile the above program, we get warning message 
>javac -Xlint:unchecked Test.java
    So if we want to suppress those warning we use above annotation
   

12. G1 garbage collector which came from jdk1.6 version, but from jdk1.9 it is default garbage collector 
     Generally we have different garbage collector like 
  - Serail GC
  - Parallel GC - until jdk1.8 default is parallel GC 
  - Concurrent Mark Sweep GC
  - G1 GC, not work based on generation, here total heap is divided into multiple regions. G1GC will choose one region where more number of objects eligible for GC and destroy that region, so performance wise it is best GC 
  

java NIO
   - We can use nio package to read from a file or write to a file
   - The basic reason to launch java.nio package since it was providing the multithreading capability to io library and we cannot do this in existing io library. So nio means non blocking io that you dont want to block ur threads while ur reading from file or writing to file.
   - Non blocking io is because whenever you are reading a file or writing to file, the thread gets blocked until the whole life is written or the whole file is read, so the nio package provides an improvement over that, it provides an improvement in a way that you can read the file into different thread but at the same time move on to an another thread and writes to the file, so we get this multithreading capabilities and non blocking capabilities by the classes provided by java.nio
    - Consider we are trying to read something then the read operation will be happening from the channel into the buffer. Similarly the write operation will be happening in reverse way (ie) to the channel from the buffer 

Path - represents the path to actual file or directory you are willing to work

Paths - helps to load the Path from a String or a URI

In Java nio package, inorder to refer to path we use Path interface which is used to refer the path. To create instance of Path interface we use Paths class with factory method called get()
    Why we have an interface or factory method to refer to paths instead of class because in legacy way of working with class (ie) java.io.File class, the problem is the paths are not same in all OS. When we use Path no matter for any OS, it refers to path. So when we run internally it refers to a class implementation called sun.nio.fs.WindowsPath

import java.nio.file.Path;
import java.nio.file.Paths;

public class Example1 {

  public static void main(String[] args) {
    Path p1 = Paths.get("a/b/c");

    Path p2 = Paths.get("a", "b", "c");

    System.out.println(p1);
    System.out.println(p2);
    System.out.println(p1.getClass());
  }
}

Path Operations:

public class Example2 {

  public static void main(String[] args) {
    Path p1 = Paths.get("a/b/c/d"); // relative
    Path p2 = Paths.get("/c/d"); // absolute since it start with /
    Path p3 = Paths.get("C:/a/b/c"); // absolute

    System.out.println(p1.getFileName()); // d
    System.out.println(p1.getRoot()); // null
    System.out.println(p1.getParent());  // a/b/c

    System.out.println(p2.getFileName());
    System.out.println(p2.getRoot());
    System.out.println(p2.getParent());

    System.out.println(p3.getFileName());
    System.out.println(p3.getRoot());
    System.out.println(p3.getParent());
    System.out.println(p3.getName(1));
  }
}

Example 3:
    Here we create unnormalized path which means the shorter version of path 
   ./ - current dir    ../ - parent directory 
We can normalize and reduce to smaller path using normalize(). We can normalization when we find current dir or parent dir, current dir we can simply remove it, because it is samething with or without, so now we have 
   a/b/c/./././d/../../c
   a/b/c/d/../../c
When we have parent dir, it will always remove the file up one level,so finally we have a/b/c
    a/b/c/d/../../c
    a/b/c/../c
    a/b/c


public class Example3 {

  public static void main(String[] args) {
    Path p1 = Paths.get("a/b/c/./././d/../../c");  // ./  ../

    /**
     * a/b/c/./././d/../../c    ---->    a/b/c
     */

    System.out.println(p1.normalize());

    Path p2 = Paths.get("a/../../../b"); // relative

    /*
    *  ../../b (we dont have parent to remove it after a/../
     */
    System.out.println(p2.normalize());

    Path p3 = Paths.get("/a/../../../b"); // absolute /b

    /*
        /a/../../../b
        /../..b  - in this case parent dir acts like current dir so we can just remove it 
        /b
    */
        

    System.out.println(p3.normalize());
  }
}


Example 4
   - resolve is kind of concatentation of paths 
   - For relative path is just simple concatentation
   - For absolute path
public class Example4 {

  public static void main(String[] args) {
    Path p1 = Paths.get("a/b/c");  //relative
    Path p2 = Paths.get("d/e/f");  //relative

    Path p3 = p1.resolve(p2); // a/b/c/d/e/f

    System.out.println(p3);

    Path p4 = p2.resolve(p1); // d/e/f/a/b/c

    System.out.println(p4);

  //If one path is absolute and another is relative, if absolute path is first and relative is second then it works as concatenation
    Path p1 = Paths.get("/a/b/c");  //absolute
    Path p2 = Paths.get("d/e/f");  //relative

    Path p3 = p1.resolve(p2); // /a/b/c/d/e/f

    System.out.println(p3);

    //If absolute path is second then it prints always absolute path

     Path p4 = p2.resolve(p1);  // /a/b/c

    //If both are absolute then it prints always second absolute path

     Path p1 = Paths.get("/a/b/c");  //absolute
    Path p2 = Paths.get("/d/e/f");  //absolute

    Path p3 = p1.resolve(p2);  // /d/e/f
  }
}


Example 5:
   - 0th index in getName dosent start from root 

public class Example1 {

  public static void main(String[] args) {
    Path p1 = Paths.get("C:/a/b/c/d");  //absolute

    System.out.println(p1.getRoot()); // C:\
    for (int i=0; i<p1.getNameCount(); i++) {
      System.out.println(p1.getName(i));
    }
  }
}

Example 6:
   subpath - part of path

public class Example2 {

  public static void main(String[] args) {
    Path p1 = Paths.get("C:/a/b/c/d");

    Path sp = p1.subpath(0, 3); //begin to end-1

    System.out.println(sp);  // a/b/c
  }
}


Example:
     relativize() tells how to get Path p1 to Path p2,  it can be used for both relative or both absolute. Imagine in cmd prompt, if we want to get to another path then we give cd in linux or windows env and we specify the relative path.
    So this method tells what u write in cd command line to get from p1 to p2  

public class Example3 {

  public static void main(String[] args) {
    Path p1 = Paths.get("b/c/d");
    Path p2 = Paths.get("b/q/w");
     
    //In p1, from d we call parent dir it goes to c, then again parent dir it goes to b, then q then w
    // cd ../../q/w

    Path p3 = p1.relativize(p2);//it returns path to move from p1 to p2

    System.out.println(p3);

//If we relativize absolute and relative path or other way we get an IllegalArgumentException 
    Path p1 = Paths.get("C:/b/c/d"); // absolute
    Path p2 = Paths.get("b/q/w"); // relative

    Path p3 = p1.relativize(p2); // throws an exception

    System.out.println(p3);
  }
}


Example:
   - createFile() used to create a file and all method in Files will throws IOException or FNFE

public class Example5 {
  public static void main(String[] args) throws IOException {
    Path p1 = Paths.get("demo.txt");
    Files.createFile(p1);  //creates demo.txt
  }
}

Example:
   - To delete we have delete() and deleteIfExists()
   - delete() throws an exception if the file dosent exist, it works only for files and empty folder. If we try to delete the folder containing file it wont work 
   - deleteIfExists() not throw an exception if the file dosent exist, instead it return boolean value false 

public class Example6 {
  public static void main(String[] args) throws IOException {
    Path p1 = Paths.get("demo.txt");
// Files.delete(p1);  //delete the file for 1st time, but 2nd time throws exception
    var res = Files.deleteIfExists(p1);
    System.out.println(res); // false
  }
}

Example:
   createDirectory() - create single dir in given path
   createDirectories() - create multiple dir one inside the other 


public class Example7 {

  public static void main(String[] args) throws IOException {
    Path p1 = Paths.get("demo.txt"); //create demo.txt with some content 
    Path p2 = Paths.get("copied.txt");

//    Files.copy(p1, p2); //create copied.txt and copy the contents of demo.txt
    Files.move(p1, p2);  //like cut and paste, so demo.txt is replaced to copied.txt 
  }
}

Example:
    isSameFile() - comparing 2 files and returns boolean
          - it dosent compare the contents, if we have 2 different files identical then isSameFile will return false
          - it tells that 2 path precisely goes to same file in file system. For example one of them is file and other is symbolic link to the file, it returns true because both paths goes to same file 
          - if one of file dosent exit it returns an exception 
          - If both paths have same file and if both of them dosent exit, it dosent throw an exception and it returns true 


public class Example8 {
  public static void main(String[] args) throws IOException {
    Path p1 = Paths.get("demo.txt");
    Path p2 = Paths.get("copied.txt");
    boolean res = Files.isSameFile(p1, p2);
    System.out.println(res); //false

    Path p3 = Paths.get("demo.txt");
    Path p4 = Paths.get("demo.txt");
    boolean res = Files.isSameFile(p3, p4);
    System.out.println(res); //true

    Path p1 = Paths.get("qwerty.txt");  //dosent exit
    Path p2 = Paths.get("copied.txt");
    boolean res = Files.isSameFile(p1, p2);
    System.out.println(res); //throws exception

    Path p1 = Paths.get("qwerty.txt");   //dosent exit
    Path p2 = Paths.get("qwerty.txt");    //dosent exit
    boolean res = Files.isSameFile(p1, p2);
    System.out.println(res); //true
  }
}


Example:
     readAllLines() - used to read content of file. If it is text file we can read line by line and return list of all the lines 
      byte[] readAllBytes() - read  binary file like images

Both methods are used for files in small in size, because when u read lines from file we are getting data from external memory to internal memory so if heap is not large enough you will have outofmemory error 


public class Example9 {
  public static void main(String[] args) throws IOException {
    Path p1 = Paths.get("demo.txt");
    var res = Files.readAllLines(p1);
    res.forEach(System.out::println);
  }
}


java.nio.file.Files vs java.io.File
 
1. Create vowel.txt file where we want to parse all rows and how many vowels have in this file

So close no matter how far,
Couldn't be much more from the heart
Forever trusting who we are
And nothing else matters.

Example 1:
   Implement using BufferedReader 

public class Example1 {

  private static String vowels = "aeiouAEIOU";

  public static void main(String[] args) {
    int n = 0;
    try (
        FileInputStream fis = new FileInputStream("verse.txt");
        BufferedReader in = new BufferedReader(new InputStreamReader(fis)
    )) {
      String line;

      while ((line = in.readLine()) != null) {
        for (int i = 0; i<line.length(); i++) {
          if(vowels.contains(String.valueOf(line.charAt(i)))) {
            n++;
          }
        }
      }
    } catch (Exception e) {
      e.printStackTrace();
    }

    System.out.println(n);
  }
}

How we make implementation to shorter?

Way 1: Using Files class newBufferedReader() of nio package 

public class Example2 {

  private static String vowels = "aeiouAEIOU";

  public static void main(String[] args) {
    int n = 0;
//try (BufferedReader in = Files.newBufferedReader(Paths.get("verse.txt")))
    try (var in = Files.newBufferedReader(Paths.get("verse.txt"))) {
      String line;

      while ((line = in.readLine()) != null) {
        for (int i = 0; i<line.length(); i++) {
          if(vowels.contains(String.valueOf(line.charAt(i)))) {
            n++;
          }
        }
      }
    } catch (Exception e) {
      e.printStackTrace();
    }

    System.out.println(n);
  }
}
   

Files have 4 methods with return type as Streams, so we can use Stream API methods on that data that comes from files 

Way 2: Using Files.lines()

public class Example3 {

  private static String vowels = "aeiouAEIOU";

  public static void main(String[] args) {
    try {
      var res =
        Files.lines(Paths.get("verse.txt"))
             .flatMap(line -> Arrays.stream(line.split("")))
             .filter(c -> vowels.contains(c))
             .count();
      System.out.println(res);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}

Here lines() takes the path of the file and return the streams which contains the lines read from the file. Now we call flatMap() which takes the value and returns the stream of different values, in this case we take line from Stream which we read and change to stream of characters, so after flatMap instead of having lines we  have as characters and check it directly 
   .flatMap(line -> Arrays.stream(line.split(""))) - Here we basically transforms the stream of streams into another stream of streams and instead of containing lines it will contains each characters of each lines as a value.
   .filter(c -> vowels.contains(c)) - Now we check which of them is vowel by simply filtering out and finally count it 


Way 3: Using Files.list() used to return the contents of files and folder inside the folder as Paths

public class Example4 {
  public static void main(String[] args) {
    try {
      Files.list(Path.of("."))
            .filter(p -> !p.toString().endsWith(".txt"))
            .forEach(System.out::println);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}

List all files and folders inside the current project that are not text files

Using Files.walk() - used to specify the depth of tree structure of the folder you want to go 

public class Example5 {
  public static void main(String[] args) {
    try {
      Files.walk(Path.of("."), 3)
            .forEach(System.out::println);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}

Now it will display the folder structure with 3 folder depth

Using Files.find(Path,depth,BiPredicate) - used to find files based on specific properties 

public class Example6 {

  public static void main(String[] args) {
    try {
      Files.find(Path.of("."), 3, (p,a) -> a.size() < 100)
            .forEach(System.out::println);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}

Here p - current path, a - attribute of path. So here we display from current path to folder depth 3 with size < 100

1. By using java.io.File class we are not using any abstraction, since File is regular class we can instantiate and it has constructors. The reason why we use abstraction in nio package is when we deal with Path and operating file system,depending on OS we have different approaches to work with paths. So when we use abstraction by means of Path interface we get instance specific to OS we are running, we dont want to take care by ourself, ur JVM will do correct implementation since we use factory method of Path interface. So java.io.File since we dont have abstraction, ur JVM will not take care 

2. File f=new File("test");
    f.createNewFile();
java.io.File dosent support Single Responsibility principal (ie) the class in ur appl will have only one purpose, but here File is used to represent the path and also its object executing the operation on file system itself, so it has 2 responsiblity  

Path p=Paths.get("demo.txt");
  But in new approach it separates the responsiblity, we have Path implementation where we dont instantiate but we use factory method, which take cares about the path and operation on paths.
   Then we have separate class called Files which used to perform operation on file system


JDBC
   - JPA is specification, hibernate used for implementing the specification and hibernate uses JDBC behind the scenes
   - JDBC provided all interface for communication but it is abstraction and we provide the implementation by providing different dependency for the different db, so there is common code in Java to connect will all db
   - JDK dosent come with implementation for specific databases so we have to add separate dependency into classpath, so in JDK we find only the abstractions like interfaces. So this way ur java appl will become independent to which dbms we communicate, thats why each technology has its own jdbc driver which is external, you add it in ur classpath and then you just have to use abstractions from JDK and ur appl will automatically during runtime use the proper implementations from the dependency u add

execute() - can be used for anytype of SQL queries
          - returns boolean - true if it is select and false for others
          - If my query is dynamic, somehow we dont know what query it will be from very beginning then we can use execute()

executeUpdate() - used for DML queries, return an int
executeQuery() - used for Select, return ResultSet

So in case of execute(), whatever the method gets it will be executed, so if we have an appl that only needs to send the select but we use execute() and that select query comes from somewhere and it can be somehow altered from outside, you have a vulnerability that you didnt see, and somehow bad intention people can change ur select to a drop table which is called as SQL Injection. If u use execute() that alter can actually be executed but if you have that vulnerability which might happen and you didnt find in time, but if we use executeQuery because it should be only select query, then eventhough someone frm outside would be able to change the select to alter or drop table, it will still not be executed 


Java Reflection API
    - used to call private members of the class from outside

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Call {
}

public class ProductService {

  private int x; // 1000

  private ProductService() {

  }

  public void addProduct() {
    System.out.println("Adding product in the DB.");
  }

  @Call
  public void editingProduct() {
    System.out.println("Editing product in the DB.");
  }

  public void printX() {
    System.out.println(x); // 1000
  }
}

So we have a ProductService class, if we want to access its methods we create an object and access. But how can spring or other framework can control classes using the principal called IOC, we allow the framework to control the classes, because framework cannot access the constructor of class using reflection API 
   Reflection is used to control the compiled code


public class Example1 {

  public static void main(String[] args) {
    String k = "service.ProductService";

    // Class
    try {
      Class productServiceClass = Class.forName(k);

      Constructor c = productServiceClass.getDeclaredConstructor();
      c.setAccessible(true);

      Object o = c.newInstance();

      Method m = productServiceClass.getDeclaredMethod("addProduct");
      m.invoke(o);

    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}

public class Example2 {

  public static void main(String[] args) {
    String k = "service.ProductService";

    try {
      Class productServiceClass = Class.forName(k);

      Constructor c = productServiceClass.getDeclaredConstructor();
      c.setAccessible(true);

      Object o = c.newInstance();

      Method[] methods = productServiceClass.getDeclaredMethods();

      for (Method m : methods) {
        if (m.isAnnotationPresent(Call.class)) {
          m.invoke(o);
        }
      }

    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}


public class Example3 {

  public static void main(String[] args) {
    String k = "service.ProductService";

    try {
      Class productServiceClass = Class.forName(k);

      Constructor c = productServiceClass.getDeclaredConstructor();
      c.setAccessible(true);

      Object o = c.newInstance();

      Field [] fields = productServiceClass.getDeclaredFields();
      for (Field f : fields) {
        f.setAccessible(true);
        f.set(o, 1000);
      }

      Method m = productServiceClass.getMethod("printX");
      m.invoke(o);
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
 

Multithreading
   - Thread is basically a set of instructions that execute in defined order, in parallel and independent of other set of instructions of same program 
    Usually if we have one thread then we call us single thread program, in case of Java the first thread that starts with main method is called as main thread 
   - Whenever we create a thread, there will be some time from starting of thread till the thread is started, so only it will print main thread then it goes to other child threads 

   - Implements Runnable in this case my object dosent act like thread, so we use Thread class and transforms this task into thread and specify that task will execute independently in same program 

   - join is the direct way you can specify that the thread must wait after another thread finishes. So the first way of synchronization is not by using synchronized keyword but using join()
    Imagine we need to fetch data from 2 different databases and use that data for some processing. So consider we query DB1 (ie) first database and DB2 (ie) second database and then do processing, but when we query the data we actually dont care whether it is 1st db or 2nd db, the order from which we fetch the data is not important because in the end when we go to processing then we simply we need to have all the data, so it dosent really matter in which order u take them.
   Consider db1 takes 3 secs, so in order to take the data from db1, the functionality u have it takes about 3secs and db2 takes 2 secs and once u collect the data we can start processing.
   In this scenario is how we can implement that so the first approach is put them on the same thread then no matter in which order you will fetch the data, u will basically at some point spend 3+2=5 sec and then we can start processing
   Now we want to change something so that we can spend less time with entire program like instead of querying them one by one, you would basically query them all together then instead of having the times added we will actually have max time of max(3,2) which is 3sec. 
  So in my example if we put those 2 together on different thread then we might have a chance to spare couple of seconds and also we want to start the processing only after querying the database because if we do actually start the processing and if we do put this on different threads and then processing remains on 3rd thread, then that means all 3 are completely in parallel now so when we actually start db1 and db2 querying on those different threads, then the processing will start at the same time and we cant start the processing because we dont have data yet so we have make sure that processing starts only both db1 thread and db2 thread have ended and returned data. This can be done using join() of Thread class 


public class DB1Runnable implements Runnable {

    @Override
    public void run() {
        try {
            Thread.sleep(3000);
            System.out.println("DB 1 querying ended...");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}


public class DB2Runnable implements Runnable {

    @Override
    public void run() {
        try {
            Thread.sleep(2000);
            System.out.println("DB 2 querying ended...");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class Example2 {

    public static void main(String[] args) {
        // 1
        // query DB1  -> 3 seconds
        // query DB2  -> 2 seconds
        // max(3 , 2) = 3  <  5

        // 2 --> join()
        // processing

        var db1 = new DB1Runnable();
        var db2 = new DB2Runnable();

        var t1 = new Thread(db1);
        var t2 = new Thread(db2);

        t1.start();
        t2.start();

        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("PROCESSING..."); // main
    }
}

Synchronized Block
    - We have resource that is used by multiple threads of 2 kinds. One kind is Producer which is used to produce something in shared resources and other kind of thread is Consumer which is used to consume something that Producer produces in shared resource. Consider shared resource as bucket in which Producer produces something and some consumer taking something from there  
   We create Producer which generate random numbers in the bucket and consumer will consume the numbers from bucket.

1. Create Main class, with ArrayList object and here we used ArrayList because it is not synchronized and it will act as bucket where we put the values and inside main() we start Producer and Consumer thread 

public class Main {

    public static List<Integer> bucket = new ArrayList<>();

    public static void main(String[] args) {
        Producer p1 = new Producer("p1");
        Producer p2 = new Producer("p2");
        Consumer c1 = new Consumer("c1");
        Consumer c2 = new Consumer("c2");

        p1.start();
        p2.start();
        c1.start();
        c2.start();
    }
}

2. Create Producer thread and create name for the thread inside the Constructor. Next we override run() to design the functionality of this thread, make the thread runnable continously using while(true) and we check if bucket size is more than 100 and we add random values in bucket from 0 to 999
   So we designed the Producer which continously run, if bucket size is more than 100 then we generate new random number and add into bucket and also print value in console 

public class Producer extends Thread {

    public Producer(String name) {
        super(name);
    }

    @Override
    public void run() {
        Random r = new Random();
        
        while (true) {
                // synchronized (Main.bucket) {
                if (Main.bucket.size() < 100) {  // T1
                    int n = r.nextInt(1000); // [0,999]
                    Main.bucket.add(n);
                    System.out.println(Thread.currentThread().getName()
                            + " added value " + n + " to the bucket");
                }
            //}
        }
    }
}

3. Create Consumer thread which will take value from bucket, create name of consumer thread inside constructor
    Now we override run() which run continuously using while(true) and we check if bucket is not empty, then we try to get the value from index 0 and remove the value from index 0 and print the value in the console 

public class Consumer extends Thread {

    public Consumer(String name) {
        super(name);
    }

    @Override
    public void run() {
        while (true) {
               // synchronized (Main.bucket) {
                if (!Main.bucket.isEmpty()) {
                    int n = Main.bucket.get(0);
                    Main.bucket.remove(0);
                    System.out.println(Thread.currentThread().getName()
                            + " took out the value " + n + " from the bucket");
                }
            //}
When we run u can see consumer thread is completely stops and producer threads only running. It is not working fine because we didnt synchronize producer and consumer. So we apply synchronized keyword on block of object.
    Synchronized block is one in which if one thread enters and acquires the lock, no other threads will be allowed to enter until one inside ends and releases the lock.

         
        }
    }
}


wait() and notify()
    Previously we created 2 instance of Producer(P1,P2) and Consumer(C1,C2) with synchronized block. Producer have synchronized the decisional structure where we change the bucket by adding random values and Consumer as well has synchronized decisional structure where we work with bucket by removing the values.
     We added synchronized block since we worked with shared resources, as we discussed when we have multiple threads working with same resource then we have to synchronize it otherwise we will face problem when 2 different threads actually try to change the same resource and thats called Race condition.
      When C1 thread access to synchronized block and we have a monitor which is an object used to manage synchronized block (ie) bucket. So C1 manages to obtain the lock from bucket (ie) C1 is actually working, so unless C1 finishes the synchronized block no other threads can be working, the reason one at time is same monitor (ie) bucket manages all threads
   In case of Consumer if condition is true we will consume one of value from bucket (ie) bucket is not empty so we consume one of value. But if the condition is false (ie) the bucket is empty and we are in while(true) and in same thread will be executing the same thread again and again, and we dont know how long JVM will stay with these C1 thread, but we are in synchronized block and no other thread at the same time, basically there is no Producer to add the value so condition will never change 
   So in case of false condition we simply left at JVM decision how many times would consumer executes which is not good performance because we already know that if condition is false then from our perspective that consumer should automatically get out and allow Producer enter the stage to add the value, for the other consumer to consume the value, then same will come for Producer also.
   So if Producer finds out if already there are 100 elements and it cannot add 1 more element in list then instead remaining there continously testing same condition which will never get through, so instead of that we actually have to  wait to allow another thread going to the stage (ie) consumer to enter the stage so that it will make list size smaller than 100.
   To do that we have an option, if condition is false and Producer cannot add anymore the values, it has to wait and it is the monitor Main.bucket who is managing the thread telling the thread to wait. wait() is a method which puts the current thread in blocked state 
    Main.bucket.wait() which makes producer to waits now because it cant add any value, so here we made producer to wait for the consumer to consume the value before it test again the condition, otherwise without that wait there our Producer will continuously run the evaluation of condition which dosent make sense because we know this condition wont become true if one consumer will consume the value.
    wait() and notify() has to be called only inside synchronized block. It is always monitor object Main.bucket should be calling wait() and notify(). wait(),notify(),notifyAll() are present in Object class because any object will be passed as an monitor.
   Now we goto Consumer class and after removing the value we will notify the threads using notify() or notifyAll() method. notify() will notify the next waiting thread whereas notifyAll() will notify all the waiting thread. In our case we dont know next thread is consumer or producer, so we use notifyAll().  
    The same thing can be done for Consumer, if no values then consumer waits using Main.bucket.wait() and when the consumer should continue when there is atleast one value in the bucket, that means one producer has added the value so notify the consumer thread when new value has been added 

public class Producer extends Thread {

    public Producer(String name) {
        super(name);
    }

    @Override
    public void run() {
        try {
            Random r = new Random();
            // 100  wait() notify()

            // scja / scjp -> oca8 / ocp8 -> ocp I 11 / ocp II 11
            while (true) {
                synchronized (Main.bucket) {
                    if (Main.bucket.size() < 100) {  // T1
                        int n = r.nextInt(1000); // [0,999]
                        Main.bucket.add(n);
                        Main.bucket.notifyAll();
                        System.out.println(Thread.currentThread().getName()
                                + " added value " + n + " to the bucket");
                    } else {
                        Main.bucket.wait(); // producer waits now
                    }
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class Consumer extends Thread {

    public Consumer(String name) {
        super(name);
    }

    @Override
    public void run() {
        try {
            while (true) {
                // not sync
                // Tx
                synchronized (Main.bucket) {
                    if (!Main.bucket.isEmpty()) {
                        int n = Main.bucket.get(0);
                        Main.bucket.remove(0);
                        Main.bucket.notifyAll();
                        System.out.println(Thread.currentThread().getName()
                                + " took out the value " + n + " from the bucket");
                    } else {
                        Main.bucket.wait();
                    }
                }

                // not sync
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

Usage of Synchronized keyword

public class Example1 {
    private Object monitor = new Object();

    public void a() {
        synchronized (monitor) {

        }
    }

/* Even we can use instance of this class itself and use the current instance as monitor which will affect synchronization, we cant use outside the class. In Producer Consumer case we want synchronize producer with consumer so we have 2 different classes we couldnt simply use "this" in that case we wouldnt synchronize directly the different kinds of thread, so we decided to use unique montior "Main.bucket" */
    public void b() {
        // here
        synchronized (this) {

        }
        // here
    }

/*synchronized in method which means the whole block of code of method is synchronized and the monitor is hidden, so method b() and c() is similar */
    public synchronized /* this */ void c() {

    }

/*synchronized keyword on static method, so we dont have "this" instance, static means part of class */
    public static synchronized void d() {

    }

/* When ClassLoader in java which is mechanism of JVM managing the classes, when it is loading the blueprint of the class it actually creates an instance which refers to blueprint itself. The main idea is that when we work with synchronization on static methods so synchronization basically done using that instance which represent the class itself*/
    public static void e() {
        synchronized (Example1.class) {

        }
    }
}


Deadlocks
   - It is problem occured in multithreading architecture
   - Racecondition is a situation when multiple threads try to access and change one resource, so the same resource is accessed and more threads try to change it. Synchronization is a way to avoid racecondition because by synchronization u simply specify that the threads should be working with shared resource one after another and not try to change it at sametime.
    - Deadlock means we have 2 or more threads because the code is designed wrongly, u face a situation in which they wait one after the another so the code will stucked, process is blocked and thread cannot continue

1. Create Example3.java with 2 methods m1() and m2(), assume that these 2 methods are executed from 2 different threads and we use 2 objects as ur monitor.
   For some reason inside m1(), we implement a code to synchronize on "a" and inside we create other synchronized block on "b". The same thing in m2() but in reversed format.
   We have multiple threads and they are calling this 2 methods, because they are threads they might call 2 methods simulanteously or in any order and we dont know precisely how it will be called 
   Conside thread T1 enters method m1() and another thread T2 enters method m2(). Now T1 proceed with execution and comes between synchronized(a) and synchronized(b), now no other threads can enter synchronized block of "a", consider we have thread T3 and it has to wait, it cant enter because it is already executed by thread T1. So when we have active thread that obtain lock for the monitor then all other threads have to wait until other thread finishes its execution.
   At same time thread T2 can proceeds and obtain the lock from synchronized(b) to synchronized(a). Why T2 is possible to enter the block because it has different monitor, previously T1 enters the synchronized block and obtains the monitor of "a", but monitor b is free and dosent have any lock, so now we have another thread T4 it wont enter the synchronized(b) because it is already taken by T2, until T2 finishes the execution no other thread can obtain lock on b
   Now T1 obtain the lock on "a" and it cant enter synchronized(b) because T2 have already obtain the lock of b, but at same time T2 at somepoint it enters synchronized(a) and T2 cannot obtain because monitor "a" is already taken by T1. So T1 can proceed only if T2 ends its synchronized block, but T2 cannot obtain access to synchronized block and T2 is waiting for T1 to complete the synchronized block but T1 cannot complete because it cannot enter synchronized(b) because it is taken by T2, so basically T1 is waiting for T2 and T2 is waiting for T1. So they are locked and they are waiting one after another and that is deadlock.
   We have deadlock when atleast 2 threads that running one after another, in such situation neither of them cant proceed.

public class Example3 {

    private Object a = new Object();
    private Object b = new Object();

    public void m1() {
        // T3
        synchronized (a) {
            // T1
            synchronized (b) {  // DEADLOCK

            }
        }
    }

    public void m2() {
        // T4
        synchronized (b) {
            // T2
            synchronized (a) {  // DEADLOCK

            }
        }
    }
}

So if we have monitor a and b in same order in both m1() and m2() then deadlock can be avoided.

public class Example4 {

    private Object a = new Object();
    private Object b = new Object();

    public void m1() {
        // T3
        synchronized (a) {
            // T1
            synchronized (b) {

            }
        }
    }

    public void m2() {
        // T4
        synchronized (a) {
            // T2
            synchronized (b) {

            }
        }
    }
}


Executor Services
    - Create an instance of ExecutorService interface, but in inheritance tree it will start with Executor interface, ExecutorService extends Executor interface 
    To create ExecutorService using Executors class which have static methods used to create specific kind of  ExecutorService 

ExecutorService service = 
                  Executors.newFixedThreadPool(n);

ThreadPool is something like collection of threads and take tasks and execute those tasks, the purpose is put the tasks inside the pool and somebody will take and execute that task. Consider we have service desk in company and say we have 10 people behind the interface of service desk and somebody can simply create the task in web interface and who create the task dont know who will take the task and process it, it will be one of 10 people behind working on service task but completely decoupled from the user, in this way only thread pool works. Its decoupling one who creates the task, from whom have executed the tasks (ie) threads
    Previously we created the thread ourself using Thread class or Runnable interface, but here we wont create any thread so ExecutorService is consider as high level multithreaded framework of JDK since we dont want to manage the thread ourself so we just create the task and throw the task and they will taken and execute by threadpool
    Consider we have olympic pool and that contains different swin lane and each swin lane will have one swimmer. Now we are throwing balls inside swimming pools and balls are basically tasks, the swimmers need to take the ball and move it from one side to other side of lane. Here swimmers are basically threads and we can have as many threads.
    Balls are the tasks and we are throwing in the pool and we dont know which swimmer will take the ball, but we know at somepoint when swimmer will come available they can take that ball and move it to other side. So throwing ball into swimming pool is task and we create task by using Runnable or Callable interface where Runnable dosent return anything but Callable returns some value. 
    Basically swimming pool is ExecutorService, balls are tasks, swimmers are threads and swim lanes are CPU that available in ur system so we cant have multiple swimmers on same lane because we cant have multiple threads executing on same CPU so we can have one swimmers in a lane since lane represented as CPU and it can execute only 1 thread at a time and we wont create more threads than the number of lanes or CPU because other threads cant be executed 

   - execute() from Executor class receives a Runnable where we can create an task 
   - We need to always close the ExecutorService using shutdown(), if not the appl will still run in background. Unfortunately ExecutorService dosent implement AutoCloseable interface so we couldnt use it in try with resources so we have to shutdown the service inside finally block

public class Example1 {

    public static void main(String[] args) {
        // Executor <- ExecutorService

        ExecutorService service = null;
        try {
            int n = Runtime.getRuntime().availableProcessors();
            service = // pool
                    Executors.newFixedThreadPool(n); // threads

            Runnable r = () -> System.out.println(":) " +
                    Thread.currentThread().getName()); // ball

            service.execute(r); // throwing the ball into the pool

            System.out.println(":( " + Thread.currentThread().getName());
        } finally {
            if (service != null) {
                service.shutdown();
//                service.shutdownNow();
            }
        }

    }
}

When we use shutdown() and we add some tasks inside pool and when we call shutdown() it will place the pool inside shutdown state and wait for the task to finish inside the pool, so we wont close the pool until all tasks are already existing in pool finishes. Using shutdownNow() it actually stops the pool eventhough u still have tasks inside it without basically executing those tasks. shutdown() returns void and shutdownNow() returns List<Runnable> which are tasks havent been executed 

Example 2:

public class Example2 {

    public static void main(String[] args) {
        ExecutorService service = null;
        try {
            int n = Runtime.getRuntime().availableProcessors();
            service = // pool
                    Executors.newFixedThreadPool(n); // threads

            Runnable r = () -> System.out.println(":) " +
                    Thread.currentThread().getName()); // ball

//Here generic type is ? because we dont return anything begin Runnable  
            Future<?> f = service.submit(r); // throwing the ball into the pool

            System.out.println(":( " + Thread.currentThread().getName());
        } finally {
            if (service != null) {
                service.shutdown();
            }
        }
    }
}

To create task, we can call submit() which takes Callable or Runnable as argument and returns Future which is defined by ExecutorService interface.
    We can use submit() to find out if ur task is executed properly (ie) we can refer to task from outside by using Future interface 


Future, Runnable and Callable interface

Example 1:
public class Example1 {

    public static void main(String[] args) {
        ExecutorService service =
                Executors.newFixedThreadPool(4);

        Runnable r = () -> System.out.println(":)"); // ordering a pizza

        Future<?> f = service.submit(r); // order a pizza and get back a receipt

        // do a lot of stuff (buy a lot of things)

        try {
            f.get(); // get your pizza
            // if not ready -> then you have to wait
            // ready -> get() returns the value
        } catch (InterruptedException e) {

        } catch (ExecutionException e) {
            // pizza has been burnt
            // take a decision what you do
        }
        service.shutdown();
    }
}

Create ExecutorService using newFixedThreadPool(), create a task using Runnable interface and execute the task using execute() but it will not return anything. So whenever you do use execute() we can just throw the task into the pool and execute at some point but u never know what happened with ur task.
   More often than execute() we use submit() as 3 overloaded methods submit(Runnable), submit(Runnable,result), submit(Callable).
   When you use submit() you get back Future and Future is an object that u will get back and that enables you interact with the task that you have submitted. Even if it is Runnable and being Runnable it dosent get you back anything, you want atleast to see if it has completed or not, otherwise we use execute() which returns nothing and have no chance of knowing if ur task has been executed or if it is succeeded or thrown an specific exception.

Example of Future interface:
    Imagine going to a big shopping center and want to buy different stuffs for ur family, in between u felt very hungry so went to pizza shop nearby. You go and buy pizza and the pizza is not something u get immediately, u have to wait for the pizza to cooked and it might take sometime to get cooked say 40min, instead of getting pizza u actually get receipt or token that we will use later to get pizza when its ready, so small receipt that u get back after paying and making the order thats basically the Future, so Future is something u get back immediately after doing an action and u will use later to see to get some status about ur task placed into the pool. Now u will able to do things at same time like while ur pizza is cooking, u can just take Future (ie) receipt and u go to shopping centre and buy lot of things and then u come back present the ticket and get back the result like wise Future will be working 

Example 2:
    In certain situations we want to get something back from task in this case we use Callable interface and returns the value 

public class Exemple2 {

    public static void main(String[] args) {
        ExecutorService service
                = Executors.newFixedThreadPool(4);

        Callable<String> c = () -> "Hello!";

        Future<String> f = service.submit(c);

        // do some stuff

        try {
            String value = f.get();
            System.out.println(value);
        } catch (InterruptedException | ExecutionException e) {
            // :(
        }
    }
}

Example 3:
   Now we get the value into the task, process that value and provide the result

public class SummingNumbersCallable
        implements Callable<Integer> {

    private int x, y;

    public SummingNumbersCallable(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public Integer call() {
        return x + y;
    }
}


public class Example3 {

    public static void main(String[] args) throws Exception {
        ExecutorService service
                = Executors.newFixedThreadPool(4);

        var c = new SummingNumbersCallable(3,5); // 8

        Future<Integer> f = service.submit(c);

        Integer sum = f.get();

        System.out.println(sum);
    }
}

Different Implementation of Executors

Example 1:

public class Example1 {

    public static void main(String[] args) {
        // Runtime.getRuntime().availableProcessors();
        ExecutorService es1 = Executors.newFixedThreadPool(4); // param is the no of threads, take from the beginning a fixed number and it creates the pool with precisely that number of threads and the number of threads wont become smaller and it wont become larger during the execution of the app, once the pool is created thats the number that will be used for that pool and you rely that always be that many threads into the pool 

        ExecutorService es2 = Executors.newSingleThreadExecutor(); // equivalent to fixed thread pool with one thread, we have task but you dont need multiple threads, u need only a pool with a single thread then easiest choice is singleThreadExceutor  

        ExecutorService es3 = Executors.newCachedThreadPool();  //creates threads while they are needed, so when you throw tasks into the pool, if the task cannot be taken by any thread because all the threads are already busy, it creates a new thread, it dosent actually store all the thread but it keeps them for a period of time of 60sec and thats why it is called as cached thread pool because it caches the thread for 60sec and if for 60sec the thread dosent get any new task to execute then it will be discarded and if it gets a new task then it will start working on that task and if u throw one more task into the pool and no more threads to execute the task then the pool will create a new thread for you. Number of threads increasing if number of tasks that you throw into the pool and also decreasing when you dont send any tasks into the pool.
   60sec is fixed by the implementers and it cant be changed 

        ExecutorService es4 = Executors.newWorkStealingPool();
//It is added in JDK8 and working on an algorithm called work Stealing algorithm, consider we have 4 threads T1,T2,T3,T4 and each thread execute the multiple task in a queue and execute one task at a time. For example T1 thread have 3 task in queue and T2,T3,T4 having each of them a task that they need to execute, at somepoint T2 ends with executing the task and it remains without the task, so T2 is allowed to steal one of tasks from T1 and put into its execution. The thread can steal task from another one and execute them if it remains without work 
    }
} 


Example 2:
public class Example2 {

    public static void main(String[] args) throws InterruptedException {
        ScheduledExecutorService es1 = Executors.newSingleThreadScheduledExecutor(); // one thread, to add a task to be scheduled on a separate thread then we use this implementation with single thread 
//        ScheduledExecutorService es2 = Executors.newScheduledThreadPool(4);   //same as fixedThreadPool where we have scheduled tasks executing in parallel then we need to have multiple threads 

//create a task and execute after sometime we put into pool
        Runnable r1 = () -> System.out.println(":)");

//schedule the task with Runnable r1, delay of time after the task will be executed and time unit like seconds,min or hours
        es1.schedule(r1, 5, TimeUnit.SECONDS);

        Thread.sleep(6000); // 6 seconds 

        es1.shutdown();
    }
}

After 5sec we can see smiley face prints in the console, we added sleep() just to make sure u allow enough time for the task to be executed, because if we dont add sleep() and we shutdown() then actually my appl will shutdown the pool and will close completely before allowing the task to execute and then see nothing in console, so we have delay in 5sec and also sleep for 6sec just to make sure we can see something in console 
   When we start ur appl we can see it will wait for 5sec and print the smiley and after 1 more second the appl is stopped automatically

Example 3:
public class Example3 {

    public static void main(String[] args) throws InterruptedException {
        ScheduledExecutorService es1 = Executors.newSingleThreadScheduledExecutor();

        Runnable r1 = () -> System.out.println(":)");

//intial delay of 3sec, interval of time of 5sec
        es1.scheduleAtFixedRate(r1, 3, 5, TimeUnit.SECONDS);

        Thread.sleep(15000); // 15 seconds

        es1.shutdown();
    }
} 

scheduleAtFixedRate() method which instruct ur scheduledExecutorService to execute a specific task only with Runnable and specify the delay so the time between the tasks (ie) time between the start of first task to be executed and the period which is the delay between the task.
    When we run first smiley prints in console after 3sec delay and each smiley prints after 5sec interval until 10 sec sleep, so shutdown will happen before 4th smiley prints 

Example 4:
public class Example4 {

    public static void main(String[] args) throws InterruptedException {
        ScheduledExecutorService es1 = Executors.newSingleThreadScheduledExecutor();

        Runnable r1 = () -> System.out.println(":)");

        es1.scheduleWithFixedDelay(r1, 3, 5, TimeUnit.SECONDS);

        Thread.sleep(15000); // 15 seconds

        es1.shutdown();
    }
}

In scheduleAtFixedRate() immediately after starting the task its start to countdown the seconds and after 5sec it will immediately start a new one and here is a task at somepoint will go over and after 5sec u will have second task executing and it also take longer than 5sec, so u might have specific interval of time where u might have more than 1 task is executing because in fixedrate method it dosent care if the task that u have added to ur pool ends, it will simply just create one more task after the time  of 5sec finished
    But in case of fixedDelay() after an initial time of 3sec we starts the first task and then say that task takes more than 5sec and only after that task ends it comes down 5 more seconds and basically adds the new task, so here 5sec is basically time between the end of the task and beginning of next task, so the total time will be x+5 sec (ie) time of execution of first task is 'X' sec and 5 sec delay so totally 11sec 


ForkJoin framework
    - ForkJoin pool is thread pool and inside we have task.
    - We take large task and split into smaller task and those task will be executed by ForkJoin on different thread. In some situation you can implement tasks recursively (ie) split the tasks into smaller tasks so that u actually split them again and again, after somepoint there is no need to split them anymore because they became small to execute directly and combine those results of all the execution such  that in the end we get total result of full task 
    Consider we have bigger task and split it into T1 and T2 smaller task and again split it into T1 (T1.1, T1.2), T2 (T2.1, T2.2) upto somepoint where u consider that tasks are more enough to execute them and combine those results to get the total result 
   - The type of task is RecursiveAction which is equivalent to Runnable since it dosent return anything 
    RecursiveTask which is equivalent to Callable since it returns some value 

Semaphore Blocking Objects
    - Semaphore is class of java.util.concurrent package 
    - The idea of blocking object is to make synchronization on one to multiple threads for block of code. The only way we discussed about synchonization is by using synchronized keyword either inside method or synchronized block of object.
    - So can we have synchronized block in which we allow multiple threads but a fixed number lets say 2 or 4 or 10. Can we limit the number of threads that are acting on specific block of instructions. With synchronized we cant do that because synchronized is limited to 1, so we have 1 thread inside synchronized block and thats not changing. 
   - By using blocking object called Semaphore which enables u to define a block of code, inside which we can have limit of number of threads that can be active.
   - So instead of using synchronized block we create instance of Semaphore with 2 constructors.
   Semaphore(int) - specify the number of threads it allow n threads to active on specify block of code
   Semaphore(int thread,boolean fair) - 
   true - Fair semaphore - The order in which threads gets acquire is preserved in queue and threads will get into block of code of Semaphore in the order in which they have reach the acquire() 
   false - Non fair semaphore - JVM decides to take one of the thread from the pool and it might not necessary be the order in which they reached the acquire()
   - Next we define block of code using acquire() of Semaphore, so acquire() is used to start the semaphore block of code and release() is used to end it inside finally block. So between acquire() and release() u can only have maximum 4 threads active. Consider if we have T1,T2,T3,T4,T5 threads, only T1,T2,T3,T4 threads can get into block of code and T5 will able to enter block of code only if one of the threads has release the lock. So purpose of Semaphore is to make sure if we have block of code where u have limited number of threads 
   - Consider u have designed an appl and it has to call an external service, the developers of external service system allow to call maximum 10 calls simultaneously. So an easy implementation to make sure that when ur appl is working we can call with 10 simultaneous request by using semaphore. It is blocking object since it is blocking the thread at some point.


public class Example2 {

  private Semaphore semaphore = new Semaphore(4, true);

  public static void main(String[] args) {
    // Sempahore  -> synchronizations
  }

  public void m() {
    try {
      semaphore.acquire();
      // something happens here
    } catch (InterruptedException e) {

    } finally {
      semaphore.release();
    }
  }

  public void n() {
    //  T3
    synchronized (this) {

    }
  }
}


CyclicBarrier
    We have rectangle which is block of code which is to be synchronized, if we use cyclic barrier it actually acts as a stoper for the threads and make sure that, it allows the thread to continue in executing the block of code only when they are at specific number, the number is decide when we create the barrier 
    Barrier is actually works as opposite of Semaphore, the semaphore did allows only specific number of threads to enter whereas cyclicbarrier waits for number of threads and allows all of them to enter block of code, only they are specific number and that number decided at the moment of creation of barrier
     Consider we have thread T1 executes some code and reaches barrier of 3, if it is first thread then it will stop by the barrier and the barrier will wait for 2 more, so basically the number is thread expected by the barrier to allow the threads to enter synchronized block of code. Consider now we have another thread T2 and at the moment both of the threads are blocked by the barrier and it still expects one more thread to arrive, so when thread T3 arrives then all of the thread will be allowed to pass the barriers.
    So barrier is isnt allow the thread to stepin until they reaches the specific number and only they are at specific number they are allowed to entire the block of code 

1. Create task called MyTask which prints the value in console and implements Runnable interface. Create CyclicBarrier inside constructor and specify the number of threads (ie) 3 threads
   await() is a method which stops the thread and make sure it waits for the specific number u have specified. When we call await() without any parameter it completely starts the execution of current thread. This method throws InterruptedException in which the thread is interrupted when thread is in blocked state and BrokenBarrierException in which the exception signalling something is wrong with the barrier and it will thrown if barrier dosent stop the threads

public class MyTask implements Runnable {

  private CyclicBarrier barrier;

  public MyTask() {
    barrier = new CyclicBarrier(3);
  }

  @Override
  public void run() {
    try {
      barrier.await(); // barrier blocks your threads
      System.out.println(":)");
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}

We create 3 threads and first one will be blocked, second also blocked and third reaches await() then all 3 threads step into System.out.println(":)"); line, so it will print 3 smiley faces in the console instead of one after the other. So barrier does a blocking object, it stops the thread until it reaches the specific number of threads u specify when u create barrier itself 
   The second implementation of await() which is overloaded method holds a timeout which is time barrier expects (ie) if barrier has timeout of 10min, it only expects for this maximum time, if maximum time is reached and number of threads didnt reach the barrier then barrier will thrown an exception and tells that timeout has reached. This overloaded method is used in real world scenarios 
   getNumberWaiting() - returns the number of waiting threads on barrier 
   getParties() - create the barrier with number of thread


Now we create ExecutorServices with newFixedThreadPool, and when we use cyclicBarrier make sure you have enough thread, Consider we create thread pool with 4 threads, newFixedThreadPool(4) and it is bigger number than parties in cyclicbarrier as 3. So if newFixedThreadPool number is smaller than parties in cyclicbarrier, then u will always encounter with deadlock.
   Eventhough we have number of threads, u also need to have enough tasks to execute otherwise cyclicbarrier is still continue to execute

public class Example1 {

  public static void main(String[] args) throws Exception {
    ExecutorService service = Executors.newFixedThreadPool(100);

    MyTask t = new MyTask();

    service.submit(t);
    Thread.sleep(1000);
    service.submit(t);
    Thread.sleep(1000);
    service.submit(t);

    service.shutdown();
  }
}

Here first it throws the task and waiting 1sec then it again throws new task and again waiting for 1sec and again throws the task. Since we have barrier instead of printing smiley face in difference of 1sec we basically see them all 3 faces printed in the console on same time because the barrier locks the thread and it only allows all the thread to continue at sametime and reach the barrier. If we comment barrier.wait() in MyTask and run then we can see smiley face will be printed after 1sec interval. 

Semaphore is opposite of cyclicbarrier, if we have semaphore of 3 then it means that it can have 3 threads they can entire the synchronized block and if we have 4th one then it will be stopped by semaphore, if one amoung 3 threads finish its execution then the 4th will enter into the sync block. So with semaphore we can limit the number of threads that access specific synchronized block.
   Readwritelocks is similar to semaphore, unlike semaphore it has 2 levels of synchronization, we have operation that are reading and writing means we have more than 1 thread at same time to specific block but exclude other blocks where specific other operation is writing.


