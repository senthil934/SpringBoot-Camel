Java Versioning
    - There is new java release coming in every 6 month, this is recent development, because of this there are 2 java release every year 

1. JDK1.0 in Jan1996 and there is subsequent release of JDK 2,3,4 after that major release was JDK5

2. J2SE5.0 in sep 2004 and there are 5 releases in almost 8 years 

3. The next major release is JavaSE 8(LTS-Long Term Support) on march 2014 which is most important Java release which bought functional programming, Lambda, Streams

4. Java SE9 in sep 2017 and again 4 release in 13 yrs (from 2004 to 2017 from 5 to 9 version)

5. Java SE10 in mar 2018 which is time based release versioning which means the release will happen for every 6 months and wht are features are ready that would be the part of that specific release

8. JavaSE 11(LTS) on sep 2018
        Java11 is paid versions, only for corporate users it is paid versions and for individual development it is free version. Oracle people have given open jdk for all members and use it

https://jdk.java.net/11/ - just download and extract u get jdk-11, no need to install jre separately and set the path 
9. Java SE 12 on mar 2019 etc
10. JavaSE 16 on mar 2021

Previously there is huge difference between each Java releases however from Java 10 onwards the new features introduced are far less as it coming in every 6 months. Java prefer to use long term support release because they have support for very long time.

Java new features
1. J2SE5.0 - Enhanced forloop,Generics, Enums, Autoboxing
2. Java SE8(LTS) - Functional programming
3. Java SE9 - Modularization(Java Platform Module System)
     Where Modularization of Java is introduced, where entire JDK is now modularized into multiple modules, not only that u can also build appl in modularized way
4. Java SE10 - Local variable type Inference - variable declaration is really complex, java can automatically infer the type of local variable in Java10
5. Java SE14 - Switch expression (Preview in 12 and 13)
      - Instead using switch as statement, from java 14 we can use switch as expression
6. Java SE 15 - Text blocks(Preview in 13)
      - If we want to write complex piece of text having multiple lines with ",', escape characters in Java is very difficult and text blocks make it easier
7. Java SE16 - Record classes (Preview in 14 and 15)
      - We have created many Java beans in previous versions with getter, setter, constructor, toString, equals  etc. In Java 16 we have record classes which makes it easy to create this type of bean classes 
8. All Java versions - There are new api is introduced and almost every version of Java has performance improvements expecially in Garbage collection
    

1. List,Set,Map copyOf method

Java 10 features
1. Local Variable Type Inference
      - Declaring local variable without type
      - Whenever we declare any variable we have to provide its datatype so only Java is called statically typed language, but Angular, Python, Javascript and all is called as dynamically typed one because depending upon the value its datatype is fixed 
     - So from JDK10 we can define any variable with "var" keyword, so compiler will understand depending upon the value it will take up datatype. 
 var a=1234; - So at compile time it will infers as int
After compile time variable "a" becomes of type int
   var b="hello"; //b infers as string at compilation

Limitations
   1. Only local variable will be declared with "var"
   2. var is reserved keyword
   3. var is not allowed in method, constructor arguments, method return types
   4. We cant assign null to var type, because null is generic (ie) it can be any object 
   5. var should be with declaration and initialization
      var a = 10;  //correct

      var a;
      a=10;  //wrong

Example:
public class Sample { PSVM {
    List<String> l1=List.of("One","two");
    List<String> l2=List.of("three","four");
    
    var names=List.of(l1,l2);
    names.stream().forEach(System.out::println);
    //whatever methods avaiable in List will now available in names also. Even when we make some mistake in methods also it will show
}

   -Java compiler infers the type of the variable at compile time
   - Introduced in Java10
   - You can add final if you want, but by default it is not final 
      final var names=List.of(l1,l2);
   - var can also be used in loops
        for(var name:names)
            System.out.println(name);
   - You cannot assign to null
            var abc=null;
   - var is not a keyword
   - Improved readability for chained expression
   var filter=List.of("one","two:).stream().filter(s->s.length()<5);
      filter.forEach(System.out::println);


2. API for creating unmodifiable Collection
     - From util package there are many methods introduce to support unmodifiable collection
     - List.copyOf, Set.copyOf, Map.copyOf used to create immutable list of values from existing list or set or map which cant be changed. If map we are passing is already immutable then it will return map back, it wont create copy
     - New methods toUnmodifiableList, toUnmodifiableSet, toUnmodifiableMap have been added to the Collectors class in stream package, which allow the elements of a stream to be collected into an unmodifiable collection

List<Integer> li=Arrays.asList(1,2,4,6,8);
List<Integer> l1=List.copyOf(li); //creates immutable object
SOP(l1); //[1,2,4,6,8]
l1.add(10); //throws UnsupportedOperationException

Stream<String> s2=Stream.of("a","b","c","d");
List<String> l2=s2.collect(Collectors.toUnmodifiableList());
Set<String> s=s2.collect(Collectors.toUnmodifiableSet());

Java 11 Features  
https://www.youtube.com/watch?v=gjr92jxiEd8
    
1. JRE Updates
      - From JDK11 onwards there is no jre install in the user machines. When u install JDK, JRE was getting install in our machines. But now onwards we wont get any JRE. So JDK and JRE are together installed. 
     - JDK itself contains Java development software and JRE 
     - In windows and Mac OS, installing the JDK in previous releases optionally installed JRE, this is no longer an option. Because Java is gradually moving towards Modularization we can create modules using JLink and we can reduces the size of software and ship that software to client  
     - Mainly JRE is install in client machine and top of that Java software is installed. Using JLink we can create small packages and u can ship that one 
     - Using JPackage also we can create exe files for windows so that the software can simply install in client machine. We can make exe file from jar file and install that jar into our client machine without any JRE

    1. Upto Java10 version, we need to compile and execute the java program. From Java11 version onwards we can execute java file directly without compiling 
   > java Test.java
  Whenever we give "java Test.java" internally first compilation perform then execution will take place, so in case any compilation failed it will show error also, which is some what similar to python execution like "python Test.py"

   2. In single java program, when we provide more than one class with main method, then JVM will search for main() in the order in which we provided from top to bottom, in which class JVM identifies main() first time then JVM will treat that class as the actual main class and JVM will execute that main class

Test.java
class C { PSVM  {
   SOP("C-Main");
}}
class A { PSVM  {
   SOP("A-Main");
}}
class B { PSVM  {
   SOP("B-Main");
}}
>java Test.java
Output: C-Main

No class file will be generated, it means which class is loaded and the respective other class are compiled but not loaded in memory
   Java11 provide backward compatibility (ie) here also we can compile and execute as previous version also 

Rules:
  1. We not have .class file for this Java file inside the folder
public class Test {
   PSVM {
      SOP("Hello world");
   }
}
>java Test.java
>java -verbose Test.java
     To check complete functionality of JVM, first it will load all classes into JVM and then at last we can see our class. JVM background uses compiler to do check

  2. If main() is not present in java file it will throw error
public class Test {
   
}
>java Test.java

  If in this folder we have .class file and if we run java Test.java then it will show error, so in Java11 we need only java file should be present
   This feature provide slow execution since both compilation and execution got combined so it is not used in production env, only for beginners or new learners we can use this. 

  3. We must place main method in first class in Java, because Java11 executes from top to bottom, so main class should be first class otherwise it will show compiler error
class Test { PSVM {
   SOP("Test-Main");
}}
public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
class B {
    static void m2() {  SOP("m2"); }
}
>java Test.java
Test-Main

  4. No need to be class name and java file name to be same, even if it is public. So u can create filename any and class name any. Because java command not verifying the class and java file same or not. We given this java file going into the file and check first class contain main method or not, if it is available it will execute 

class C{ PSVM {
   SOP("C-Main");
}}
public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
class B {
    static void m2() {  SOP("m2"); }
}
>java Test.java
C-Main

  5. Even if we have multiple main method in call, no problem JVM will execute the first main method 

class C { PSVM {
   SOP("C-Main");
   A.m1();
   B.m2();
   A.main(new String[0]);
}}
public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
class B {
    static void m2() {  SOP("m2"); }
}

>java Test.java
C-Main
m1
m2
A Main

  6. Even in single program, we have multiple classes to be public
  7. In single java program, we have multiple classes but when we run it will execute only main class, other classes will not load into JVM until u call those classes, to check that
    > java -verbose Test.java
Now we can it will load only C class into JVM
[class,load] C source: __JVM Defines___
  In case, if we call A.m1() inside main(), then if we check u can see C as well as A classes will be loaded in JVM 
   In source file, we can define multiple classes then first class should contain main() to launch the class, then when u running this java file we can have multiple classes compiler will compile all classes if no mistake are there it will generate the byte code and give to JVM. JVM making all this classes store in buffer, it is not loading in memory and storing somewhere in buffer. So whichever class we are accessing that class from buffer is loading in JVM 
   Previously the buffer is nothing but .class file that it is in harddisk, whenever we access the class that time class loading from harddisk to JVM and executed. But harddisk cannot be used thats why it uses internal RAM level buffer it uses, so RAM level buffer stores all this classes bytecode whenever we access methods from the class then at that time it load class to JVM.

    8. Now we copy class A separately into another java file
Test.java
class C { PSVM {
   SOP("C-Main");
   A.m1();
   B.m2();
   A.main(new String[0]);
}}
class B {
    static void m2() {  SOP("m2"); }
}  

A.java

public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}

>java Test.java
    - It will show error

But we can access other program if it has a class file 
>javac A.java
   - It creates A.class
Now we can execute 
>java Test.java
    It will execute main class, but when we try to access A.m1() it will show an IllegalAccessError. So if u want to access any class outside means it should be present in a package   

package p1;
public class A {
   public static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
>javac -d . A.java

Test.java
class C { PSVM {
   SOP("C-Main");
   p1.A.m1();
   B.m2();
   A.main(new String[0]);
}}
class B {
    static void m2() {  SOP("m2"); }
}  

>java Test.java
C main
A m1
B m2

We cannot access another java file classes, but we can access the classes which are already compiled and has .class with package 

CommandLine argument
>java Test.java 10 20 30

2. No language translations for Java release - From JDK11 onwards java releases available only in english

3. Updated packaging format for Windows has changed from .tar.gz to .zip and for MacOS it is changed from .app to .dmg

4. JavaFx, Java Mission Control(JMC) is shipped separately
     - Previously these where part of JDK itself, JavaFx is updates related to flash works, java effects api 

5. Deployment stack for applets, webstart apps deprecated in Java9 and now it is remove from Java 11

2. Launch single file programs without compilation 
       - When new developer want to start developing a program, he have study so many thing how to compile and execute the program
       - Here developer can write simple file and execute that single file without compiling (ie) without generating .class file we can execute the program
        >java sample.java
Without giving .class file we can run our file. Here java interpreter enhanced to take the responsbility of compilation without generating .class file. So internally maintaining some stack so directly running java file and give the output 

3. java.util.Collection - toArray(intFunction)

ArrayList<String> list=new ArrayList<>();
list.add("one");
list.add("two");

list.stream().toArray(s->new String[s]); //old version

String a[]=list.toArray(size->new String[size]);
SOP(Arrays.toString(arr));

Previously we have to create stream object and pass but now we can dynamically pass some lambda expr and generate the array 

String a[]=list.toArray(String[]::new); //using method refernece
SOP(Arrays.toString(arr));

4. Local Variable syntax for Lambda parameters
      -You either define the type var on all the parameters or none

interface Example {
    int operation(int a,int b);
}

Example e=(int a,int b) -> a+b;
Example e=(var a,var b) -> a+b;

(var a,var b) -> a+b;  //correct
(var a,b) -> a+b; //wrong
(a,var b) -> a+b; //wrong
(var a,String b)-> a+b; //wrong
var a -> a; //wrong,we have to use the parenthesis

5. String API changes
      - certain enhancement in String API
isBlank() - check whether string is blank or not
lines() - based on \n extract list of strings. From multi line string if we want to extract substring of each line
strip() - removes leading and trailing spaces
stripLeading()
stripTrailing()
   In general both method removes leading and trailing spaces from string. However the difference comes when we work with unicode charaters or multilingual features.New method strip which is added in java 11 usage this Character.isWhitespace(int) method to cover wide range of white space characters and remove them.

repeat() - repeat string for particular times

Example2: 

String a=" Welcome ";
SOP(a.isBlank()); //false
String a1="    ";
SOP(a.isBlank()); //true since it emply spaces

String b= "one \n"
         + "two \n"
         + "three \n";
a.lines().forEach(System.out::println);

String c="welcome"
SOP(c.repeat(5)); //welcome will repeat 5 times


SOP(" ".isBlank()); //true
SOP(" L R ".strip().replace(" ","@")); //L@R
SOP(" L R ".stripLeadig().replace(" ","@")); //L@R@
SOP(" L R ".stripTrailing().replace(" ","@")); //@L@R
"Line1\nLine2\nLine3\nLine4".lines().forEach(System.out::println);

String string = '\u2001'+"String    with    space"+ '\u2001';
   System.out.println("Before: \"" + string+"\"");
   System.out.println("After trim: \"" + string.trim()+"\"");
   System.out.println("After strip: \"" + string.strip()+"\"");
   }
}

//take specific set of string and transform it
SOP("UPPER".transform(s->s.substring(2))); //PER

//takes string and format it
SOP("My name is %s. My age is %d.".formatted("Ram",24));

//additional info for NullPointerException
String str=null;
System.out.println(str.isBlank()); //In Java14 it gives additional info about the NPE 

Example2:
public class Sample { PSVM {
  String name="";
  sop(name.isEmpty()); //true
  String name1=" ";
  sop(name1.isEmpty()); //false
  String name2=" ";
  sop(name2.isBlank()); //true
  String name3="";
  sop(name3.isBlank());  //true

  String name4="One\nTwo";
  List<String> l=name4.lines().collect(Collectors.toList());
  sop(l);  //[one,two]

  String s="test string\u205F";
  String s1=s.strip();
  sop(s1+"*****");
  String t1=s.trim();
  sop(t1+"*****");

  String n5=" Ram Kumar ";
  sop(n5.strip()); 
  String n6=" Ram Kumar ";
  sop(n6.stripLeading()); 
  String n7=" Ram Kumar ";
  sop(n7.stripTrailing()); 
  sop(n7.repeat(4));

6. Optional.isEmpty()
       - to check whether optional class is empty or not
       - If we want to do something if value is absent, in that case we use negation. It wont make it very readable. Normally ifPresent() gives value if value is present so for negation purpose we use !ifPresent() so for that we can use isEmpty()

 
Optional o=Optional.of("hello");
o=o.empty();
o.ifPresent(s->System.out.println(s));
SOP(o.isEmpty());  //true

7. Files read string and write string
     - When we write something to text files or read from file, we use BufferedReader, BufferedWriter, FileWriter etc. From Java11 onwards oracle introduce few methods which made easy to write few context and read from text file 
     - read and write string data from files - writeString(), readString(), isSameFile()-compare the contents of 2 file

Program 1:
var uri="C:\\data.txt";
try{
  Files.writeString(Path.of(uri),"hello",StandardOpenOption.APPEND);

  String data=Files.readString(Path.of(uri));
  System.out.println(data);
}
catch(IOException e){
    e.printStackTrace();
}

Now the data will be appended into file and prints the data

Program 2:
1. Create sample.txt inside resources folder
Sample
Line 2
Line 3
2. Now we read the content from file and write to another file

Path path=Paths.get("./resources/sample.txt");
String f=Files.readString(path);
System.out.println(f);
String n=f.replace("Line","Lines");
Path n1=Paths.get("./resources/sample1.txt");
Files.writeString(n1,n);

8. HTTP Client API
       - used to give post, get and delete request 
       - Alternate to HttpURLConnection,  we are using HttpURLConnection to deal with http connection, to read and perform operation on HTTP protocol. Now we use HTTP Client API to do all this things 
       - The advantage is it can perform sync and async operations and can handle multiple urls at same time on Http 1 as well as Http2

String uri="https://postman-echo.com/get?uname=java&pwd=121";
HttpRequest req=HttpRequest.newBuilder().uri(URI.create(uri)).GET().version(Version.HTTP_2).build();

HttpClient client=HttpClient.newBuilder().build();
try{
  HttpResponse<String> res=client.send(req,BodyHandlers.ofString());
   SOP(resp.statusCode());
   SOP(resp.body());
}
catch(IOException | InterruptedException e) {
   e.printStackTrace();
}

Example 2: synchronous get request 
public class Sample { 
//create http client with http version 1.1
private static final HttpClient httpClient=HttpClient.newBuilder()
          .version(HttpClient.Version.HTTP_1_1)
          .connectTimeout(Duration.ofSeconds(10))
          .build();

     PSVM() throws Exception {
   //Synchronous get request 
   HttpRequest req=HttpRequest.newBuilder()
                   .GET()
                   .uri(URI.create("https://httpbin.org/get"))
                   .setHeader("User-Agent","Java 11 HttpClient")
                   .build();

//using httpclient send the request 
HttpResponse<String> res=httpClient.send(req,HttpResponse.BodyHandlers.ofString());

HttpHeaders headers=res.headers();
headers.map().forEach((k,v)->System.out.println(k +":"+v));
   System.out.println(res.statusCode());
   System.out.println(res.body());

}
}

Example 3: For Asynchrounous GET request 
public class Sample { 
//create http client with http version 2
private static final HttpClient httpClient=HttpClient.newBuilder()
          .version(HttpClient.Version.HTTP_2)
          .connectTimeout(Duration.ofSeconds(10))
          .build();

     PSVM() throws Exception {
   //Synchronous get request 
   HttpRequest req=HttpRequest.newBuilder()
                   .GET()
                   .uri(URI.create("https://httpbin.org/get"))
                   .setHeader("User-Agent","Java 11 HttpClient")
                   .build();

CompletableFuture<HttpResponse<String>> res=httpClient.sendAsync(req,HttpResponse.BodyHandlers.ofString());

String result=res.thenApply(HttpResponse::body).get(5, TimeUnit.SECONDS);
System.out.println(result);
}
}

Example 4: we can send multiple request at same time

public class Sample {
   private static final ExecutorService exe=Executors.newFixedThreadPool(3);

private static final HttpClient httpClient=HttpClient.newBuilder()
          .executor(exe)
          .version(HttpClient.Version.HTTP_2)
          .connectTimeout(Duration.ofSeconds(10))
          .build();
PSVM() throws Exception  {
   List<URI> targets = Arrays.asList(
       new URI("https://httpbin.org/get?name=ram"),
       new URI("https://httpbin.org/get?name=kumar"),
       new URI("https://httpbin.org/get?name=sam"));

List<CompletableFuture<String>> res=target.stream().
       map(url->httpClient.sendAsync(
           HttpRequest.newBuilder(url)
             .GET()
             .setHeader("User-Agent","Java HttpClient")
             .build(),
         HttpResponse.BodyHandlers.ofString())
        .thenApply(HttpResponse::body))
        .collect(Collectors.toList());

for(CompletableFuture<String> f:res) {
     sop(f.join());
  {
}
}

9. Predicate.not
      - Returns a predicate that is the negation of the supplier predicate 

public class Sample {
    public static boolean isEven(Integer number) {
         return number%2==0;
    }
    public static void main(String[] a){
        List<Integer> l=List.of(3,4,5,67,89,88);
    //Predicate<Integer> p1=n->n%2==0;
    //l.stream().filter(p1).forEach(System.out::println);  //4, 88
    //l.stream().filter(p1.negate()).forEach(System.out::println);  //3,5,67,89

   l.stream().filter(Predicate.not(Sample::isEven)).forEach(System.out::println); //4 88


10. Nested based access control
       - This is the feature 

Example 1:

public class Main {
    static class Blog {
         private String name;
    }
    PSVM {
      Blog b=new Blog();
      Field bName=Blog.class.getDeclaredField("name");
      bName.set(b,"hello world");
      SOP(b.name);
   }
}

Example 2:

public class Test {
     private static int x=5;
     public static class NestedTest {
         public static void doSomething() {
             System.out.println(x);
         }
     }
}

>javac Test.java
>javap -v Test.class

Before Java11 we we compile such type of file,here we can see extra method will be added for nested class called static int access$000(). This is the private bridge created between two classes, when we compile a class which contains another class so for that 2 class file will be created, one for outer and one for inner, so there should be some bridge between the outer class can access the method of another .class file 

>javap -v Test$NestedTest.class

Here we can see when we invoke doSomething(), it have provide like Test.access$000(), stating the outerclass can access this method by specifying the bridge between  both of the classes

But from Java11 onwards another access control is introduced which is "nest" and in nest we have nestHost and nestMembers. Basically outer class is nest host and inner classes are nest members or nest mate of that class
  When we compile the code in Java11 and see
>javac Test.java
>javap -v Test.class
    Here we have static int access$000() which will act as bridge between outer and inner class so that we can access private members of the outer class. So in Java11 onwards we have nesthost and nestmembers, so the outer class contains nest members as "Test$NestedTest.class"
    When we try to access inner class
>javap -v Test$NestedTest.class
    Here we can see nest host as "class Test" which is outer class 

So basically in this feature there is no impact on development or enduser but just enhancement on JVM level. 

Basically, the nest term defines a new access control context that allows classes that are logically part of the same code entity, but which are compiled with distinct class files, to access each others private members without the need for compilers to insert accessibiltity bridge methods
   Earlier version to access private members of class we need to specify the brigding method, but from java11 onwards no need to specify in compiled class instead we need to mention nesthost and nest members


11. TimeUnit Conversion
       - used to convert DAY, HOURS, MINUTES 

TimeUnit c=TimeUnit.DAYS;
c.convert(Duration.ofHours(24));
Output: 1 //convert 24hrs to day

TimeUnit c1=TimeUnit.MINUTES;
c1.convert(Duration.ofHours(60));
Output: 3600

13. Pattern recognizing method
      - used to generate the pattern and test against the string 

asMatchPredicate() - will create a predicate if pattern matches with input string 



14. Java Flight Recorder
       - Used tool for running Java appl and capturing diagnostic for further analysis. So when ur appl crashes or not perform as expected, u can monitor or troubleshoot it using the data collected by flight recorder
       - It is used for black box analysis as it continuously save state data into circular buffer and this information can be accessed when a problem is detected. You can use JFR for unexpected events.
       - For example if we get OutOfMemoryError in ur code or VM crashes, we can get all details and root causes with help of JFR

Introduction to Flight Recorder
   1. JFR provides best possible visibility into the JVM since it is build into JVM itself
   2. JFR has low performance overhead when used in heavily loaded production appl. We have overhead when we have profilers because profilers are attached to JVM and they consume heaps and create their own threads. When we use in production system u should carefully choose which event u should use with profiling
   3. It is event based profiling engine, when we say event that could be garbage collection or CPU load increase by threshold value or heap space consume more than 90%. JFR collects data from more than 500 events and we can create custom events also 
   4. JFR has binary recordings and we cant open and look into them. Events are written in binary formats, all the recordings are .jfr extension 
   5. We have Java API also to load and read data through Java code, you can trigger events through Java API calls. Java API is introduced in Java9 in jdfk.jfr package 

Events
   - Event occurs in JVM at specific point in time. Each event has name, timestamp and optional payload(the data associated with event)
   - For eg, CPU usage or Java heap size before and after the event or thread id 

3 types of events
   1. Duration events
   2. Instant events
   3. Sample events

Removed Features
1. Removal of com.sun.awt.AWTUtilities class
2. Removal of appletviewer launcher
3. Removal of Thread.destroy() and Thread.stop() methods
4. Removal of JVM-Managemebt-MIB.mib
5. Removal of Java Deployment Technologies like Java plugins, Java webstart, JRE 
6. Removal of JAVA FX from Oracle JDK
7. Remove JavaEE and CORBA Modules

Migration to Java 11
1. Eclipse : Photon 4.9RC2 with Java 11 plugin
Maven :3.5.0
Compiler plugin: 3.8.0
surefire and failsafe:2.22.0



Java 12 features
1. Compact Number Format 
     - Compact number formatting refers to the representation of a number in a short or human readable form
     - For eg, 1000 can be represent as 1k, 100000 can be represent as 1L, depending on the style specified by NumberFormat.Style
     - The compact number formats are defined by LDML(Local Data Markup Language) specification
     - NumberFormat adds suppory for formatting a number in its compact form

NumberFormat fmt=NumberFormat.getCompactNumberInstance(Locale.US,Style.SHORT);
String s=fmt.format(1000);
SOP(s); //output: 1K

String s1=fmt.format(100000000);
SOP(s1); //output: 100M

String s=fmt.format(100000000000000L);
SOP(s); //output: 1OOT

String s=fmt.format(9999);
SOP(s); //output: 10K - will display the nearest value 

2.  Switch Expression
       - new form of switch statement, normally we cant return value directly from switch stmt, instead we can go for switch expr
       - Syntax:  label -> logic
       - break is not required here
       - If we want to return multiple value we can use yeild keyword
   
class Sample {  PSVM {
   String msg=perOfDailyTask("SATURDAY");
   System.out.println(msg);
}

public static String perOfDailyTask(String day) {
     String msg=null;
     msg= switch(day) {
        case "MONDAY" -> {
                      System.out.println("hii");
                      yield "A";
                      }
        case "TUESDAY" -> "B";
        case "WEDNESDAY" -> "C";
        case "THURSDAY" -> "D";
        case "FRIDAY" -> "E";
        case "SATURDAY" -> "F";
        default -> "wrong input";
        };
    return msg;
}
}
Output: F

We can have multiple case in single line 

public static String perOfDailyTask(String day) {
     String msg=null;
     msg= switch(day) {
        case "MONDAY" -> {
                      System.out.println("hii");
                      yield "A";
                      }
        case "TUESDAY","WEDNESDAY","THURSDAY" -> "B";
        case "FRIDAY" -> "E";
        case "SATURDAY" -> "F";
        default -> "wrong input";
        };
    return msg;
}


Java 13 features - https://github.com/greenlearner01/Java13/tree/master/CommandLine

1. Text Blocks
       - A text block is a multi line literal. Avoids the need for most escape sequences automatically formats the string in a predictable way 

String email="hello welcome,\n"
             + " to java \"bean\"....\n"
             + "welcome\n"
             + "hello world\n";

email="""
        hello welcome,
        to Java "bean"....
        welcome
        hello world
      """;

   String s="""
       Line 1: %s
       Line 2: %s
       Line 3
       Line 4
       """.formatted("Some value","Some other value");
   SOP(s);

  - u cannot have text block in single line
      String s="""abcejjdjd"""; 

2. Z Garbage Collector Enhancement in JKD13
      - It is about returning unused memory to the os
      - It is introduced in Java11, to enhance the performance of the application by returing the unused memory to the OS and efficiently clearing the garbage 
      - Z Garbage collector is low latency garbage collector (ie) it takes more time  
      - ZGC performs all expensive works concurrently, without stopping the execution of appl threads for more than 10ms, so 10ms is threshold or max time 

Java 14 features

https://programmingtechie.com/2020/03/20/java-14-new-features/

1. Helpful NullPointerException 
     - Whenever we write big code in java, and when this code throws NullPointerException, it can become difficlt to know from where the exception originates.
     - Gives developers control over the format when desired
     - Aims to improve the readability of NullPointerExceptions, generated by JVM, by describing which variable is null
     - By providing -XX:+ShowCodeDetailsInExceptionMessages in VM Options 

2. Pattern matching for instanceOf
      - instanceOf operator is enhanced to support pattern matching 
      - Normally when u dealing with type Object which is from java.lang package, we will cast it to our required type by checking its type using instanceof keyword, then we will cast object to our required type, then will cast the object 
      - But will pattern matching feature we dont need to cast the object explicitly, we have to provide corresponding variable along with type to instance object and the variable will bound to casted value 

Object obj="hello";

//lower version
if(obj instanceOf String) {
    String str=(String)obj;
    System.out.println(str.toUpperCase());
}

//latest version
if(obj instanceOf String str) {
    System.out.println(str.toUpperCase());
}

3. Records 
     - Eliminate verbosity in creating Java Beans - public accessor methods, constructor, equals, hashcode, toString are automatically created 
     - Records improves developer productivity by providing a compact syntax for declaring classes which act as transparent carriers for immutable data 
     - new class called record, it is final class not abstract and all of its field are final
     - The record will automatically generate the tedious constructors, getter methods, equals, hashCode, toString during compile time. No setter methods for record class 
     - So whenever we create immutable class we have to provide constructors, getter methods, equals, hashCode, toString, instead we can use record class for creating immutable class 

public class RecordDemo {
  record UserRecord(String firstName, String lastName, int userId){ }
  public static void main(String[] args){
     UserRecord u=new UserRecord("ram","kumar",1234);
     UserRecord u1=new UserRecord("ram","kumar",1234);
     System.out.println(u.firstName()); //ram
     System.out.println(u.equals(u1)); //true
  }
}

Internally if we decompile java class, compiler will provide methods related to fields provided 
   - We cant set the data as all fields are final. Inside  record we cant create instance variable but we can create static variable 

   - Compact constructors are only allowed in Records

public class Sample {
    record Person(String name, String email,String phone) {
         int number; //error instance variable
         static int num;
     Person {
         if(name==null) {
             throw new IllegalArgumentException("Name is null");
     }

     //instance method error
     /* public String name() {
                return "hello";
       } */
}
PSVM {
    Person p1=new Person("Ram","ram@gmail.com","34444");
    System.out.println(p1.name());
 }
}

  - You can add static fields, static initializer and static methods. But you cannot add instance variable.

4. Packaging tool
     - Creates Platform specific installers out of jar files, so we know installing java on machine is prerequiste whenever we want to run any java appl
     - With help of JPackage, no need to install Java on client machine to run any Java appl
     - JPackage tool to package java appl into a platform specific package 
     - To execute any software we need any exe file and exe file will be executed in windows. In Java we have java and class files and we package into jar file and those jar file will be executed only in Java env.
     - Any client who dont have java software cannot execute those jar files 
     - Now java came with new packaging tool called JPackage so that we can convert our jar files into env specific. For MacOS, we can convert jar file into pkg and dmg file so that it can install in client machine. In windows we can convert jar file into msi or exe file and in linux as deb and rpm file 

1. Create java project with simple java program
2. Create executable jar file
   src>jar -cfe Sample.jar com.pack.Sample com/pack/*.class
3. copy the jar file inside another folder and in that we create exe file
3. Install Wix(Windows Installer XML tool) 3.0 from wixtoolset.org wix311-binaries
set wix311-binaries path in env variable
4. Use JPackage tool 
newfolder>jpackage --input . --name SampleApp --main-jar Sample.jar --main-class com.pack.Sample --type exe --java-options '--enable-preview' --win-shortcut
5. Install into exe and check how it is working


5. Text blocks 
   - Which is released as preview feature for 2nd time, it was originally introduced in Java 13
   - With text blocks we can use multi line string in java without using string concatention
   - When u want to store any HTML, JS and SQL code inside string in Java,we want to manually use string concatentation to construct them. With Text blocks we can just multiline string with """ and indentation of string is preseved by Java
   - Change in Java14 is we can add trailing (\) in one of line inside multi line string which tells the Java compiler to ignore the next coming line break

public class Sample { PSVM  {
   String html="<html>\n" +
               "  <body>\n" +
               "    <p>Hello world</p>\n"+
               "  </body>\n" +
               "</html>";
   String java13="""
                <html>
                   <body>
                      <p>Hello world</p>
                   </body>
                </html>""";
   String java14="""
                  <html>
                   <body>\
                      <p>Hello world</p>\
                   </body>
                </html>""";
System.out.println("Before Java 13");
System.out.println(html);
System.out.println("From Java 13");
System.out.println(java13);
System.out.println("From Java 14");
System.out.println(java14);
}}

Output:
Before Java 13
 <html>
    <body>
       <p>Hello world</p>
    </body>
 </html>

From Java 13
 <html>
    <body>
       <p>Hello world</p>
    </body>
 </html>

From Java 14
 <html>
    <body> <p>Hello world</p> </body>
 </html>


6. General JVM Improvements

1. G1 Garbage collector Improvements
       - Default garbage collector in Java which was introduced in Java9 
       - In Java14, this GC has been made NUMA aware(Non uniform memory access)
       - Goal is to improve performance of GC over lareg machines
       - Can be enabled by -XX+UseNUMA flag

2. Z Garbage Collector
      - Introduced in Java11 and in Java14, the pause time of GC is reduced to under 10ms. This was originally available only for Linux but with Java14 their ports avialable for Mac and windows 

3. CMS(Concurrent Mark Sweep) GC completely removed from Java14 




Java Mission Control 
https://github.com/cameronmcnz/Java-Mission-Control-Tutorial/tree/main/projects

1. Mission Control Plugin in Eclipse
       - If ur in eclipse, only plugin u can install is version 6 which is oracles which requires a commercial license. So we use open source AdoptOpenJDK plugin installed so u dont need that commercial license at all.
     In Eclipse Market Place, we can search Java Mission Control, but it is license version. So we get the latest version of JMC which build it from OpenJDK. 

1. Goto https://github.com/openjdk/jmc and try to clone to the jmc repo inside a folder
2. folder> git clone https://github.com/openjdk/jmc.git
    It created a folder jmc
3. Goto jmc/releng/third-party folder, where we can see bunch of third party lib that u need to build in order to get Java Mission Control and Java Flight Recorder plugin working
    Open gitbash inside third-party folder 
thirdparty>mvn p2:site
   - Which will set up whole website that going to host a maven repo with all these third party libraries.
    
4. After build success, Now hosts this site on jetty 
thirdparty>mvn jetty:run
This is all configured to host maven repo on localhost:8080 which is going to give the core build of JMC JFR eclipse plug-in access to the 3rd party libraries that it needs
    Let the prompt runs on Jetty server

5. Now go to jmc/core folder and open gitbash and need to build again
jmc/core> mvn clean install
    - compiles the code, run some test and then package all of the core stuff into appropriate jar file 

6. Now in same gitbash go to jmc folder
jmc/core>cd..
jmc> mvn package
    - So everything build in previous maven install will package it up into various jar files, one of jar file is java flight recorder maven plugin 

7. Once build sucess, under jmc folder we can see the folder called application.
  Inside that goto org.openjdk.jmc.updatesite.ide/target/ we can see the plugin for Java flight recorder
  org.openjdk.jmc.updatesite.ide-8.0.0.SNAPSHOT.zip

8. Now we need to install that plugin in Eclipse

Goto Eclipse - Help - Install New Software - Click Add - Click Archive - select the zip file from jmc/application/org.openjdk.jmc.updatesite.ide/target/  folder
  - Click Add - Select all checkboxes 
  - Click Next - Accept the agreement - Click Finish 
  - Restart eclipse ide

9. In eclipse we can see Java Mission Control icon in top
Under Local - Select Jetty server running - Start Flight Recording - click Finish 

localhost:8080/site/ - to see all available server running 

Which open Flight recording in that we can select memory, garbage collection , Threads(all class loading the thread that were in use and were blocked the memory the file socket, io etc)

2. Java Mission Control Overview
     We going to download it and install it and show you how to connect to an existing JVM and then do a Java Flight Recorder and take a look at some of the memory used and some of the cpu usage 
    To work with JMC u have to download it, it dosent come packaged with JDK anymore. 

1. Goto https://adoptopenjdk.net/jmc.html and download 
org.openjdk.jmc-8.0.0-win32.win32.x86_64.zip
    Extract it - Inside client jmc.exe file to start JMC
   Once started,it will load all the JVM's which is running on my local system, one of which is Jetty server which is already running.
   Under JVM browsing Tab we can see jvms running on the machine, under that we select Jetty server, under that we can see MBean Server and Flight Recorder
   Mbean server gives feedback on how your jvm is running right now, we got jetty server as we already running jetty server 
   Now if we refresh localhost:8080/site/, we can see needle moving as increase in memory 

2. Now we do flight recording
Right click Flight Recorder - Start Flight Recording - Finish 
    It gathers bunch of info about this jvm hosting, when u click refresh on jetty server we can see some sort of load and number of megs being used is increasing. This is MBean server this is giving us some live feedback on howour jvm is behaving. We will get JMC report once flight recorder is completed
   This will show information about the threads, memory, garbage collection all sorts of info about just what happened during that run. You can see little bit of cpu peaking  


3 ways to Start Java Flight Recorder in Eclipse

First way:
1. Configure DoSomething project in eclipse
2. Right click project - Run as Java application
3. Goto JVM Browser tab - Right click Flight Recorder - Start Flight Recording 
   Recording Time: 10s - Click Finish
4. Once recording is compelted, it show the result in JMC which provide info abt memory, abt thread and in Automated Analyse Result it show the completed result 
   Under Environment - Click ^ - we can see the number of completing resources running on my computer  

Second way:
1. In the same project we can provide Launchers, in that we use DoNothing Auto Record.launch, in this launcher we set some JVM arguments like flight recorder arguments
    We specify that the recordings starts after 5sec delay and 20s duration and the file would be saved in DoNothing folder 
2. Run as Java Application - Select Launcher - click ok
    It will start the recording for 20s duration, once complete, u just refresh the project 
    You can see the recording file, just double click it will open automated analysis of that appl with threads, memory and with feedback 

Third way:
1. Right click project - Run as Java application
2. Goto package of DoSomething.java - Right click package - show in local terminal 
  > jcmd 
which displays process id of that appl

>jcmd 1886 JFR.start duration=10s filename=recording.jfr 

It will take 10s to create the recording. Once done, just refresh the project, u can see the recording. Just double click the recording which generates the flight recording of the application.

LinkedList vs HashSet Performance Problem in JMC 
    - Here we see difference between LinkedList and HashSet when we have large number of elements in Java Collection. Now we see difference in performance between a linked list versus HashSet by using example

http://missioncontrol.mcnz.com/2020/12/10/Java_LinkedList_vs_HashSet_Performance.html

public class HotJavaMethodRunner implements Runnable {
	
	private static final int NUMBER_OF_THREADS = 8;

	public static void main(String[] args) throws Exception {
		ThreadGroup threadGroup = new ThreadGroup("Workers");
		Thread[] threads = new Thread[NUMBER_OF_THREADS];
		for (int i = 0; i < threads.length; i++) {
			threads[i] = new Thread(threadGroup, new HotJavaMethodRunner(), "Worker Thread " + i);
			threads[i].setDaemon(true);
			threads[i].start();
		}
		System.out.print("Press enter to quit!");
		System.out.flush();
		System.in.read();
	}
	
	public void run() {
		while (true) {
			WorkEvent event = new WorkEvent();
			Collection<Integer> firstBunch = new LinkedList<>();
			Collection<Integer> secondBunch = new LinkedList<>();
			
			//Collection<Integer> firstBunch = new HashSet<>();
			//Collection<Integer> secondBunch = new HashSet<>();
			
			event.begin();
			
			initialize(firstBunch, 3);
			initialize(secondBunch, 2);
			int intersectionSize = countMatches(firstBunch, secondBunch);
			
			event.setIntersectionSize(intersectionSize);
			event.commit();
			Thread.yield();
		}
	}
	
	public void initialize(Collection<Integer> collection, int modulus) {
		collection.clear();
		for (int i = 1; i < 100000; i++) {
			if ((i % modulus) != 0)
				collection.add(i);
		}
	}
	
	public int countMatches(Collection<Integer> first, Collection<Integer> second) {
		int count = 0;
		for (Integer i : first) {
			if (second.contains(i)) {
				count++;
			}
		}
		System.out.println(count);
		return count;
	}
	
}


1. In the above example we create 2 collection firstBunch and secondBunch which contains collection of Integers. FirstBunch is numbers from 1 to 100000 and mod by 3 and secondbunch is between 1 to 100000 and mod by 2 using initialize() method
   Once we got those two collection of numbers that are linkedlist initialized,we want to find the intersection (ie) how many numbers are same between first list and second list using countMatches()
    This example causes lot of computation and we are going to run this with JFR and take a look at how cpu and memory behaves. This kicks off 8 threads in my example and every time a thread kicks off we create a new work event 

import jdk.jfr.*;

@Label("Work")
@Category("02_JFR_HotMethods")
@Description("Data from one loop run in the worker thread")
public class WorkEvent extends jdk.jfr.Event {
	@Label("Intersection Size")
	@Description("The number of values that were the same in the two collections")
	private int intersectionSize;

	public int getIntersectionSize() {
		return intersectionSize;
	}

	public void setIntersectionSize(int intersectionSize) {
		this.intersectionSize = intersectionSize;
	}
}


We created a work called "Work", we started at the beginning of run() as event.begin() and we terminate at the end, this will keep track of how long it takes to actually run all of these  methods

2. Run the main class, we have Launcher confgiured here which will automatically run JFR and we made recording to save inside Recording folder, just refresh u can see  the recording 
  You click the recording and u can see it displays 

3. Instead of LinkedList we use HashSet. In linkedlist the larger the list is more difficult it is to process and bigger the performance implication. Hashset tends to have linear performace
Collection<Integer> firstBunch = new HashSet<>();
Collection<Integer> secondBunch = new HashSet<>();

4. Run the application, now u can see it was taking very less time to process compare to LinkedList 
   Now look at flight recorder in Recording folder, now it says high CPU load because my threads are running so quickly 





Soap UI
   - It is open source tool to perform any kind of API testing related to SOAP request as well as RETS request 
   - SOAP is used by large cooperation like Apple, Microsoft, Cisco, Oracle, HP, NASA, ebay, MasterCard, Intel, FedEx etc, so SOAP is basically made for large enterprise appl
   - It basically provides an easy interface and provides couple of drag and drop operations which will definitely help to create any kind of API, collection of worl with api testing
   - It is preferred for both SOAP and REST api 
   - SOAP Ui is a  heavy full fledged tool providing facility of data driven testing, since it supports programming language like Groovy  where u have more leverage over the tool
   - If u r not starter or u have advance level of knowledge expecially related to apis definitely go with SOAP UI and again totally depend on ur company level

Postman
   - It is not api testing tool, it is api development suite and it provides lot of different features like sharing your collection(set of apis), performing api testing, monitoring, documentation  of apis 
   - Easy for sharing reports, it is not made for large appl, it is considered to be work only with rest apis most of the time, but it will support soap request also in postman 
   - Postman is mostly made for small based companies 

			SoapUI			Postman
1. REST API testing	  yes			   yes
2. Soap API Testing	  yes			   no
3. Scripting lang	Groovy,js           Javascript


SoapUI 

What is SOAPUI?
   - API Testing Tool
   - For manual and automation testing of SOAP and REST APIs
   - Cross-platform tool
   - Built entirely over Java platform
   - uses Swing for GUI

Why to use SoapUI
1. To create quick and efficient API tests
2. To create API functional, performance and security tests
3. To create API Testing automation framework


Downloads and Installation
1. https://www.soapui.org/downloads/latest-release/
   - Download SOAP UI Open scource
2. create empty project
3. Right click project - Click New Rest Service From URI
4. Under URI: http://thomas-bayer.com/sqlrest/CUSTOMER/10
   Click OK
We can see Request Editor and Response editor
5. Click Run (green color icon) - we can see the response on response editor, where we can see response in xml, json and html format 
6. In the down we can see log section 


OCP - 1Z0-819 

To create jar file 
   >jar -cvf myFile.jar

To run Jar file
   >java -cp ".;c:\folder\myFile.jar" Animal(mainclass name)


package packagea;
public class ClassA{

}

package packageb;
import packagea.ClassA;
public class ClassB{
   PSVM(){
     ClassA a;
     System.out.println("Got it");
   }
}

>mkdir classes
   - create classes folder

>javac -d classes packagea/ClassA.java packageb/ClassB.java
   -Move class file to classes folder

To run :
>java -cp classes packageb.ClassB
           or
>java -classpath classes packageb.ClassB
           or
>java --class-path classes packageb.ClassB


Options u need to know for exam while compile:  javac

Option		          Description
1. -cp               Location of classes needed to --classpath compile
--class-path

2. -d <dirname>      Directory to place generated class file

3. -m <modulename>   Module name to compile
--module <name>

4. -p <path>         Location of jars in module prg
--module-path <path>

5. --module-source-path   Specify the location of module source files


Options u need to know for exam while running: java

Option 				Description
1. -cp <classpath>       Location of classes needed to run the program
-classpath <classpath>
--class-path <classpath>

2. -p <path>        Location of Jars in modular prg
--module-path <path>

3. -m <name>        Module name to run
--module <name>

4. -d              Describe the details of a module
--descrobe-module

5.--list-modules   List observable modules without running the program

6.--show-module-resolution      Shows module when running program


Option u need to know for exam for archieving: jar

Option 				Description
1. -c                 Create new JAR file
  --create

2. -v		      Prints details when working with jar
   --verbose

3. -f <filename>           JAR filename
--file <filename>

4. -C <directory>        Directory containing files to be used to create JAR

5. -d               Describe the details of module
--describe-module


Stack - methods, local variable, reference variables
Heap - Object, string pool


We can store char in any datatype

Datatype:

boolean b1=true;  

byte b=1;
b='a';  //97

short s=1;
s='a';
s=b;
b=s;   //error

int i=1;
i='a';
i=b;
i=s;
b=i;  //error
s=i;  //error


8E2 * 0 + 8E1 * 1 + 7E1 * 1
64 * 0 + 8 * 1 + 7 * 1 = 15

Literal and Underscore character
   Add underscore except
  1. at the beginning of literal
  2. end of literal
  3. right before decimal point 
  4. right after decimal point

int million=1_000_000; //1000000
int million=_1000.00;  //error
int million=1000.00_;  //error
int million=1000_.00;  //error
int million=1000._00;  //error
int million=1_00_0.0_0;  //1000.0

Identifier
    - name of variable, method, class, interface, pkg
    - must begin with letter, $ or _
    - Include numbers but not start with them
    - single underscore is not allowed
    - no keyword
    - Method and variable names are written in camelCase with first letter in lowercase
    - Class and interface are written with CamelCase
    - Constant, enum,static, final are capitial case

long l1=1;
l1=2147483648l;
l1='a';

float f=1;
f=2147483648L;  //2.14748365E9
f=3.14f;
f='a';

double d=1;
d=2147483648L;   //2.14748365E9
d=3.14f;
d=3.14;
d='a';

char c='a';
c=1;


Autoboxing - convert primitive to wrapper class
Unboxing - convert wrapper class to primitive

Order of Precedence
POST
PRE
Unary
Multi Div
Add Sub
Shift Relational Equalto Logical Shortcirucit Ternary Assignment

public class Primitive {

    //autoboxing in primitive types is allowed in literals
    long primitive() {
        boolean bo = true; //false

        byte b = (byte) 1;
        b = (short) 1;
        b = 1;//int (-128 to 127)
        b = (int) 1L;
        b = (int) 1.2345f;
        b = (int) 1.245;
        b = 'a'; //97

        short s = (byte) 1;
        s = (short) 1;
        s = 1; //int (-32,768 to 32,767)
        s = (int) 1L;
        s = (int) 1.2345f;
        s = (int) 1.245;
        s = 'a';

        s = b;
//        b = s;

        int i = (byte) 1;
        i = (short) 1;
        i = 1; //(-2,147,483,648 to 2,147,483,647)
        i = (int) 1L;
        i = (int) 1.2345f;
        i = (int) 1.245;
        i = 'a';

        i = b;
        i = s;
//        b = i;
//        s = i;

        long lo = (byte) 1;
        lo = (short) 1;
        lo = 1;
        lo = 2147483648L;
        lo = (long) 3.14f;
        lo = (long) 3.14;
        lo = 'a';

        float f = (byte) 1;
        f = (short) 1;
        f = 1;
        f = 2147483648L;//2.14748365E9
        f = 3.14f;
        f = (float) 3.14;
        f = 'a';

        double d = (byte) 1;
        d = (short) 1;
        d = 1;
        d = 2147483648L;//2.14748365E9
        d = 3.14f;
        d = 3.14; //double
        d = 'a';

        char c = 'a'; //97
        c = (byte) 1;
        c = (short) 1;
        c = 1; //int (0 to 65,535)
        c = (short) 1L;
        c = (short) 3.14f;
        c = (short) 3.14;
        return 1L;
    }

    public Long wrapper() {
        Boolean bo = false; //Autoboxing
        boolean boo = Boolean.valueOf(true); //unboxing

        //Before Java 5.0
        bo = Boolean.valueOf(true);
        bo = Boolean.valueOf("FALSE");

        boo = Boolean.parseBoolean("false");

        Byte b = (byte) 1;
        b = (short) 1;
        b = 1; //int
        b = (byte) 1L;
        b = (short) 1.2345f;
        b = (int) 1.245;
        b = 'a';

        Short s = (byte) 1;
        s = (short) 1;
        s = 1;
        s = (int) 1L;
        s = (int) 1.2345f;
        s = (int) 1.245;
        s = 'a';

        Integer i = 1;
        i = (int) 1L;
        i = (int) 1.2345f;
        i = (int) 1.245;
        i = (int) 'a';

        Long lo = (long) 1;
        lo = 1L;
        lo = (long) 3.14f;
        lo = (long) 3.14;
        lo = (long) 'a';

        Float f = (float) 1;
        f = 3.14f;
        f = (float) 2147483648L;//2.14748365E9
        f = (float) 3.14;
        f = (float)'a';

        Double d = (double)1;
        d = (double) 1L;
        d = (double)3.14f;
        d = 3.14;
        d = (double)'a';

        Character c = 'a';
        c = 1; //int (0 to 65,535)
        c = (int)1;
        c = (byte) 1L;
        c = (short) 3.14f;
        c = (char) 3.14;

        return 1L;
    }
}

boolean monkey = true == 3; //error
boolean ape = false != "Grape";  //error
boolean a = 10.2 == "koko"; //error


String and StringBuilder

https://github.com/mhussainshah1/HandleStrings/blob/master/StringPool.jsh

String Pool - intern pool
    There are 2 parts of memory, stack and heap. Stack is part of memory which loads the method data in form of stack one on the other 
    So first method load in stack is main(), in main() if we initialize any local variable or make any object, then local variable will go to stack and object in heap
    Consider we have 3 string objects like
String name="Fluffy";
String name1="Fluffy";
String name2=new String("Fluffy");

       Stack                                 Heap
      100 - name                                          String Pool
      100 - name1                  Object                 100 - Fluffy
      201 - name2                  201 - 100

100,201 - memory address
   So object reference name  will stay in stack and value will store in heap 
   So whenever we create string without  new keyword it goes in the string pool and string pool is a location in JVM contains reusable literal values and constants for fast memory processing.
       String name="Fluffy";
       String name1="Fluffy";
   So benefit of this if we make another string object and it has same value so instead of creating a new object it goes and check the string pool, if it is there then it provides the memory address to this reference, so both these objects point to same location in the memory 

  String name2=new String("Fluffy");
     So whenever we use a new keyword, compiler creates an new object in the memory for name2 and it first checks the string pool and if that string value is present it  copy the address of that string in that object as value and provide its memory address to the reference variable in the stack.

String name="Fluffy";
String name1="Fluffy";
String name2=new String("Fluffy");
name == name1;  //true
name == name2; //false

But at time of concatentation, consider we have

String  name3="Fluf"+"fy";
String name4="Fluf";
name4 += "fy";

So name3 and name4 will have same string "Fluffy" but one is pointing to String pool and other created the object.
   name3 is determine at the compile time, the complete string is "Fluffy" and stored in string pool as address 100 will be stored (ie) to name.
   But for name4, first time it is Fluf and Fluf goes to string pool, then we added "fy" and store back to name4 which is same like calling concat() which return string, so whenever we call a method so it creates a new object so name4 is not same because name4 created new object rather than going to string pool

String name3="Fluf"+"fy";
String name4="Fluf";
name4 += "fy";
name==name3; //true
name==name4; //false

String x="Hello World";
String y=" Hello World".trim();
x==y; //false
   Because first x will store in string pool and y is called with trim() so it create new object so it refers different object 


String s1="hello world";
String s2=new String("hello world");
s2=s2.intern(); //hello world, because it checks with string pool whether value already present so it copy the address of that value

s1==s2; //true

String s3="rat"+1;  //rat1 stored in string pool
String s4="r"+"a"+"t"+"1"; //rat1 stored in string pool
String s5="r"+"a"+"t"+new String("1"); //rat1 but new object created

s3==s4; //true
s3==s4.intern(); //true
s3==s5; //false
s3==s5.intern(); //true


Local Variable Type Inference - Var
    - It introduced in Java10 and purpose is to infer datatype at compile time. We can only use them in constructor, method and initializer block 
    - var is keyword used as local variable in constructor, method, initializer block, loops. The value of var can change but type cannot change 
    - var will check the value and assign the related datatype

Important notes:
    1. var can't declare without initial value. It is always initialized on same line or statment where it is declared
    2. var can be declared in first like and initialized in next line, because it is compile of two lines however it is 1 statement 
    3. var cannot be initialized with null value without a type 
    4. var is not permitted in multiple variable declartion
    5. var cannot be used to initialize array

public class Main {
    {
        var num = 1.0;
    }
    Main(){
        var name = "Main";
    }
    public static void main(String[] args) {
       var size = 7;

       for (var i = 0; i < 10; i++) {

       }

        for (var arg: args) {

        }

        size = 4;
       //size = "five"; //error we cant change its datatype

        //Can't do
        //1. Same line
//        var question;
/*        question =1;
        var answer;
        if(size == 4){
            answer = 2;
        } else {
            answer =3;
        }*/

        //Note 2
        var silly
                = 1;


        //Note 3
        //var n = null;  //error
        var o = (String) null;    //here we specify type before null

        var n = "my string";
        n = null;

        var m = 4;
        //m = null;  //error

        //Note 4 Compound Declaration
//        var a = 2 , b = 3;
//        int a, var b =3;

        //Note 5 Array
//        var prices = {9.95, 8.86};
    }
}


    6. var cant be used in parameters, return type and fields

public class VarKeyword {
/*    var name = "Hello";
    static var counter =0; //error
    public VarKeyword(var name) {  //error
        this.name = name;
    }
    public var getName() {  //error
        return name;
    }
    public var setName(var name) { //error
        this.name = name;
    }*/
}

    7. var is reserved type name but not reserved word (ie) it can used as an identifier except as a class interface or enum name
public class Var {
    public void var(){
        var var = "var";
    }
    public void Var(){
        Var var = new Var();
    }
}

/*class var{}
interface var{}
enum var{}*/

Important Points

1. Choose a variable name that provides useful information

public class Guideline1 {
    public static void main(String[] args) {
        List<String> result = List.of("hello", "how", "are", "you", "?");

        var stringsList = List.of("hello", "how", "are", "you", "?");

    }
}

2. Minimize the scope of local variable 

3. Consider var when the initializer provides sufficient information, so  here in below example right side provide sufficient information 

public class Guideline3 {
    public static void main(String[] args) throws IOException {
        var outputStream = new ByteArrayOutputStream();
        var reader = Files.newBufferedReader(Path.of(""));
        var list = List.of("a", "b", "c");

    }
}

4. Consider var to split chained or nested expression

 List<String> strings = List.of("hello", "hello", "how", "are", "you", "?");

    public Optional<String> getMaxEntry() {
        return strings.stream()
          .collect(groupingBy(s -> s, counting()))
                .entrySet()
                .stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey);


public class Guideline4 {
    List<String> strings = List.of("hello", "hello", "how", "are", "you", "?");

    public Optional<String> getMaxEntry() {
        var collect = strings.stream()
                .collect(groupingBy(s -> s, counting()));
        var max = collect
                .entrySet()
                .stream()
                .max(Map.Entry.comparingByValue());
        return max
                .map(Map.Entry::getKey);


    }
}

5. Do not worry too much programming to the interface with local variable 

public class Guideline5 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list = new CopyOnWriteArrayList<>();
        list = new LinkedList<>();

        var list1 = new ArrayList<>();
//        list1 = new CopyOnWriteArrayList<>();
//        list1 = new LinkedList<>();
    }
}

6. Take care using var with diamond or generic methods 

public class Guideline6 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        var list1 = new ArrayList<>();//since we didnt give it ArrayList<Object>()
        var list2 = new ArrayList<String>();

        var list3 = new ArrayList<>(list);//since we pass list which is ArrayList<String>(), so list3 is ArrayList<String>()
    }
}

7.Take care var with literals 

public class Guideline7 {
    public static void main(String[] args) {
        //No issue with Boolean, character, long, String and Floating Point
        var ready = true;//boolean
        var ch = '\ufffd';//char
        var sum = 0L;//long
        var label = "wombat";//String
        var f1 = 1.0f;//float
        var d1 = 3.0;//double

        //Whole number inferred as integer
        byte flags = 0;
        short mask = 0x7fff;
        long base = 17;

        var flags1 = 0; //int
        var mask1 = 0x7fff;//int
        var base1 = 17;//int

        var flags2 = (byte)0; //byte
        var mask2 = (short)0x7fff;//short
        var base2 = (long)17;//long
    }
}

var in Lambda Expression 
    - Lambda expr can also be implicitly typed with var syntax
           (var num) -> num+1;

public class LambdaExpression {
    public static void main(String[] args) {
        Function<Integer,Integer> f = (var num) -> 1;

//        var f1 = (var num) -> 1;

        BiFunction<Integer,Integer,String> f2 = (@Notnull var a,var b) -> "Hello";
    }
}
    - var can be used with annotation 
           (@NotNull var a,var b) -> a+b;
    - var can be used for non-denotable (anonymous class and intersection)

public class NonDenotable {
    public static void main(String[] args) {
        //Anonymous Class
        var productInfo = new Object() {
            String name = "Apple";
            int total = 0;
        };
        System.out.println("name = " + productInfo.name + ", total = " + productInfo.total);

}}

Cant do
1. you cant mix var and non var parameters
        (var a,Integer b)-> true;  //error
        (var a,var b)-> true; //correct
        (String x,var y,Integer z)->true; //error
        (var x,var y,var z)->3.14159; //correct

2. you cant mix var and explicit type parameters
        (var x, y) -> "goodbye"; //error
3. you cant omit parenthesis for single var parameter
        var w-> 99;  //error


Lambda Expression and Functional programming

Deferred Execution - in lambda object will not be created unless we call the implementation of method


Anonymous class			                 Lambda
1. It is an inner class                     1. Lambda is static 
It has an instance in memory                method in memory

2. keyword this represent inner             2. keyword this 
anonymous class                                represent enclosing class

3. It can have more than                    3. only one method
one method 

public class ConvenienceMethod {
    public static void main(String[] args) {
        //Predicate
        Predicate<String> egg = str -> str.contains("egg");
        Predicate<String> brown = str -> str.contains("brown");

//        Predicate<String> brownEggs = str -> str.contains("egg") && str.contains("brown");
        Predicate<String> brownEggs = egg.and(brown);
        System.out.println(brownEggs.test("eggbrown"));

//        Predicate<String> otherEggs = str -> str.contains("egg") && !str.contains("brown");
        Predicate<String> otherEggs = egg.and(brown.negate());

        //Consumer
        Consumer<String> c1 = x -> System.out.print("1: " + x);
        Consumer<String> c2 = x -> System.out.println(",2: " + x);
        Consumer<String> combined = c1.andThen(c2);
        combined.accept("Annie");

        //Function
        Function<Integer, Integer> before = x -> x + 1;
        Function<Integer, Integer> after = x -> x * 2;
        Function<Integer, Integer> combined2 = after.andThen(before);
        System.out.println(combined2.apply(3));//( 3 x 2) +1 = 7

        combined2 = after.compose(before);
        System.out.println(combined2.apply(3));//(3 + 1) x 2 = 8
    }
}


Variable in lambda expression

1. Parameter list

What is type of x in below code?

Predicate<String> p=x->true;   //string
---------------------------------------------------
public void whatAmI(){
   test((var x)->x>2,123);   //x is integer
}
public void test(Predicate<Integer> c,int num){
   c.test(num);
}
---------------------------------------------------
public void counts(List<Integer> list){
   list.sort((var x,var y)->x.compareTo(y));  //x is integer
}


2. Local variable inside lambda body
       Cannot create a local variable with the same name as one already declared in scope

(a,b) -> { int c=0; return 5;}  //correct
(a,b) -> { int a=0; return 5;}  //error

public void variables(int a){   //error 
    int b=1;
   Predicate<Integer> p1=a->{
             int b=0;
             int c=0;
             return b==c;};
}

3. Variable Reference from Lambda body
    Rules for accessing a variable from a lambda body inside a method

Variable Type				Rule
Instance Variable			Allowed
Static variable 			Allowed
Local variable			Allowed if effectively final
Method parameter                Allowed if effectively final
Lambda parameter		        Allowed

Effectively final - value cannot change and dont need to explicitly declare final

public class Closure {
    private static String staticVariable;
    private String instanceVariable;

    public void instanceMethod(final String parameter) {
        final String localVariable = "local";
        staticVariable ="allowed";

        Predicate<String> p = str -> (instanceVariable + parameter + localVariable + staticVariable).length() == 10;

//        parameter ="not allowed";
//        localVariable ="not allowed";

        staticVariable ="allowed";
        instanceVariable ="allowed";
    }
}


Optional class

public class MyOptional {

    public static Optional<Double> average(int... scores) {
        if (scores.length == 0)
            return Optional.empty();

        int sum = 0;
        for (int score : scores) {
            sum += score;
        }
        return Optional.of((double) sum / scores.length);
    }

    public static void main(String[] args) {
        System.out.println(average(90, 100));
        System.out.println(average());

        Optional<Double> opt = average(90, 100);
        if (opt.isPresent())
            System.out.println(opt.get());

        //or
        opt.ifPresent(System.out::println);

        opt = average();
//        System.out.println(opt.get());//NoSuchElementException

        String value = "";
        Optional o = (value == null) ? Optional.empty() : Optional.of(value);
        //or
        o = Optional.ofNullable(value);

        opt = average();
        System.out.println(opt.orElse(Double.NaN));
        System.out.println(opt.orElseGet(Math::random));// () -> Math.random()
//        System.out.println(opt.orElseThrow());//NoSuchElementException
//        System.out.println(opt.orElseThrow(IllegalAccessError::new));//() -> new IllegalAccessError()
//        System.out.println(opt.orElseGet(IllegalStateException::new));//Does not compile

        opt = average(90, 100);
        System.out.println(opt.orElse(Double.NaN));
        System.out.println(opt.orElseGet(Math::random));
        System.out.println(opt.orElseThrow());
    }
}


Stream API
    Sequence of data, it can be used only once
Types:  Finite and infinite

Lazy evaluation: delay execution until necessary - we pass lambda expr/method reference in the function and processor calls the method at its own

https://www.rapid7.com/blog/post/2017/01/13/java-8-lazy-argument-evaluation/

public class EagerVsLazyEvaluation {

    static boolean compute(String str) {
        System.out.println("executing...");
        // expensive computation here
        return str.contains("a");
    }

    static String eagerMatch(boolean b1, boolean b2) {
        return b1 && b2 ? "match" : "incompatible!";
    }

    static String lazyMatch(Supplier<Boolean> a, Supplier<Boolean> b) {
        return a.get() && b.get() ? "match" : "incompatible!";
        //call function here - if first part returns false then other doesn`t execute
    }

    public static void main(String[] args) {
        System.out.println(eagerMatch(compute("bb"), compute("aa")));//call function
        System.out.println(lazyMatch(() -> compute("bb"), () -> compute("aa")));
    }
}

When we call eagerMatch() it prints 
executing...
executing...
incompatible!
But when we call lazyMatch() it prints
executing...
incompatible!

When it comes to lazyMatch(), we call a.get() goes to compute() and get false and && which is short circuit operator, so if one is false it wont execute the next one. So in eagerMatch() we have 2 method calls but in lazyMatch() it is 1 method call  and it happens only at execution 

Intermediate vs Terminal operation
Scenario		Intermediate     Terminal
1. can exist multiple	    yes		    no
times in pipeline

2. Return type is stream    yes	 	    no

3. Executed upon method     no              yes
call

4. Stream valid after       yes             no
call


Advanced Stream Pipeline Concept

1. Linking streams to the underlying data

public class Linking {
    public static void main(String[] args) {
        var cats = new ArrayList<String>();
        cats.add("Annie");
        cats.add("Ripley");

        var stream = cats.stream();
        cats.add("KC");
        System.out.println(stream.count());
    }
}

2. Chaining Optional - calls one optional to another optional 

public class ChainingOptionals {
    public static void main(String[] args) {
        threeDigit_Java7(Optional.empty());
        threeDigit_Java7(Optional.of(4));
        threeDigit_Java7(Optional.of(123));

        threeDigit_Java8(Optional.empty());
        threeDigit_Java8(Optional.of(4));
        threeDigit_Java8(Optional.of(123));

        Optional<String> optional = Optional.of("123");
        Optional<Integer> result = optional.map(String::length);
        System.out.println(result.get());

        Optional<Optional<Integer>> result1 = optional.map(ChainingOptionals::calculator);
        System.out.println(result1.get().get());

        Optional<Integer> result2 = optional.flatMap(ChainingOptionals::calculator);
        System.out.println(result2.get());
    }

    private static Optional<Integer> calculator(String s) {
        return Optional.of(s.length());
    }

    private static void threeDigit_Java8(Optional<Integer> optional) {
        optional.map(n -> "" + n)
                .filter(s -> s.length() == 3)
                .ifPresent(System.out::println);
    }

    private static void threeDigit_Java7(Optional<Integer> optional) {
        if (optional.isPresent()) {
            Integer num = optional.get();
            String string = "" + num;
            if (string.length() == 3) {
                System.out.println(string);
            }
        }
    }
}

3. Collecting Results - used to group the results

1. Collecting using Basic Collectors
public class CollectingCollectors {
    public static void main(String[] args) {
        String result = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.joining(","));
        System.out.println(result);

        Double results = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.averagingInt(String::length));
        System.out.println(results);

        Set<String> result1 = Stream.of("lions","toads", "tigers", "bears")
                .filter(s -> s.startsWith("t"))
                .collect(Collectors.toSet());
        System.out.println(result1);

        TreeSet<String> result2 = Stream.of("lions", "toads", "tigers", "bears")
                .filter(s -> s.startsWith("t"))
                .collect(Collectors.toCollection(TreeSet::new));
        System.out.println(result2);
    }
}

2. Collecting into Maps using toMap()
       To create map we need to specify 2 functions
1). How to create key
2). How to create value 

public class CollectingMaps {
    public static void main(String[] args) {
        Map<String, Integer> map = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.toMap(s -> s, String::length));
        System.out.println(map);

        //reverse key into values
        Map<Integer, String> map1 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.toMap(String::length, s -> s, (s1, s2) -> s1 + "," + s2));
        System.out.println(map1);
        System.out.println(map1.getClass());

        TreeMap<Integer, String> map2 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.toMap(String::length,
                        s->s,
                        (s1, s2) -> s1 + "," + s2,
                        TreeMap::new));
        System.out.println(map2);
        System.out.println(map2.getClass());
    }
}

3). Grouping - group all the elements of the stream into Map using groupingBy()
   groupingBy(Function f)
   groupingBy(Function f, Collector c)
   groupingBy(Function f, Supplier s,Collector c)

public class Grouping {
    public static void main(String[] args) {
        Map<Integer, List<String>> map = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length));
        System.out.println(map);

        Map<Integer, Set<String>> map1 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length, Collectors.toSet()));
        System.out.println(map1);

        TreeMap<Integer, Set<String>> map2 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length, TreeMap::new, Collectors.toSet()));
        System.out.println(map2);

        TreeMap<Integer, List<String>> map3 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length, TreeMap::new, Collectors.toList()));
        System.out.println(map3);
    }
}

4. Partitioning - splitting list into 2 parts - true and false
      partitioningBy(Predicate p)
      partitioningBy(Predicate p, Collector c)

public class Partitioning {
    public static void main(String[] args) {
        Map<Boolean, List<String>> map = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.partitioningBy(s -> s.length() <= 5));
        System.out.println(map);

        map = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.partitioningBy(s -> s.length() <= 7));
        System.out.println(map);

        Map<Boolean, Set<String>> map1 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.partitioningBy(s -> s.length() <= 7, Collectors.toSet()));
        System.out.println(map1);

        Map<Integer, Long> map3 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length, Collectors.counting()));
        System.out.println(map3);

    }


Interface

1. Interface contains public static final constant variable
2. Interface contains abstract method
3. Interface contains default,static method from Java8
4. Interface contains private, private static method from Java9

public /*abstract*/ interface InterfaceSummary {
    /*public static final*/ int CONSTANT = 1;

    /*public abstract*/ int abstractMethod();

    /*public*/ default int defaultMethod(){abstractMethod(); privateMethod();staticMethod();  privateStaticMethod();return CONSTANT; }

    private int privateMethod(){abstractMethod();defaultMethod();staticMethod();privateStaticMethod();return CONSTANT;}

    /*public*/ static int staticMethod(){ privateStaticMethod(); return CONSTANT; }

    private static int privateStaticMethod(){ return CONSTANT;}

}

Instance method in interface can access static method
   - abstract
   - default
   - non static private

Class/static method in interface cant access instance method (ie) static and static private 

Interface Member access
1. Accessible from default and private methods within interface defination
    constant variable - yes
    abstract method-yes
    default method - yes
    private method - yes
    static method - yes
    private static method - yes

2. Accessible from static methods within interface defination
    constant variable - yes
    abstract method-no
    default method - no
    private method - no
    static method - yes
    private static method - yes

3. Accessible from instance methods implementing or extending the interface - Refer WithInterface.java
     constant variable - yes
    abstract method-yes
    default method - yes
    private method - no
    static method - yes
    private static method - no

4.Accessible outside interface without an instance of interface - Refer WithoutInterface.java
     constant variable - yes
    abstract method-no
    default method - no
    private method - no
    static method - yes
    private static method - no


public class WithInterface implements InterfaceSummary{
    @Override
    public int abstractMethod() {
        defaultMethod();
        InterfaceSummary.staticMethod();
        return CONSTANT;
    }
}


public class WithoutInterface {
    public int instantMethod() {
        InterfaceSummary.staticMethod();
        return InterfaceSummary.CONSTANT;
    }
}


Create and use Enumeration
     - It is type of class that mainly contains constants or fixed set of values
     - It implicitly extends from abstract class java.lang.Enum
     - It is implicitly final (ie) it cannot extend but implements interface
     - It provides type-safe checking, invalid enum value introduce compiler error


public enum Day /*implements MyInterface*/{
    SUNDAY,
    MONDAY,
    TUESDAY ,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY;
}
interface MyInterface{

}

/*public enum ExtendedEnum extends Day{
}*/


public class Main {
    public static void main(String[] args) {
        Day d = Day.TUESDAY;
        //Day d=2;  //error
        Day d1 = Day.valueOf("TUESDAY");
      // d1 = Day.valueOf("tuesday"); //compiler error because no enum tuesday

        System.out.println(d == d1);
        System.out.println(d.equals(d1));
        System.out.println(Day.SUNDAY);
        System.out.println(d.toString());

        for (Day day: Day.values() ) {
            System.out.println(day.name() + " " + day.ordinal());
        }

        /*if (Day.THURSDAY == 4){    //compiler error

       }*/
}


Important notes
1. Values are declare first
2. Values end with semicolon,if there is anything besides value show compiler error

public enum Day {
    int i=4; //compiler error

    SUNDAY,
    MONDAY,
    TUESDAY ,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY;
   
    private String temparature; //correct but previously u should end with semicolon
}

3. A non final enum method can be overridden by any enum value

public enum Day {
    int i=4; //compiler error

    SUNDAY {
      public void printTemperature(){            System.out.println(75);
    }},
    MONDAY,
    TUESDAY ,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY;
   
    private String temparature; 

    public void printTemperature(){                     System.out.println(65);
    }
}
So sunday have overridden method and rest of days have default value 

public class Main {
    public static void main(String[] args) {
       d.printTemperature();  //prints 65
       Day.SUNDAY.printTemperature(); //prints 75
    }
}

4. If we have abstract method then it should be implemented 

public enum Day {
    int i=4; //compiler error

    SUNDAY {
      public void printTemperature(){            
           System.out.println(75);
    }},
    MONDAY{
      public void printTemperature(){            
           System.out.println(65);
    }},
    TUESDAY{
      public void printTemperature(){            
           System.out.println(75);
    }} ,
    WEDNESDAY{
      public void printTemperature(){            
           System.out.println(85);
    }},
    THURSDAY{
      public void printTemperature(){            
           System.out.println(65);
    }},
    FRIDAY{
      public void printTemperature(){            
           System.out.println(75);
    }},
    SATURDAY{
      public void printTemperature(){            
           System.out.println(85);
    }};
   
    private String temparature; 

    public abstract void printTemperature();
}


Constructor
  - Implicitly private 
  - Called once in the beginning to create enum values.


public enum Day{
    SUNDAY("High"){ public void printTemperature(){ System.out.println(75); }},
    MONDAY ("Moderate"){ @Override public void printTemperature() {System.out.println(65);}},
    TUESDAY ("High"){ @Override public void printTemperature() {System.out.println(75);}},
    WEDNESDAY("High") { @Override public void printTemperature() {System.out.println(85);}},
    THURSDAY ("Moderate"){ @Override public void printTemperature() {System.out.println(65);}},
    FRIDAY ("High"){ @Override public void printTemperature() {System.out.println(75);}},
    SATURDAY ("High"){ @Override public void printTemperature() {System.out.println(85);}};

    private String temperature;

    /*private*/ Day (String temperature){
        this.temperature = temperature;
    }

    public  abstract void printTemperature();

}

5. Enum can also used in switch

switch (d){
            case SUNDAY:
                System.out.println("Go to beach");
                break;
            case MONDAY:
                System.out.println("Go back to work");
                break;
            case TUESDAY://Error- Day.TUESDAY: , 2
                System.out.println("I am at work");
                break;
            default:
                System.out.println("Are you at work?");
        }


Compiler error
   Code will not compile if 
     1. Values are not declared first
     2. Constructor contains public or protected modifier
     3. Switch block - contains case as Enum.TYPE
     4. extends an enum
     5. compare enum value with integer


Multithreading - Concurrency

Thread 
   It is smallest unit of execution that can schedule by OS

Process
   It is group of one or more threads that are run in shared env

Shared Environment
   Multiple threads run in the same memory space an d talk to each other directly. If they are not in shared env, two threads cannot talk 

Single Threaded Process
   It is process that have exactly one thread
Multi Threaded Process
   It is process that have more than one thread 

Consider we have a process and let say its a java program and then any process that is run by OS will have a memory associated with it where it stores all info that needs to run the program. Let say this program has multiple threads in it, so all the thread will use this memory that is reserved for the process. When the threads has to do some computation it needs CPU and to get CPU it takes the help of OS thread scheduler, thread scheduler is build in OS, which is used to find a CPU that is available for a given thread 

2 types of Thread
1. System Thread 
      It is threads that we do not interact directly with. For example when we run a java program there are some background threads running (ie) Garbage collector that cleans up memory periodically and as a programmer we dont directly deal with garbage collector, so JVM takes care of it and runs in backend
2. User defined thread 
      It is the thread that we will create in our program. Every java program that we run are multithreaded program and we didnt dealt with system thread directly and jvm creating other threads and the program we have written in the main() is just one of the thread that jvm controls

Thread concurrency
     We know OS thread scheduler is sitting between thread and CPU's so that scheduler uses an algorithm to decide which threads get the CPU time
1. Round Robin Scheduling in which a fixed amount of time is given to each thread and as soon as that time amount is over the thread is taken out of CPU and the next thread is put in for the computation. OS goes in round robin fashion starting with thread one to last thread and comes back again to thread one and so on

2. Priority based scheduling
      OS scheduler will always pick a thread which is of higher priority, so priority which is associated with the thread represent as integer number, if scheduler sees higher priority coming in it moves out the lower priority thread out of CPU and gives CPU with higher priority thread 
      The process where the OS takes out a thread from CPU and puts a new thread is known as context switching

Polling
   Eventhough multithreaded program allows u to run tasks in parallel there is often a situation where one thread needs to wait for another thread, we can do using polling
   Polling is a process where one thread constantly checks if the other thread is done before it continues 

Polling using static variable
     We create main thread and that main thread will start another thread, lets call that new thread as IncrementNumber which has static variable called counter, and static variable will be accessed by both the threads. 
     So IncrementThread will keep on incrementing the counter variable and main thread will keep constantly checking the value of counter as soon as the value goes above defined value, the main thread will continue with its process

public class CheckResult {
    private static int counter=0;
    PSVM throws InterruptedException{
        new Thread(() -> {
           for(int i=0;i<500;i++) {
              CheckResult.counter++;
           }
        }).start();
  
      while(CheckResult.counter < 400){
         System.out.println("Not reached, keep waiting");
         Thread.sleep(1);
      }
       System.out.println("End of main thread");
   }
}


Single Thread Executor 
    We have seen 2 ways to create thread, but as the program gets bigger and bigger it becomes bit complex to do all the thread managment tasks manually. Java have concurreny API to handle the complicated work of managing threads

ExecutorService Interface
   It defines the operation that can done on thread, since this is an interface we need a concrete class that will have the implementation and concurrency api provides a way to get that concrete class.
   We can get instance of single thread executor using below code, once we get hold of executor we can ask to execute as many task using execute() and then we need to shutdown the executor so if we do not shutdown then program keep on going

  ExecutorService e=Executors.newSingleThreadExecutor();
   e.execute(task);
   e.shutdown();

In the above code we are creating thread executor service that will manage only one thread so if we ask to execute multiple tasks all those tasks will be executed synchronously (ie) in sequence one after the other but those tasks will happen in parallel to the main thread 

Consider we create thread with task1 which prints simple statement and task2 which print from 0 to 4. Now we create instance of SingleThreadExecutor and execute task1,task2,task1 and finally shutdown the executor

public class Main { PSVM {
    System.out.println("Start of Main thread");
    Runnable task1=() -> {
               System.out.println("Task 1: Simple print");
    };
    Runnable task2=() -> {
           for(int i=0;i<5;i++){
               System.out.println("Task 2:i="+i);
           }
    };

    ExecutorService e=null;
    try { 
       e=Executors.newSingleThreadExecutors();
       e.execute(task1);
       e.execute(task2);
       e.execute(task1);
    }
    finally {
       if(e!=null) {
          e.shutdown();
       }
    }
    System.out.println("End of main thread");
   }
}

Start of Main thread
Task 1: Simple print
Task 2:i=0
Task 2:i=1
Task 2:i=2
Task 2:i=3
Task 2:i=4
Task 1: Simple print
End of main thread

Here we can see each task will execute sequentially because we use SingleThreadExecutor which happend in sequence and in parallel to main thread 

Shutting down Executor service
    - e.shutdown() does not actually stop any task  that have been submitted to thread executor, it will wait for all the tasks to finish and then shutdown the executor 
    - e.shutdownNow(), let say we have given multiple tasks to the executor service, at any given point there will be some tasks that already have been finished, there will be some tasks that are in process at that particular time and there will be tasks in queue that are still to be executed. When shutdownNow() is hit the tasks that are currently in process, the executor service  attempts to stop them and tasks that are not yet started those tasks will not be executed and returns list of runnable tasks that are never executed  

public class Main { PSVM {
    System.out.println("Start of Main thread");
    Runnable task1=() -> {
               System.out.println("Task 1: Simple print");
    };
    Runnable task2=() -> {
           for(int i=0;i<5;i++){
               System.out.println("Task 2:i="+i);
           }
    };

    ExecutorService e=null;
    try { 
       e=Executors.newSingleThreadExecutors();
       e.execute(task1);
       e.execute(task2);
       e.execute(task1);
    }
    finally {
       if(e!=null) {
          List<Runnable> t=e.shutdown();
          System.out.println(t.size()+"tasks never got run");
       }
    }
    System.out.println("End of main thread");
   }
}

Start of main thread
Tas 1: Simple Print
2 tasks never got run
End of main thread 

Now it will exexute task1 and by the time it got shutdownNow request so it didnt execute the other 2 tasks 

Concurrency - submit,invokeAll/any
    We have seen how to ask executor service to run tasks in a thread, we have used execute() but we not assigned the output of execute() to any variable because execute dosent return anything. This way of doing job is called fire and forget where u ask someone to do the task and dont care when it is finished or it finished successfully.
   But if task returns some value and we want to get hold of that then we use submit(). The main difference between execute() and submit() is that submit() returns a Future object, this object represent the task and we can get the state of the task at any given point of time

ExecutorService method
1. void execute(Runnable task) - Takes Runnable task but does not return anything and task is executed some point in the future

2. Future submit(Runnable task) - Takes Runnable task and returns Future object representing the task. 

3. Future submit(Callable task) - Takes Callable task as input 
   Callable is similar to Runnable, Callable will return something back. This submit() return Future object and we can use the Future object to get the value returned from the Callable

4. List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException
    It takes list of Callable tasks and wait for all of them to finish. This call is blocking call which means unless all the tasks are finished the control in the  code will not move forward and once the tasks are finished the method will return a list if future in the same order in which we gave the list of  tasks to it to execute

5. T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException
    It takes a list of Callable tasks and wait for at least one to finish, it returns the result of finished task, when anyone of task is finished then it cancels the remanining unfinished tasks 

Future interface
   - Used to get more information about the given tasks

1. boolean isDone()
      This method returns true if task is completed, completion may be due to normal termination that is task completed successfully or the task could have thrown exception or task would have been cancelled in all cases this method will return true 

2. boolean isCancelled()
      Returns true if this task was cancelled before it completed normally

3. boolean cancel(boolean b)
      Attempts to cancel a task, return true if its successfully cancelled, false if it could not be cancelled or its already finished

4. V get()
      Waits if necessary for the computation to complete, and then retrieves its result that return from task. This method will wait until the task is complete no matter how long the task takes 

5. V get(long timeout, TimeUnit unit)
      We give timeout and say that if the task has finished then return the result of the task but if it does not finish in provided time period then return back without getting the result 


Example:
   Here we create ExecutorService using newSingleThreadExecutor and submit a runnable task which just increment number from 1 to 500 and return the output of submit() to Future called result and we make result to wait for 10sec (ie)maximum time waiting for result. If the task completes successfully then it comes to print statement within 10sec, if the task dosent complete within 10sec then it will throw an exception 

public class Main {
   private static int counter=0;
   PSVM() throws ExecutionException, InterruptedException {
      ExecutorService service=null;
   try {
     service = Executors.newSingleThreadExecutor();
     Future<?> result=service.submit(() -> {
         for(int i=0;i<500;i++) {
             Main.counter++;
         }
     )};
     result.get(10,TimeUnit.SECONDS);
     System.out.println("Task Completed");
   }
   catch(TimeoutException e){
      System.out.println("Not completed task");
   }
   finally {
       if(service!=null){
           service.shutdown();
       }
   }
  }
}


Callable Interface
   @FunctionalInterface
   public interface Callable {
       V call() throws Exception;
   }

We create AddData class which add two numbers in a separate thread and return back to main thread, since we returning result we cannot use Runnable we use Callable.
    Here we create ExecutorService using newSingleThreadExecutor and submit a task as callable to it and in this task we simply add 2 numbers and return the response  as Future. Here we didnt give timeout so the call will wait for the callable task to finish and move on and no matter how long callable task takes 

public class Main {
   PSVM() throws ExecutionException, InterruptedException {
      System.out.println("Start of main thread");
      ExecutorService service=null;
   try {
     service = Executors.newSingleThreadExecutor();
     Future<?> result=service.submit(() -> 1+2);
     System.out.println("Result ="+result.get());
   }
   catch(TimeoutException e){
      System.out.println("Not completed task");
   }
   finally {
       if(service!=null){
           service.shutdown();
       }
   }
   System.out.println("End of main thread");
  }
}

So here get() waits until Callable task is finished 


Submitting Multiple tasks using invokeAll/invokeAny
    We create Callable task which return the string,and create ExecutorService. Now we call invokeAll which takes list of callable task and we give same task 3 times and finally return List<Future>. We use for loop to print the output of each callable 

public class Main {
   PSVM() throws ExecutionException, InterruptedException {
      System.out.println("Start of main thread");
      Callable<String> task=()->"Return from the thread";
      ExecutorService service=null;
   try {
     service = Executors.newSingleThreadExecutor();
     List<Future<String>> result=service.invokeAll(Arrays.asList(task,task,task));

     for(Future result:results){
          System.out.println(result.get());
     }
   }
   finally {
       if(service!=null){
           service.shutdown();
       }
   }
   System.out.println("End of main thread");
  }
}

Output:
Start of main thread
Result from the thread
Result from the thread
Result from the thread
End of main thread

So here invokeAll() only return back when all 3 tasks that we gave to it finished.

invokeAny:
   It will return the result of the task that is completed 

public class Main {
   PSVM() throws ExecutionException, InterruptedException {
      System.out.println("Start of main thread");
      Callable<String> task=()->"Return from the thread";
      ExecutorService service=null;
   try {
     service = Executors.newSingleThreadExecutor();
    String result=service.invokeAny(Arrays.asList(task,task,task));
          System.out.println(result);
     
   }
   finally {
       if(service!=null){
           service.shutdown();
       }
   }
   System.out.println("End of main thread");
  }
}

Output:
Start of main thread
Result from the thread
End of main thread

Even though we asked to run 3 callable task, it just run anyone of task and whichever finishes the earliest it returns the response back and cancels the other 2 tasks 

Waiting for result: 
     ExecutorService service=null;
   try {
     service = Executors.newSingleThreadExecutor();
     Future<?> result=service.submit(() -> {
         for(int i=0;i<500;i++) {
             Main.counter++;
         }
     )};
     result.get(10,TimeUnit.SECONDS);
     System.out.println("Task Completed");
   }
   In the previous example we have submitted runnable task and then we use Future object to wait  on the task to finish, we have another way to achieve this functionality ExecutorService awaitTermination() and we give timeout until when we want the executor to wait for the task to finish

public class Main {
   private static int counter=0;
   PSVM() throws ExecutionException, InterruptedException {
      ExecutorService service=null;
   try {
     service = Executors.newSingleThreadExecutor();
     Future<?> result=service.submit(() -> {
         for(int i=0;i<500;i++) {
             Main.counter++;
         }
     });
   }
   finally {
       if(service!=null){
           service.shutdown();
       }
   }
   if(service!=null){
      service.awaitTermination(10,TimeUnit.SECONDS);
      if(service.isTerminated()){
         SOP("Task Completed");
      } else {
         SOP("Atleast one task is still running"):
       }
     }
   }
  }
}


How to schedule a task using Concurrency API?
     Consider we want to create a job which runs at every 5min and check the status of another program thats running or we want to generate and send a report at the end of day. For these type of scenarios we want the task to happen at regular intervals and concurreny api provides a way to do that
     Concurrency API has an interface called ScheduledExecutorService for this purpose and this interface extends ExecutorService 

ScheduledExecutorService e=Executors.newSingleThreadScheduledExecutor();

Methods:
1. public ScheduledFuture<?> schedule(Runnable task, long delay, TimeUnit t)
    This method will run the task that we provided with delay of time we provided and return type is ScheduledFuture
   ScheduledFuture is an interface which extends Delayed and Future interface 
   Delayed interface has method long getDelay(TimeUnit t) and returns the time that is left for the task to run 
 
2. public ScheduledFuture<?> schedule(Callable task, long delay, TimeUnit t)
    It takes callable and we see Runnable dosent return anything and Callable returns value from thread so depends on scenario we can use any method

3. public ScheduledFuture<?> scheduleAtFixedRate(Runnable task, long initialDelay,long period, TimeUnit t)
     Used to run the task at regular provided interval, previous 2 methods will only fire the task only once 

4. public ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, long initialDelay,long period, TimeUnit t)
    The difference between the above method is the delay that we provide, time period will only counts when the previous job is done. Say we have long running job, say the job that u run takes 2min and delay we give is 1min, in this case job will run for 2 min and there will be delay after first job is finished and then again the job will be kicked which will take another 2 min 
   Whereas in previous method it dosent care about if ur job is finished, whenever the time period we have given expires it schedules another job

Example 1:
   We create Callable task which return string value, we create ScheduledExecutorService and we call schedule() which takes the task and run the task after 5sec 

public class Main {
    PSVM() throws ExecutionException, InterruptedException {
    Callable<String> task=()->"Returned from thread";
    ScheduledExecutorService service=null;
    try {
        service=Executors.newSingleThreadScheduledExecutor();
ScheduledFuture future=service.schedule(task,5,TimeUnit.SECONDS);
System.out.println(future.get());
}
finally {
   if(service!=null){
       service.shutdown();
   }
}
}}

When we run it will wait for 5sec timeout and then it will print the output 

Example 2: We use Runnable

public class Main {
    PSVM() throws ExecutionException, InterruptedException {
    Runnable<String> task=()->System.out.println("Returned from thread");
    ScheduledExecutorService service=null;
    try {
        service=Executors.newSingleThreadScheduledExecutor();
ScheduledFuture future=service.schedule(task,5,TimeUnit.SECONDS);
}
finally {
   if(service!=null){
       service.shutdown();
   }
}
}}

When we run it will wait for 5sec timeout and then it will print the output

Example 3:
   Here we give initial delay of 5sec and once time expires we want the job to run every second. In case of scheduleAtFixedRate or scheduleAtFixedDelay we dont shutdown executor because if u shutdown then it will stop working 

public class Main {
    PSVM()  {
    Runnable<String> task=()->System.out.println("Returned from thread");
    ScheduledExecutorService service=null;
    
        service=Executors.newSingleThreadScheduledExecutor();
ScheduledFuture future=service.scheduleAtFixedRate(task,5,1,TimeUnit.SECONDS);
}}

First it will wait for initial 5sec delay after that it will run thread for every 1 sec

If we want executor to shutdown then we need to write extra logic so here we sleep for 10sec and then shutdown the executor and after sleep we will cancel the task

public class Main {
    PSVM() throws InterruptedException {
    Runnable<String> task=()->System.out.println("Returned from thread");
    ScheduledExecutorService service=null;
    try {
        service=Executors.newSingleThreadScheduledExecutor();
        ScheduledFuture future=service.scheduleAtFixedRate(task,5,1,TimeUnit.SECONDS);
        Thread.sleep(10000);
        future.cancel(true);
    }
    finally {
   if(service!=null){
       service.shutdown();
   }
}
}}

Here we ask ScheduledExecutorService to schedule the task, then main thread will sleep for 10sec after that we cancel the task using cancel() after that goes to finally block and stops the executor 

Example 4:
  Now we want the task to some time to execute by using sleep()

public class Main {
    PSVM()  {
    Runnable<String> task=()->{
         System.out.println("Start of task");
         try {   Thread.sleep(5000); }
         catch(InterruptedException e){ }
         System.out.println("End of task");
    };
    ScheduledExecutorService service=null;
    
        service=Executors.newSingleThreadScheduledExecutor();
ScheduledFuture future=service.scheduleAtFixedRate(task,5,1,TimeUnit.SECONDS);
}}

First program will wait for 5sec initial delay and now task is started but it is long running task and then task ended and next task is already started. The reason next task immediately starts was it has already passed that 1sec period, so 1sec period starts as soon as task is kicked off. Since the task ran longer than our time period the next task ran immediately after that.
   In case if we want a gap between first and second task then we use scheduleWithFixedDelay is used


public class Main {
    PSVM()  {
    Runnable<String> task=()->{
         System.out.println("Start of task");
         try {   Thread.sleep(5000); }
         catch(InterruptedException e){ }
         System.out.println("End of task");
    };
    ScheduledExecutorService service=null;
    
        service=Executors.newSingleThreadScheduledExecutor();
ScheduledFuture future=service.scheduleWithFixedDelay(task,5,1,TimeUnit.SECONDS);
}}

First it waits for initial 5sec delay, the thread is started since its long running we are waiting for it to finish and thread finished. Next we can see a gap inbetween start of next one and end of previous one and this gap is due to 1sec period we gave 


Thread Pools
    We has created a main thread and that starts execution and at some point its going to create ExecutorService using newSingleThreadExecutor() which will handle only one thread . Now if main() want to execute a task it will ask ExecutorService to execute the task in a different thread, since this is singleThreadExecutor it gives the task to one thread it manages and the task gets executed.
    Now the main thread gives 4 tasks to the executor then the ExecutorService makes use of 1 thread it has to execute those tasks, now the tasks will be executed one after the other in sequence, they do happen in parallel to the main thread but there is no concurrency within the task itself. If you want to these 4 tasks to be run in parallel thats where Thread pool is used

Introduction to Thread Pool
    We will start the main thread and at some point in main thread we create ExecutorService which handle 4 threads. Now let say main thread wants the 4 tasks to be executed, then its going to handover those 4 tasks to the executor service and ask to execute into the threads. ExecutorService will take each task and assign a thread to the task, since ExecutorService have 4 different threads that its managing all 4 threads will execute those tasks in parallel along with main, so main is 5th thread in this case 

How to get Thread Pool Executors?
3 methods
1. ExecutorService newFixedThreadPool(int)
       This method will return ExecutorService which will manage a fixed number of threads and that number of threads will be determined by parameters that we pass 

2. ExecutorService newCachedThreadPool()
       We are not passing integer number which means we are not predefining the number of threads so ExecutorService will create threads on demand so as soon as it receives a task it creates a thread and does that task, if it receives multiple tasks in parallel that means if one task is running and before it finishes, it receives another task then it will create a second thread so once the task is finished, the thread stays for 1min and if no new tasks coming then thread will discarded 

3. ScheduledExecutorService newScheduledThreadPool(int)
      Used to get ScheduledExecutorService which schedule the task at sometime in future and it can be recurring task, to get a scheduledExecutorService which manages more than one thread we use newScheduledThreadPool and pass an integer 

Example 1:
   In main() we create Runnable task and print thread id using Thread.currentThread.getId() which will assigned by default to each thread with sleep of 5 sec.
   Now create ExecutorService which  manage 4 different threads , now we submit the task 4 times (ie) we give 4 tasks to thread executor to run 

public class Main { PSVM {
   Runnable task = () -> {
       System.out.println("Start of task with id="+Thread.currentThread().getId());
     try {  Thread.sleep(5000); }
     catch(InterruptedException e){ }
   };
  
  ExecutorService service=Executors.newFixedThreadPool(4);
  try {
       service.submit(task);
       service.submit(task);
       service.submit(task);
       service.submit(task);
  }
  finally {
      if(service!=null)
          service.shutdown();
  }
 }
}

Now we can see all 4 task will be started in parallel and once 5sec sleep is over it ends the task and all 4 tasks taking exactly 5sec

Example 2:
  Instead of giving fixed sleep of 5sec to all task, we give random sleep by using Random class. So it will return intefer number between 0 to 20, when we submit 4 tasks all tasks will have different sleep times  

public class Main { 
    private static Random random=new Random();
   PSVM {
   Runnable task = () -> {
       int sleepTime=random.nextInt(20);
       System.out.println("Start of task with id="+Thread.currentThread().getId()+" "+sleepTime+"seconds");
     try {  Thread.sleep(sleepTime+1000); }
     catch(InterruptedException e){ }
   };
  
  ExecutorService service=Executors.newFixedThreadPool(4);
  try {
       service.submit(task);
       service.submit(task);
       service.submit(task);
       service.submit(task);
  }
  finally {
      if(service!=null)
          service.shutdown();
  }
 }
}

Now we can see different task taking different time to run.

Example:
   Now we use newCachedThreadPool(), so in this case when executor starts it dosent have any thread but as we submit the task it actually creates a new threads on fly 

public class Main { 
    private static Random random=new Random();
   PSVM {
   Runnable task = () -> {
       int sleepTime=random.nextInt(20);
       System.out.println("Start of task with id="+Thread.currentThread().getId()+" "+sleepTime+"seconds");
     try {  Thread.sleep(sleepTime+1000); }
     catch(InterruptedException e){ }
   };
  
  ExecutorService service=Executors.newCachedThreadPool();
  try {
       service.submit(task);
       service.submit(task);
       service.submit(task);
       service.submit(task);
  }
  finally {
      if(service!=null)
          service.shutdown();
  }
 }
}

We can see 4 tasks in parallel with random delays and once all 4 of them finishes, the program ends

Example:
  Now we provide newScheduledThreadPool() which return ScheduledExecutorService and we can schedule the first task 5 sec later and schedule second task 6sec later, 3rd task 7sec later and 4th task 8sec later

public class Main { 
    private static Random random=new Random();
   PSVM {
   Runnable task = () -> {
       int sleepTime=random.nextInt(20);
       System.out.println("Start of task with id="+Thread.currentThread().getId()+" "+sleepTime+"seconds");
     try {  Thread.sleep(sleepTime+1000); }
     catch(InterruptedException e){ }
   };
  
  ScheduledExecutorService service=Executors.newScheduledThreadPool(4);
  try {
       service.schedule(task,5,TimeUnit.SECONDS);
       service.schedule(task,6,TimeUnit.SECONDS);
       service.schedule(task,7,TimeUnit.SECONDS);
       service.schedule(task,8,TimeUnit.SECONDS);
  }
  finally {
      if(service!=null)
          service.shutdown();
  }
 }
}

First it will wait for initial delay for each task and one by one it will schedule all 4 tasks with random sleep and all 4 tasks running in parallel


Understanding the problem of Thread Safety
     We create static variable and then we create 10 different threads and ask each thread to increment and print the number

public class Main {
  private static Integer counter=0;
  PSVM() {
    ExecutorService service=Executors.newFixedThreadPool(10);
    try {
       for(int i=0;i<10;i++) {
          service.submit(() -> {
             System.out.println(++counter+" ");
          });
       }
    } finally {
        if(service != null) 
           service.shutdown();
      }
   }
}

Here each thread would go and get the counter, increment the counter to its next value and it should print from 1 to 10. But when we run it is very different.

Problem with the code we wrote
1. Duplicity
2. Missing Number (only incremented number until 8 not 10)
3. Output are not in sequence 

   So when the program starts we have created counter static variable and in main thread once the execution starts we create ExecutorService and then submit 10 tasks to it to increment 1 number. Since ExecutorService managing 10 different threads so it will use each thread to increment the counter once,due to parallel task that we are running we have this problem 


Increment Operation using Atomic class
     Since all classes are thread safety in Atomic class we dont want to worry about thread safe 

public class Main {
  private static AtomicInteger counter=new AtomicInteger();
  PSVM() {
    ExecutorService service=Executors.newFixedThreadPool(10);
    try {
       for(int i=0;i<10;i++) {
          service.submit(() -> {
             System.out.println(counter.incrementAndGet()+" ");
          });
       }
    } finally {
        if(service != null) 
           service.shutdown();
      }
   }
}

Now all 10 threads have incremented the variable exactly once and print the number from 1 to 10 but not in order 

3 Atomic class 
    1. AtomicInteger
    2. AtomicLong
    3. AtomicBoolean 
All are used to do operations in thread safe way

Common Atomic Methods
1. get() - get the value
2. set() - set the value 
3. getAndSet() - used to set new value that is passed in and method returns old value that was stored in the variable 
4. incrementAndGet() - equivalent to pre increment
5. getAndIncrement() - equivalent to post increment
6. decrementAndGet() - equivalent to pre decrement
7. getAndDecrement() - equivalent to post increment


Writing Thread Safety Code using Synchronized Block
      Previously we saw Atomic classes to achieve thread safety in increment operation. Now we have a requirement that we want to print all the variables in sequence which means that one thread not only should increment the variable but also we want to print the number before the other threads can access it
    
Synchronized block
    //some code
    synchronized(someinstance) {
        //This code will be accessed by one and one 
        //only thread at given time
    }
    //More code

Synchronized block will have synchronized keyword and have an instance in the argument with start and end curly braces, any code that goes within these curly braces can be accessed by one and only one thread at any given time, the instance provided in parenthesis can be any object 
    Consider we have 2 threads thread1 and thread2, they both running code in parallel. Say thread1 reaches the synchronized block first, it uses that instance that we provided in the argument to acquire the lock. When thread1 has a lock and other thread reaches, then they have to wait to get the lock, thread1 will release the lock only when it reaches closing curly braces of synchrozied block, until that thread2 will keep on waiting for the lock.
   Thread2 will acquire the lock on the instance and then start executing that code within the block and once the thread2 reaches to the end of block then it release the lock for other threads to acquire it, so using this process we will ensure that code that is written within curly brace will always run by one thread at any given point of time and since the synchronzied block is run sequentially within the thread to improve the performance, this block should be as small as possible 

Example:
   Here we use synchronized block in place where we define the task, so here we use service as instance  that the threads will get locked on 
    
public class Main {
  private static Integer counter=0;
  PSVM() {
    ExecutorService service=Executors.newFixedThreadPool(10);
    try {
       for(int i=0;i<10;i++) {
          service.submit(() -> {
              synchronized(service) }
             System.out.println(++counter);
            }
          });
       }
    } finally {
        if(service != null) 
           service.shutdown();
      }
   }
}
We can see the output where all numbers will be printed in sequence because print statement is also synchronized so until one thread increments and prints the value, it dosent give access of counter to second thread 

Reentrant Lock 
    We have seen synchronized block as if one thread acquires the lock, the other threads cannot access the code written in synchronized block and keeps waiting until the first thread has finished 
    If we want the thread2 to first check if it can acquire a lock and if it cannot for now, we want to  do something else and then try again after sometime, that way thread2 dosent have to wait while thread1 is executing the synchronized block.
    In case if thread1 never releases the lock then thread2 will wait there forever, to address this problem concurrency API have lock framework where we can get more control on acquiring the lock and for that we use Lock interface 
    Its is similar to synchronization block, the only difference is instead of synchronizing on any object we can only lock on the object that implements the lock interface. We can get concrete implementation of lock interface using ReentrantLock class 
     
    Lock lock=new ReentrantLock();
    try  {
        lock.lock();
    }
    finally {
        lock.unlock();
    }

First we create an instance of ReentrantLock class and then use lock() to get the lock and then do the work that cannot be run in parallel and when we done with work we release the lock using unlock(), releasing the lock is important otherwise other thread will not get the lock forever and also we can only release the lock that we have acquired 

Example:

public class Main {
  private static Integer counter=0;
  PSVM() {
    ExecutorService service=Executors.newFixedThreadPool(10);
  Lock lock=new ReentrantLock();
    try {
       for(int i=0;i<10;i++) {
          service.submit(() -> {
              try { lock.lock();
             System.out.println(++counter);}
            finally { lock.unlock(); }
            }
          });
       }
    } finally {
        if(service != null) 
           service.shutdown();
      }
   }
}
We can see the output where all numbers will be printed in sequence

Example:
    We see what happens if we do not unlock 

public class Main {
  private static Integer counter=0;
  PSVM() {
    ExecutorService service=Executors.newFixedThreadPool(10);
  Lock lock=new ReentrantLock();
    try {
       for(int i=0;i<10;i++) {
          service.submit(() -> {
              try { lock.lock();
             System.out.println(++counter);}
            finally { //lock.unlock(); }
            }
          });
       }
    } finally {
        if(service != null) 
           service.shutdown();
      }
   }
}

The program hangs because thread comes in it get the lock, it prints the value but never releases it and the thread finishes and other threads are still waiting to get the lock, so always we need to unlock in case of Lock framework

Methods in Lock interface
1. void lock() - requests lock and blocks until uts acquired. It is blocking call which means whatever method is calling the lock method will actually block its execution until it acquires the lock 
2. void unlock() - Releases the lock
3. boolean tryLock() - Requests the lock and return immediately, the return value will tell if the lock  was acquired or not
4. boolean tryLock(long,TimeUnit) - Requests the lock and blocks for specified time. The return value will tell if the lock is acquired or not 

Example:
   We create acquireLock() which takes lock as argument and it will simply get the lock and release the lock 
   In main(), we create instance of Lock and we create a another new thread which run parallel to main thread and then task that new thread will do is simply get and release the lock. And we use tryLock() to get the lock and if we get and we print 

public class Main {
  PSVM() {
  Lock lock=new ReentrantLock();
  new Thread(()->acquireLock(lock)).start();
  if(lock.tryLock()){
     SOP("Lock acquired by main thread");
     lock.unlock();
  }
  else {
     SOP("Lock cannot acquired by main thread");
  }
 }
  public static void acquireLock(Lock lock){
    try {
        lock.lock();
    }
    finally {
        lock.unlock();
    }
  }
}

Output: Lock cannot acquired by main thread
   The reason is when main thread try to acquire the lock using tryLock(), at that time the other thread that we created has that lock, so main thread did not wait to get the lock 

Example:
public class Main {
  PSVM()throws InterruptedException {
  Lock lock=new ReentrantLock();
  new Thread(()->acquireLock(lock)).start();
  Thread.sleep(2000);
  if(lock.tryLock()){
     SOP("Lock acquired by main thread");
     lock.unlock();
  }
  else {
     SOP("Lock cannot acquired by main thread");
  }
 }
  public static void acquireLock(Lock lock){
    try {
        lock.lock();
    }
    finally {
        lock.unlock();
    }
  }
}

Output: Lock acquired by main thread
   The reason is by 2 sec the additional thread that we created it already acquire the lock and release it, so now main thread able to acquire the lock 

1. Without locking the thread, if we unlock then the program throws IllegalMonitorStateException
public class Main {
  PSVM() {
  Lock lock=new ReentrantLock();
        lock.unlock();
  }
}

2. Lock framework will keep the count of how many times have we locked 
public class Main {
  PSVM() {
  Lock lock=new ReentrantLock();
        lock.lock();
        lock.lock();
        lock.unlock();
        lock.unlock();

     new Thread(()->System.out.println(lock.tryLock())).start();
  }
}
Output: True
   The reason is new thread we create is able to get the lock because main thread already released the lock


Cyclic Barrier
    Consider we have cage which has some lions in it  and the task that we want to achieve is to clean the cage. At high level this is how the sequence would be so we will remove all lions from cage, we will clean the cage and once its clean we will put back all the lions.
    Conside zoo has only 1 employee, the employee will remove all the lions in the cage one after the other, once all the lions are removed that employee goes into the cage and cleans, comes back out and put back all lions in cage. If we have one employee  then we do not have any problem, we do not need any orchestration the employee is doing what he suppose to do.
   Now say we have 4 employees and we want to use all 4 employees to do as much work as possible in parallel, so that the work as whole is done in a greater speed, given that they all 4 different human beings all of them will have a different caliber and hence they might work in a different speed, so there is possibility that employee1 removes the lion and goes into cage to clean it even before the other 3 lions are removed (ie) employee1 is much faster than other 3. But we have problem that employee1 is in cage with 3 lions in it which might not end well.
   What we want is eventhough employee1 is fast we need to ask him to wait until all other 3 lions are  removed from the cage, and once they are then all 4 employees will go in cage, they all will clean the cage and all of them do their part of the job and all 4 employees are back out of cage, then we will bring all 4 lions into cage 
   So in multithreading, think 4 employees as 4 different threads, we need some kind of orchestration which would communicate between the threads, so eventhough 1 thread is faster than other we want it to wait until other 3 threads done that unit of task and only after all 4 threads have done the task they will move on to the next unit. This orchestration of task can be done using cyclic barrier 

Example:
   We create ZooManager class with removeLion() which just print some statement along with id of thread. We create another method cleanCage() which just print some statement along with id of thread. We create another method addLion() which just print some statement along with id of thread. Next we create performTasks() which call all previous that we created      
   Next we create main class inside we create ExecutorService with 4 different threads, next we create instance of ZooManager class, next we submit the task and task will be doing all three different  task we defined 

public class ZooManager {
  public void removeLion() {
      SOP(Thread.currentThread().getId()+"Removing lion");
  }
  public void cleanCage() {
      SOP(Thread.currentThread().getId()+"Cleaning cage");
  }
  public void addLion() {
      SOP(Thread.currentThread().getId()+"Adding lion");
  }
  public void performTasks(CyclicBarrier c1, CyclicBarrier c2) {
     try { removeLion();
      c1.await();
      cleanCage();
      c2.await();
      addLion();
     }
     catch(InterruptedException | BrokenBarrierException e) {
        System.out.println(e);
     }
  }
}

public class Main { PSVM  {
   ExecutorService service=Executors.newFixedThreadPool(4);
   ZooManager manager=new ZooManager();
   CyclicBarrier c1=new CyclicBarrier(4);
   CyclicBarrier c2=new CyclicBarrier(4,()->System.out.println("Cage cleaned"));
   try {
       for(int i=0;i<4;i++) {
          service.submit(()->manager.performTasks(c1,c2));
    }
   finally {
      if(service != null){
          service.shutdown();
      }
   }
}

await() is going to stop the execution of threads until a counter has been reached and that counter is the number that we gave in the constructor when we created Cyclic Barrier 

JDBC -  https://github.com/mhussainshah1/JDBC11

Bind Variables
   The placeholder that lets u specify  the actual values at runtime

Can:
  - set parameters out of order
  - set the different parameter and skip similar in updating multi times

public class UpdateMultiples {
    public static void main(String[] args) throws SQLException {
        var sql = "INSERT INTO names VALUES (?, ?, ?)";
        try(Connection conn = DriverManager.getConnection("jdbc:derby:zoo");
            var ps = conn.prepareStatement(sql)){

            ps.setInt(1, 20);
            ps.setInt(2, 1);
            ps.setString(3, "Ester");
            ps.executeUpdate();

            ps.setInt(1,21);
            ps.setString(3, "Elias");
            ps.executeUpdate();
        }
    }
}

Java is smart enough, it will take 2nd bind variable from the previous one so output to be 20,1,Ester and 21,1,Elias

Cant:
   - set more or less values than u have as bind variable

//error
public static void registerMore(Connection conn, int key, int type, String name) throws SQLException {
        var sql = "INSERT INTO names VALUES (?, ?)";
        try (var ps = conn.prepareStatement(sql)) {
            ps.setInt(1,key);
            ps.setInt(2,type);
            ps.setString(3,name);

            int result = ps.executeUpdate();
            System.out.println(result);
        }
    }

//error
    public static void registerLess(Connection conn, int key, int type, String name) throws SQLException {
        var sql = "INSERT INTO names VALUES (?, ?, ?)";
        try (var ps = conn.prepareStatement(sql)) {
            ps.setInt(1,key);
            ps.setInt(2,type);

            int result = ps.executeUpdate();
            System.out.println(result);
        }
    }
   - cant Work if u dont set them in between PreparedStatement and ResultSet

public class BindVariables {
    public static void main(String[] args) throws SQLException {
        Connection conn = DriverManager.getConnection("jdbc:derby:zoo");
        var sql = "SELECT id FROM exhibits where name = ?";

        try(var ps = conn.prepareStatement(sql)){

            ps.setString(1, "Zebra");//set in between ps and rs

            try(var rs = ps.executeQuery()){
                while (rs.next()){
                    int id = rs.getInt("id");
                    System.out.println(id);
                }
            }
        }

    }
}



public class BadCode {
    public static void main(String[] args) throws SQLException {
        Connection conn = DriverManager.getConnection("jdbc:derby:zoo");
        var sql = "SELECT COUNT(*) AS count FROM EXHIBITS";
        /*try (var ps = conn.prepareStatement(sql);
             var rs = ps.executeQuery()) {
            if (rs.next()) {
                var count = rs.getInt("total");//SQLException: Column 'total' not found.
                System.out.println(count);
            }
        }*/

        /*sql = "SELECT * FROM EXHIBITS WHERE name = 'Not in table'";
        try (var ps = conn.prepareStatement(sql);
             var rs = ps.executeQuery()) {
            rs.next();
            rs.getInt(1);//SQLException: Invalid cursor state - no current row.
        }*/

        /*sql = "SELECT COUNT(*) FROM EXHIBITS";
        try (var ps = conn.prepareStatement(sql);
             var rs = ps.executeQuery()) {
            if (rs.next()) {
                var count = rs.getInt(0);//SQLException:  Column '0' not found.
                System.out.println(count);
            }
        }*/

        sql = "SELECT name FROM EXHIBITS";
        try (var ps = conn.prepareStatement(sql);
             var rs = ps.executeQuery()) {
            if (rs.next()) {
                rs.getInt("badColumn");//SQLException:  Column 'badColumn' not found.
            }
        }

    }
}

Closing Database Resources
   - Closing a Connection also closes PreparedStatement or CallableStatement and ResultSet
   - Closing a PreparedStatement or CallableStatement and ResultSet
   - JDBC automatically close a ResultSet when u run another SQL statement from same statement

public class TryCatchResources {
    public static void main(String[] args) throws SQLException {

        var url = "jdbc:derby:zoo";
        var sql = "SELECT COUNT(*) FROM names WHERE id = ?";
        try (var conn = DriverManager.getConnection(url);    //1 - open conn
             var ps = conn.prepareStatement(sql)) {     //2 - open ps
            ps.setInt(1, 1);

            var rs1 = ps.executeQuery();
            while (rs1.next()) {                                        //3 - open rs1
                System.out.println("Count: " + rs1.getInt(1));
            }

            ps.setInt(1, 2);
            var rs2 = ps.executeQuery();
            while (rs2.next()) {                                        //4 - close rs1  , 5 - open rs2
                System.out.println("Count: " + rs2.getInt(1));
            }
            rs2.close();                                                //6 - close rs2
        }                                                               //7 - close ps
                                                                        //8 - close conn
    }
}


Localization

https://github.com/mhussainshah1/Localization

Date Formatting

public class FormatDateTime {
    public static void main(String[] args) {
        LocalDate date = LocalDate.of(2020, Month.NOVEMBER, 10);
        LocalTime time = LocalTime.of(19, 23);
        LocalDateTime dt = LocalDateTime.of(date, time);

        //format
        //buit-in formatter
        System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE));
        System.out.println(time.format(DateTimeFormatter.ISO_LOCAL_TIME));
        System.out.println(dt.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));

//        System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_TIME));
//        System.out.println(time.format(DateTimeFormatter.ISO_LOCAL_DATE));

        //custom formatter
        var formatter1 = DateTimeFormatter.ofPattern("MM/dd/yyyy hh:mm:ss");
        System.out.println(dt.format(formatter1));

        var formatter2 = DateTimeFormatter.ofPattern("MM_yyyy_-_dd");
        System.out.println(dt.format(formatter2));

        var formatter3 = DateTimeFormatter.ofPattern("h:mm z");
//        System.out.println(dt.format(formatter3));

        System.out.println(formatter1.format(dt));

        //Add custom text
        var f = DateTimeFormatter.ofPattern("MMMM dd, yyyy 'at' hh:mm");
        System.out.println(dt.format(f));

        var f1 = DateTimeFormatter.ofPattern("MMMM dd, yyyy");
        var f2 = DateTimeFormatter.ofPattern("hh:mm");
        System.out.println(dt.format(f1) + " at " + dt.format(f2));

        var g1 = DateTimeFormatter.ofPattern("MMMM dd, yyyy 'Party''s at' hh:mm");
        System.out.println(dt.format(g1));

        var g2 = DateTimeFormatter.ofPattern("'System format, hh:mm' hh:mm");
        System.out.println(dt.format(g2));

        var g3 = DateTimeFormatter.ofPattern("'New!' yyyy ',yay!!'");
        System.out.println(dt.format(g3));

//        DateTimeFormatter.ofPattern("Time is: hh:mm:ss");
//        DateTimeFormatter.ofPattern("'Time is: hh:mm:ss");

        //In java 7
        DateFormat s = new SimpleDateFormat("MMMM dd, yyyy 'at' hh:mm");
        System.out.println(s.format(new Date()));
    }
}

Internationalization
   Designing ur program so it can ve adapted. This involves placing strings in a properties file and ensuring the proper data formatters are used

Locale: specific geographical, political or cultural region

Localization - supporting multiple locales or geographic regios. It includes translating strings to different languages. Output the dates and numbers in the correct format for that locale

Locale class - java.util.* package
  Locale language - fr
  Locale language,country - en_US

Select Built-in Locale
1. constants - Locale.GERMAN

2. Constructor
       new Locale("fr");
       new Locale("en","US");

Invalid identifier
   EN - langugae must be lowercase
   US - cannot have country without language
   enUS - Missing Underscore
   US_en - The country and language are reversed

3. Builder design pattern
     Locale l1=new Locale.Builder()
        .setLanguage("en").setRegio("US").build();

Methods:
   1. public static Locale getDefault()
   2. public static void setDefault(Locale newLocale)
   3. public static void setLocale(Locale.Category l,Locale newLocale)

public class MyLocale {
    public static void main(String[] args) {
        Locale locale = Locale.getDefault();
        System.out.println(locale);//en_US

        //Select Locale
        System.out.println(Locale.GERMAN);//de
        System.out.println(Locale.GERMANY);//de_DE

        //2
        System.out.println(new Locale("fr"));//fr
        System.out.println(new Locale("ur","PK"));//ur_PK
        System.out.println(new Locale("xx","XX")); //prints but dosent behave as Locale

        //3
        Locale l1 = new Locale.Builder()
                .setLanguage("hi")
                .setRegion("IN")
                .build(); //hi_IN

        Locale l2 = new Locale.Builder()
                .setRegion("IN")
                .setLanguage("hi")
                .build(); //hi_IN

        //set local
        locale = new Locale("fr");
        Locale.setDefault(locale);
        System.out.println(Locale.getDefault());
    }
}

Localizing Dates - package java.time.format

1. For formatting dates - DateTimeFormatter.ofLocalizedDate(dateStyle)

2. For formatting times - DateTimeFormatter.ofLocalizedTime(timeStyle)

3. For formatting dates and times - DateTimeFormatter.ofLocalizedDateTime(dateStyle,timeStyle)
DateTimeFormatter.ofLocalizedDateTime(datetimeStyle)

public class LocalizingDates {

    public static void print(DateTimeFormatter dtf, LocalDateTime dateTime, Locale locale){
        System.out.println(dtf.format(dateTime) + ", " + dtf.withLocale(locale).format(dateTime));
    }
    public static void main(String[] args) {
        Locale.setDefault(new Locale("en","US"));
        var italy = new Locale("it","IT");
        var dt = LocalDateTime.of(2020, Month.NOVEMBER,12,19,23,55);

        print(DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT),dt,italy);
        print(DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT),dt,italy);
        print(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT,FormatStyle.SHORT),dt,italy);
    }
}

Localizing Number - package java.text

1. General purpose formatter 
     - NumberFormat.getInstance()
     - NumberFormat.getInstance(locale)

2. Same as getInstance
     - NumberFormat.getNumberInstance()
     - NumberFormat.getNumberInstance(locale)

3. For formatting monetary amounts
     - NumberFormat.getCurrencyInstance()
     - NumberFormat.getCurrencyInstance(locale)

4. For formatting percentages
     - NumberFormat.getPercentInstance()
     - NumberFormat.getPercentInstance(locale)

5. Rounds decimal values before displaying
     - NumberFormat.getIntegerInstance()
     - NumberFormat.getIntegerInstance(locale)

public final String format(double num) - change number to string

public Number parse(String source) throws ParseException - change String into Number


public class LocalizingNumbers {
    public static void main(String[] args) throws ParseException {
        //formatting
        //numbers
        int attendeesPerYear = 3_200_000;
        int attendeesPerMonth = attendeesPerYear / 12;

        var us = NumberFormat.getInstance(Locale.US);
        System.out.println(us.format(attendeesPerMonth));//266,666

        var gr = NumberFormat.getInstance(Locale.GERMANY);
        System.out.println(gr.format(attendeesPerMonth));//266.666

        var ca = NumberFormat.getInstance(Locale.CANADA_FRENCH);
        System.out.println(ca.format(attendeesPerMonth));//266 666

        //currency
        Locale.setDefault(new Locale("en","GB"));
        double price =40;
        var myLocale = NumberFormat.getCurrencyInstance();
        System.out.println(myLocale.format(price));//£40.00

        //parsing
        //number
        Locale.setDefault(new Locale("en","US"));
        String s ="40.45";
        var en =NumberFormat.getInstance();
        System.out.println(en.parse(s));
        var fr =NumberFormat.getInstance(Locale.FRANCE);
        System.out.println(fr.parse(s));

        //currency
        String income = "$92,807.99";
        var cf = NumberFormat.getCurrencyInstance();
        double value = (Double)cf.parse(income);
        System.out.println(value);

        //Custom Formatting
        //number
        double d = 1234567.467;
        NumberFormat f1 = new DecimalFormat("###,###,###.0");
        System.out.println(f1.format(d));//1,234,567.5

        NumberFormat f2 = new DecimalFormat("000,000,000.00000");
        System.out.println(f2.format(d));//001,234,567.46700

        //currency
        NumberFormat f3 = new DecimalFormat("$#,###,###.##");
        System.out.println(f3.format(d));//$1,234,567.47

    }
}

Custom Number formatter
    public DecimalFormat(String pattern)

# - Omit the position if no digit exist for it
0 - Put O in the position if no digit exists for it

Specifying Locale Category
   Locale.Category enum is a nested element, support distinct locales for displaying and formatting data
1. DISPLAY - Category used for displaying data about the locale
2. FORMAT - Category used for formatting dates,numbers or currencies

public class LocaleCategory {
    public static void print(Locale locale, double money){
        System.out.println(locale.getDisplayLanguage() + ", " + NumberFormat.getCurrencyInstance().format(money));
    }

    public static void main(String[] args) {
        var spain = new Locale("es" , "ES");
        var money = 1.23;

        Locale.setDefault(Locale.US);
        print(spain, money);

        Locale.setDefault(Locale.Category.DISPLAY, spain);
        print(spain, money);

        Locale.setDefault(Locale.Category.FORMAT, spain);
        print(spain, money);

    }
}

Loading properties with ResourceBundle
    ResourceBundle contains locale-specific objects to be used by a program. It is like a map with keys and values. The resource bundle is commonly stored in a properties file
   Properties file is a text file in a specific format with key/value pairs

public class MyResourceBundle {
    public static void main(String[] args) {
        var us = new Locale("en","US");
        var fr = new Locale("fr", "FR");
        print(us);
        print(fr);

        var rb1 = ResourceBundle.getBundle("Zoo" , us);
        rb1.keySet().stream()
                .map(k -> k +": " + rb1.getString(k))
                .forEach(System.out::println);
    }

    private static void print(Locale locale) {
        var rb = ResourceBundle.getBundle("Zoo" , locale);
        System.out.println(rb.getString("hello") + ", " + rb.getString("open"));
    }
}

Zoo_en.properties
hello=Hello
open=The zoo is open
name=en

Zoo_fr.properties
hello=Bonjour
open=Le zoo est ouvert
name=fr   


Without Requested Locale, by default is en_US

Zoo_en_US.properties
name=en_US
text=The Zoo
helloByName=Hello, {0} and {1}

With Requested Locale

Zoo_fr_FR.properties
name=fr_FR
visitors = French Visitors

public class PickingResourceBundle {
    public static void main(String[] args) {
        Locale.setDefault(new Locale("en","US"));//default locale
        Locale locale = new Locale("fr","FR"); //requested locale

        var rb = ResourceBundle.getBundle("Zoo");
        System.out.println(rb.getString("name"));
        /**
         * Zoo_en_US
         * Zoo_en
         * Zoo
         */

        rb = ResourceBundle.getBundle("Zoo" ,locale);
        System.out.println(rb.getString("name"));
        /**
         * Zoo_fr_FR
         * Zoo_fr
         * Zoo
         *
         * if requested locale(language,country) not present
         * ------------------------------------------------
         * Zoo_en_US
         * Zoo_en
         * Zoo
         */

        rb = ResourceBundle.getBundle("Zoo" ,locale);
        System.out.print(rb.getString("hello"));
        System.out.print(".");
        System.out.print(rb.getString("text"));
        System.out.print(" ");
        System.out.print(rb.getString("open"));
        System.out.print(" ");
        System.out.print(rb.getString("visitors"));


    }
}

Zoo.properties - No locale at all - default bundle
name=no locale
text=France Zoo


Formatting Message
MessageFormat - package java.text
  - Support parametrized String values that take input values
  - public static String format(String pattern,Object...arg)

public class FormattingMessages {
    public static void main(String[] args) {
        var us = new Locale("en" , "US");
        var rb = ResourceBundle.getBundle("Zoo",us);
        String format = rb.getString("helloByName");
        System.out.println(MessageFormat.format(format,"Muhammad","Shah"));
    }
}

If still not found throws MissingResourceException
