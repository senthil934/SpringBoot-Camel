Java Versioning
    - There is new java release coming in every 6 month, this is recent development, because of this there are 2 java release every year 

1. JDK1.0 in Jan1996 and there is subsequent release of JDK 2,3,4 after that major release was JDK5

2. J2SE5.0 in sep 2004 and there are 5 releases in almost 8 years 

3. The next major release is JavaSE 8(LTS-Long Term Support) on march 2014 which is most important Java release which bought functional programming, Lambda, Streams

4. Java SE9 in sep 2017 and again 4 release in 13 yrs (from 2004 to 2017 from 5 to 9 version)

5. Java SE10 in mar 2018 which is time based release versioning which means the release will happen for every 6 months and wht are features are ready that would be the part of that specific release

8. JavaSE 11(LTS) on sep 2018
        Java11 is paid versions, only for corporate users it is paid versions and for individual development it is free version. Oracle people have given open jdk for all members and use it

https://jdk.java.net/11/ - just download and extract u get jdk-11, no need to install jre separately and set the path 
9. Java SE 12 on mar 2019 etc
10. JavaSE 16 on mar 2021

Previously there is huge difference between each Java releases however from Java 10 onwards the new features introduced are far less as it coming in every 6 months. Java prefer to use long term support release because they have support for very long time.

Java new features
1. J2SE5.0 - Enhanced forloop,Generics, Enums, Autoboxing
2. Java SE8(LTS) - Functional programming
3. Java SE9 - Modularization(Java Platform Module System)
     Where Modularization of Java is introduced, where entire JDK is now modularized into multiple modules, not only that u can also build appl in modularized way
4. Java SE10 - Local variable type Inference - variable declaration is really complex, java can automatically infer the type of local variable in Java10
5. Java SE14 - Switch expression (Preview in 12 and 13)
      - Instead using switch as statement, from java 14 we can use switch as expression
6. Java SE 15 - Text blocks(Preview in 13)
      - If we want to write complex piece of text having multiple lines with ",', escape characters in Java is very difficult and text blocks make it easier
7. Java SE16 - Record classes (Preview in 14 and 15)
      - We have created many Java beans in previous versions with getter, setter, constructor, toString, equals  etc. In Java 16 we have record classes which makes it easy to create this type of bean classes 
8. All Java versions - There are new api is introduced and almost every version of Java has performance improvements expecially in Garbage collection
    

1. List,Set,Map copyOf method

Java 10 features
1. Local Variable Type Inference
      - Declaring local variable without type
      - Whenever we declare any variable we have to provide its datatype so only Java is called statically typed language, but Angular, Python, Javascript and all is called as dynamically typed one because depending upon the value its datatype is fixed 
     - So from JDK10 we can define any variable with "var" keyword, so compiler will understand depending upon the value it will take up datatype. 
 var a=1234; - So at compile time it will infers as int
After compile time variable "a" becomes of type int
   var b="hello"; //b infers as string at compilation

Limitations
   1. Only local variable will be declared with "var"
   2. var is reserved keyword
   3. var is not allowed in method, constructor arguments, method return types
   4. We cant assign null to var type, because null is generic (ie) it can be any object 
   5. var should be with declaration and initialization
      var a = 10;  //correct

      var a;
      a=10;  //wrong

Example:
public class Sample { PSVM {
    List<String> l1=List.of("One","two");
    List<String> l2=List.of("three","four");
    
    var names=List.of(l1,l2);
    names.stream().forEach(System.out::println);
    //whatever methods avaiable in List will now available in names also. Even when we make some mistake in methods also it will show
}

   -Java compiler infers the type of the variable at compile time
   - Introduced in Java10
   - You can add final if you want, but by default it is not final 
      final var names=List.of(l1,l2);
   - var can also be used in loops
        for(var name:names)
            System.out.println(name);
   - You cannot assign to null
            var abc=null;
   - var is not a keyword
   - Improved readability for chained expression
   var filter=List.of("one","two:).stream().filter(s->s.length()<5);
      filter.forEach(System.out::println);


2. API for creating unmodifiable Collection
     - From util package there are many methods introduce to support unmodifiable collection
     - List.copyOf, Set.copyOf, Map.copyOf used to create immutable list of values from existing list or set or map which cant be changed. If map we are passing is already immutable then it will return map back, it wont create copy
     - New methods toUnmodifiableList, toUnmodifiableSet, toUnmodifiableMap have been added to the Collectors class in stream package, which allow the elements of a stream to be collected into an unmodifiable collection

List<Integer> li=Arrays.asList(1,2,4,6,8);
List<Integer> l1=List.copyOf(li); //creates immutable object
SOP(l1); //[1,2,4,6,8]
l1.add(10); //throws UnsupportedOperationException

Stream<String> s2=Stream.of("a","b","c","d");
List<String> l2=s2.collect(Collectors.toUnmodifiableList());
Set<String> s=s2.collect(Collectors.toUnmodifiableSet());

Java 11 Features  
https://www.youtube.com/watch?v=gjr92jxiEd8
    
1. JRE Updates
      - From JDK11 onwards there is no jre install in the user machines. When u install JDK, JRE was getting install in our machines. But now onwards we wont get any JRE. So JDK and JRE are together installed. 
     - JDK itself contains Java development software and JRE 
     - In windows and Mac OS, installing the JDK in previous releases optionally installed JRE, this is no longer an option. Because Java is gradually moving towards Modularization we can create modules using JLink and we can reduces the size of software and ship that software to client  
     - Mainly JRE is install in client machine and top of that Java software is installed. Using JLink we can create small packages and u can ship that one 
     - Using JPackage also we can create exe files for windows so that the software can simply install in client machine. We can make exe file from jar file and install that jar into our client machine without any JRE

    1. Upto Java10 version, we need to compile and execute the java program. From Java11 version onwards we can execute java file directly without compiling 
   > java Test.java
  Whenever we give "java Test.java" internally first compilation perform then execution will take place, so in case any compilation failed it will show error also, which is some what similar to python execution like "python Test.py"

   2. In single java program, when we provide more than one class with main method, then JVM will search for main() in the order in which we provided from top to bottom, in which class JVM identifies main() first time then JVM will treat that class as the actual main class and JVM will execute that main class

Test.java
class C { PSVM  {
   SOP("C-Main");
}}
class A { PSVM  {
   SOP("A-Main");
}}
class B { PSVM  {
   SOP("B-Main");
}}
>java Test.java
Output: C-Main

No class file will be generated, it means which class is loaded and the respective other class are compiled but not loaded in memory
   Java11 provide backward compatibility (ie) here also we can compile and execute as previous version also 

Rules:
  1. We not have .class file for this Java file inside the folder
public class Test {
   PSVM {
      SOP("Hello world");
   }
}
>java Test.java
>java -verbose Test.java
     To check complete functionality of JVM, first it will load all classes into JVM and then at last we can see our class. JVM background uses compiler to do check

  2. If main() is not present in java file it will throw error
public class Test {
   
}
>java Test.java

  If in this folder we have .class file and if we run java Test.java then it will show error, so in Java11 we need only java file should be present
   This feature provide slow execution since both compilation and execution got combined so it is not used in production env, only for beginners or new learners we can use this. 

  3. We must place main method in first class in Java, because Java11 executes from top to bottom, so main class should be first class otherwise it will show compiler error
class Test { PSVM {
   SOP("Test-Main");
}}
public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
class B {
    static void m2() {  SOP("m2"); }
}
>java Test.java
Test-Main

  4. No need to be class name and java file name to be same, even if it is public. So u can create filename any and class name any. Because java command not verifying the class and java file same or not. We given this java file going into the file and check first class contain main method or not, if it is available it will execute 

class C{ PSVM {
   SOP("C-Main");
}}
public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
class B {
    static void m2() {  SOP("m2"); }
}
>java Test.java
C-Main

  5. Even if we have multiple main method in call, no problem JVM will execute the first main method 

class C { PSVM {
   SOP("C-Main");
   A.m1();
   B.m2();
   A.main(new String[0]);
}}
public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
class B {
    static void m2() {  SOP("m2"); }
}

>java Test.java
C-Main
m1
m2
A Main

  6. Even in single program, we have multiple classes to be public
  7. In single java program, we have multiple classes but when we run it will execute only main class, other classes will not load into JVM until u call those classes, to check that
    > java -verbose Test.java
Now we can it will load only C class into JVM
[class,load] C source: __JVM Defines___
  In case, if we call A.m1() inside main(), then if we check u can see C as well as A classes will be loaded in JVM 
   In source file, we can define multiple classes then first class should contain main() to launch the class, then when u running this java file we can have multiple classes compiler will compile all classes if no mistake are there it will generate the byte code and give to JVM. JVM making all this classes store in buffer, it is not loading in memory and storing somewhere in buffer. So whichever class we are accessing that class from buffer is loading in JVM 
   Previously the buffer is nothing but .class file that it is in harddisk, whenever we access the class that time class loading from harddisk to JVM and executed. But harddisk cannot be used thats why it uses internal RAM level buffer it uses, so RAM level buffer stores all this classes bytecode whenever we access methods from the class then at that time it load class to JVM.

    8. Now we copy class A separately into another java file
Test.java
class C { PSVM {
   SOP("C-Main");
   A.m1();
   B.m2();
   A.main(new String[0]);
}}
class B {
    static void m2() {  SOP("m2"); }
}  

A.java

public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}

>java Test.java
    - It will show error

But we can access other program if it has a class file 
>javac A.java
   - It creates A.class
Now we can execute 
>java Test.java
    It will execute main class, but when we try to access A.m1() it will show an IllegalAccessError. So if u want to access any class outside means it should be present in a package   

package p1;
public class A {
   public static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
>javac -d . A.java

Test.java
class C { PSVM {
   SOP("C-Main");
   p1.A.m1();
   B.m2();
   A.main(new String[0]);
}}
class B {
    static void m2() {  SOP("m2"); }
}  

>java Test.java
C main
A m1
B m2

We cannot access another java file classes, but we can access the classes which are already compiled and has .class with package 

CommandLine argument
>java Test.java 10 20 30

2. No language translations for Java release - From JDK11 onwards java releases available only in english

3. Updated packaging format for Windows has changed from .tar.gz to .zip and for MacOS it is changed from .app to .dmg

4. JavaFx, Java Mission Control(JMC) is shipped separately
     - Previously these where part of JDK itself, JavaFx is updates related to flash works, java effects api 

5. Deployment stack for applets, webstart apps deprecated in Java9 and now it is remove from Java 11

2. Launch single file programs without compilation 
       - When new developer want to start developing a program, he have study so many thing how to compile and execute the program
       - Here developer can write simple file and execute that single file without compiling (ie) without generating .class file we can execute the program
        >java sample.java
Without giving .class file we can run our file. Here java interpreter enhanced to take the responsbility of compilation without generating .class file. So internally maintaining some stack so directly running java file and give the output 

3. java.util.Collection - toArray(intFunction)

ArrayList<String> list=new ArrayList<>();
list.add("one");
list.add("two");

list.stream().toArray(s->new String[s]); //old version

String a[]=list.toArray(size->new String[size]);
SOP(Arrays.toString(arr));

Previously we have to create stream object and pass but now we can dynamically pass some lambda expr and generate the array 

String a[]=list.toArray(String[]::new); //using method refernece
SOP(Arrays.toString(arr));

4. Local Variable syntax for Lambda parameters
      -You either define the type var on all the parameters or none

interface Example {
    int operation(int a,int b);
}

Example e=(int a,int b) -> a+b;
Example e=(var a,var b) -> a+b;

(var a,var b) -> a+b;  //correct
(var a,b) -> a+b; //wrong
(a,var b) -> a+b; //wrong
(var a,String b)-> a+b; //wrong
var a -> a; //wrong,we have to use the parenthesis

5. String API changes
      - certain enhancement in String API
isBlank() - check whether string is blank or not
lines() - based on \n extract list of strings. From multi line string if we want to extract substring of each line
strip() - removes leading and trailing spaces
stripLeading()
stripTrailing()
   In general both method removes leading and trailing spaces from string. However the difference comes when we work with unicode charaters or multilingual features.New method strip which is added in java 11 usage this Character.isWhitespace(int) method to cover wide range of white space characters and remove them.

repeat() - repeat string for particular times

Example2: 

String a=" Welcome ";
SOP(a.isBlank()); //false
String a1="    ";
SOP(a.isBlank()); //true since it emply spaces

String b= "one \n"
         + "two \n"
         + "three \n";
a.lines().forEach(System.out::println);

String c="welcome"
SOP(c.repeat(5)); //welcome will repeat 5 times


SOP(" ".isBlank()); //true
SOP(" L R ".strip().replace(" ","@")); //L@R
SOP(" L R ".stripLeadig().replace(" ","@")); //L@R@
SOP(" L R ".stripTrailing().replace(" ","@")); //@L@R
"Line1\nLine2\nLine3\nLine4".lines().forEach(System.out::println);

String string = '\u2001'+"String    with    space"+ '\u2001';
   System.out.println("Before: \"" + string+"\"");
   System.out.println("After trim: \"" + string.trim()+"\"");
   System.out.println("After strip: \"" + string.strip()+"\"");
   }
}

//take specific set of string and transform it
SOP("UPPER".transform(s->s.substring(2))); //PER

//takes string and format it
SOP("My name is %s. My age is %d.".formatted("Ram",24));

//additional info for NullPointerException
String str=null;
System.out.println(str.isBlank()); //In Java14 it gives additional info about the NPE 

Example2:
public class Sample { PSVM {
  String name="";
  sop(name.isEmpty()); //true
  String name1=" ";
  sop(name1.isEmpty()); //false
  String name2=" ";
  sop(name2.isBlank()); //true
  String name3="";
  sop(name3.isBlank());  //true

  String name4="One\nTwo";
  List<String> l=name4.lines().collect(Collectors.toList());
  sop(l);  //[one,two]

  String s="test string\u205F";
  String s1=s.strip();
  sop(s1+"*****");
  String t1=s.trim();
  sop(t1+"*****");

  String n5=" Ram Kumar ";
  sop(n5.strip()); 
  String n6=" Ram Kumar ";
  sop(n6.stripLeading()); 
  String n7=" Ram Kumar ";
  sop(n7.stripTrailing()); 
  sop(n7.repeat(4));

6. Optional.isEmpty()
       - to check whether optional class is empty or not
       - If we want to do something if value is absent, in that case we use negation. It wont make it very readable. Normally ifPresent() gives value if value is present so for negation purpose we use !ifPresent() so for that we can use isEmpty()

 
Optional o=Optional.of("hello");
o=o.empty();
o.ifPresent(s->System.out.println(s));
SOP(o.isEmpty());  //true

7. Files read string and write string
     - When we write something to text files or read from file, we use BufferedReader, BufferedWriter, FileWriter etc. From Java11 onwards oracle introduce few methods which made easy to write few context and read from text file 
     - read and write string data from files - writeString(), readString(), isSameFile()-compare the contents of 2 file

Program 1:
var uri="C:\\data.txt";
try{
  Files.writeString(Path.of(uri),"hello",StandardOpenOption.APPEND);

  String data=Files.readString(Path.of(uri));
  System.out.println(data);
}
catch(IOException e){
    e.printStackTrace();
}

Now the data will be appended into file and prints the data

Program 2:
1. Create sample.txt inside resources folder
Sample
Line 2
Line 3
2. Now we read the content from file and write to another file

Path path=Paths.get("./resources/sample.txt");
String f=Files.readString(path);
System.out.println(f);
String n=f.replace("Line","Lines");
Path n1=Paths.get("./resources/sample1.txt");
Files.writeString(n1,n);

8. HTTP Client API
       - used to give post, get and delete request 
       - Alternate to HttpURLConnection,  we are using HttpURLConnection to deal with http connection, to read and perform operation on HTTP protocol. Now we use HTTP Client API to do all this things 
       - The advantage is it can perform sync and async operations and can handle multiple urls at same time on Http 1 as well as Http2

String uri="https://postman-echo.com/get?uname=java&pwd=121";
HttpRequest req=HttpRequest.newBuilder().uri(URI.create(uri)).GET().version(Version.HTTP_2).build();

HttpClient client=HttpClient.newBuilder().build();
try{
  HttpResponse<String> res=client.send(req,BodyHandlers.ofString());
   SOP(resp.statusCode());
   SOP(resp.body());
}
catch(IOException | InterruptedException e) {
   e.printStackTrace();
}

Example 2: synchronous get request 
public class Sample { 
//create http client with http version 1.1
private static final HttpClient httpClient=HttpClient.newBuilder()
          .version(HttpClient.Version.HTTP_1_1)
          .connectTimeout(Duration.ofSeconds(10))
          .build();

     PSVM() throws Exception {
   //Synchronous get request 
   HttpRequest req=HttpRequest.newBuilder()
                   .GET()
                   .uri(URI.create("https://httpbin.org/get"))
                   .setHeader("User-Agent","Java 11 HttpClient")
                   .build();

//using httpclient send the request 
HttpResponse<String> res=httpClient.send(req,HttpResponse.BodyHandlers.ofString());

HttpHeaders headers=res.headers();
headers.map().forEach((k,v)->System.out.println(k +":"+v));
   System.out.println(res.statusCode());
   System.out.println(res.body());

}
}

Example 3: For Asynchrounous GET request 
public class Sample { 
//create http client with http version 2
private static final HttpClient httpClient=HttpClient.newBuilder()
          .version(HttpClient.Version.HTTP_2)
          .connectTimeout(Duration.ofSeconds(10))
          .build();

     PSVM() throws Exception {
   //Synchronous get request 
   HttpRequest req=HttpRequest.newBuilder()
                   .GET()
                   .uri(URI.create("https://httpbin.org/get"))
                   .setHeader("User-Agent","Java 11 HttpClient")
                   .build();

CompletableFuture<HttpResponse<String>> res=httpClient.sendAsync(req,HttpResponse.BodyHandlers.ofString());

String result=res.thenApply(HttpResponse::body).get(5, TimeUnit.SECONDS);
System.out.println(result);
}
}

Example 4: we can send multiple request at same time

public class Sample {
   private static final ExecutorService exe=Executors.newFixedThreadPool(3);

private static final HttpClient httpClient=HttpClient.newBuilder()
          .executor(exe)
          .version(HttpClient.Version.HTTP_2)
          .connectTimeout(Duration.ofSeconds(10))
          .build();
PSVM() throws Exception  {
   List<URI> targets = Arrays.asList(
       new URI("https://httpbin.org/get?name=ram"),
       new URI("https://httpbin.org/get?name=kumar"),
       new URI("https://httpbin.org/get?name=sam"));

List<CompletableFuture<String>> res=target.stream().
       map(url->httpClient.sendAsync(
           HttpRequest.newBuilder(url)
             .GET()
             .setHeader("User-Agent","Java HttpClient")
             .build(),
         HttpResponse.BodyHandlers.ofString())
        .thenApply(HttpResponse::body))
        .collect(Collectors.toList());

for(CompletableFuture<String> f:res) {
     sop(f.join());
  {
}
}

9. Predicate.not
      - Returns a predicate that is the negation of the supplier predicate 

public class Sample {
    public static boolean isEven(Integer number) {
         return number%2==0;
    }
    public static void main(String[] a){
        List<Integer> l=List.of(3,4,5,67,89,88);
    //Predicate<Integer> p1=n->n%2==0;
    //l.stream().filter(p1).forEach(System.out::println);  //4, 88
    //l.stream().filter(p1.negate()).forEach(System.out::println);  //3,5,67,89

   l.stream().filter(Predicate.not(Sample::isEven)).forEach(System.out::println); //4 88


10. Nested based access control
       - This is the feature 

Example 1:

public class Main {
    static class Blog {
         private String name;
    }
    PSVM {
      Blog b=new Blog();
      Field bName=Blog.class.getDeclaredField("name");
      bName.set(b,"hello world");
      SOP(b.name);
   }
}

Example 2:

public class Test {
     private static int x=5;
     public static class NestedTest {
         public static void doSomething() {
             System.out.println(x);
         }
     }
}

>javac Test.java
>javap -v Test.class

Before Java11 we we compile such type of file,here we can see extra method will be added for nested class called static int access$000(). This is the private bridge created between two classes, when we compile a class which contains another class so for that 2 class file will be created, one for outer and one for inner, so there should be some bridge between the outer class can access the method of another .class file 

>javap -v Test$NestedTest.class

Here we can see when we invoke doSomething(), it have provide like Test.access$000(), stating the outerclass can access this method by specifying the bridge between  both of the classes

But from Java11 onwards another access control is introduced which is "nest" and in nest we have nestHost and nestMembers. Basically outer class is nest host and inner classes are nest members or nest mate of that class
  When we compile the code in Java11 and see
>javac Test.java
>javap -v Test.class
    Here we have static int access$000() which will act as bridge between outer and inner class so that we can access private members of the outer class. So in Java11 onwards we have nesthost and nestmembers, so the outer class contains nest members as "Test$NestedTest.class"
    When we try to access inner class
>javap -v Test$NestedTest.class
    Here we can see nest host as "class Test" which is outer class 

So basically in this feature there is no impact on development or enduser but just enhancement on JVM level. 

Basically, the nest term defines a new access control context that allows classes that are logically part of the same code entity, but which are compiled with distinct class files, to access each others private members without the need for compilers to insert accessibiltity bridge methods
   Earlier version to access private members of class we need to specify the brigding method, but from java11 onwards no need to specify in compiled class instead we need to mention nesthost and nest members


11. TimeUnit Conversion
       - used to convert DAY, HOURS, MINUTES 

TimeUnit c=TimeUnit.DAYS;
c.convert(Duration.ofHours(24));
Output: 1 //convert 24hrs to day

TimeUnit c1=TimeUnit.MINUTES;
c1.convert(Duration.ofHours(60));
Output: 3600

13. Pattern recognizing method
      - used to generate the pattern and test against the string 

asMatchPredicate() - will create a predicate if pattern matches with input string 



14. Java Flight Recorder
       - Used tool for running Java appl and capturing diagnostic for further analysis. So when ur appl crashes or not perform as expected, u can monitor or troubleshoot it using the data collected by flight recorder
       - It is used for black box analysis as it continuously save state data into circular buffer and this information can be accessed when a problem is detected. You can use JFR for unexpected events.
       - For example if we get OutOfMemoryError in ur code or VM crashes, we can get all details and root causes with help of JFR

Introduction to Flight Recorder
   1. JFR provides best possible visibility into the JVM since it is build into JVM itself
   2. JFR has low performance overhead when used in heavily loaded production appl. We have overhead when we have profilers because profilers are attached to JVM and they consume heaps and create their own threads. When we use in production system u should carefully choose which event u should use with profiling
   3. It is event based profiling engine, when we say event that could be garbage collection or CPU load increase by threshold value or heap space consume more than 90%. JFR collects data from more than 500 events and we can create custom events also 
   4. JFR has binary recordings and we cant open and look into them. Events are written in binary formats, all the recordings are .jfr extension 
   5. We have Java API also to load and read data through Java code, you can trigger events through Java API calls. Java API is introduced in Java9 in jdfk.jfr package 

Events
   - Event occurs in JVM at specific point in time. Each event has name, timestamp and optional payload(the data associated with event)
   - For eg, CPU usage or Java heap size before and after the event or thread id 

3 types of events
   1. Duration events
   2. Instant events
   3. Sample events

Removed Features
1. Removal of com.sun.awt.AWTUtilities class
2. Removal of appletviewer launcher
3. Removal of Thread.destroy() and Thread.stop() methods
4. Removal of JVM-Managemebt-MIB.mib
5. Removal of Java Deployment Technologies like Java plugins, Java webstart, JRE 
6. Removal of JAVA FX from Oracle JDK
7. Remove JavaEE and CORBA Modules

Migration to Java 11
1. Eclipse : Photon 4.9RC2 with Java 11 plugin
Maven :3.5.0
Compiler plugin: 3.8.0
surefire and failsafe:2.22.0



Java 12 features
1. Compact Number Format 
     - Compact number formatting refers to the representation of a number in a short or human readable form
     - For eg, 1000 can be represent as 1k, 100000 can be represent as 1L, depending on the style specified by NumberFormat.Style
     - The compact number formats are defined by LDML(Local Data Markup Language) specification
     - NumberFormat adds suppory for formatting a number in its compact form

NumberFormat fmt=NumberFormat.getCompactNumberInstance(Locale.US,Style.SHORT);
String s=fmt.format(1000);
SOP(s); //output: 1K

String s1=fmt.format(100000000);
SOP(s1); //output: 100M

String s=fmt.format(100000000000000L);
SOP(s); //output: 1OOT

String s=fmt.format(9999);
SOP(s); //output: 10K - will display the nearest value 

2.  Switch Expression
       - new form of switch statement, normally we cant return value directly from switch stmt, instead we can go for switch expr
       - Syntax:  label -> logic
       - break is not required here
       - If we want to return multiple value we can use yeild keyword
   
class Sample {  PSVM {
   String msg=perOfDailyTask("SATURDAY");
   System.out.println(msg);
}

public static String perOfDailyTask(String day) {
     String msg=null;
     msg= switch(day) {
        case "MONDAY" -> {
                      System.out.println("hii");
                      yield "A";
                      }
        case "TUESDAY" -> "B";
        case "WEDNESDAY" -> "C";
        case "THURSDAY" -> "D";
        case "FRIDAY" -> "E";
        case "SATURDAY" -> "F";
        default -> "wrong input";
        };
    return msg;
}
}
Output: F

We can have multiple case in single line 

public static String perOfDailyTask(String day) {
     String msg=null;
     msg= switch(day) {
        case "MONDAY" -> {
                      System.out.println("hii");
                      yield "A";
                      }
        case "TUESDAY","WEDNESDAY","THURSDAY" -> "B";
        case "FRIDAY" -> "E";
        case "SATURDAY" -> "F";
        default -> "wrong input";
        };
    return msg;
}


Java 13 features - https://github.com/greenlearner01/Java13/tree/master/CommandLine

1. Text Blocks
       - A text block is a multi line literal. Avoids the need for most escape sequences automatically formats the string in a predictable way 

String email="hello welcome,\n"
             + " to java \"bean\"....\n"
             + "welcome\n"
             + "hello world\n";

email="""
        hello welcome,
        to Java "bean"....
        welcome
        hello world
      """;

   String s="""
       Line 1: %s
       Line 2: %s
       Line 3
       Line 4
       """.formatted("Some value","Some other value");
   SOP(s);

  - u cannot have text block in single line
      String s="""abcejjdjd"""; 

2. Z Garbage Collector Enhancement in JKD13
      - It is about returning unused memory to the os
      - It is introduced in Java11, to enhance the performance of the application by returing the unused memory to the OS and efficiently clearing the garbage 
      - Z Garbage collector is low latency garbage collector (ie) it takes more time  
      - ZGC performs all expensive works concurrently, without stopping the execution of appl threads for more than 10ms, so 10ms is threshold or max time 

Java 14 features

https://programmingtechie.com/2020/03/20/java-14-new-features/

1. Helpful NullPointerException 
     - Whenever we write big code in java, and when this code throws NullPointerException, it can become difficlt to know from where the exception originates.
     - Gives developers control over the format when desired
     - Aims to improve the readability of NullPointerExceptions, generated by JVM, by describing which variable is null
     - By providing -XX:+ShowCodeDetailsInExceptionMessages in VM Options 

2. Pattern matching for instanceOf
      - instanceOf operator is enhanced to support pattern matching 
      - Normally when u dealing with type Object which is from java.lang package, we will cast it to our required type by checking its type using instanceof keyword, then we will cast object to our required type, then will cast the object 
      - But will pattern matching feature we dont need to cast the object explicitly, we have to provide corresponding variable along with type to instance object and the variable will bound to casted value 

Object obj="hello";

//lower version
if(obj instanceOf String) {
    String str=(String)obj;
    System.out.println(str.toUpperCase());
}

//latest version
if(obj instanceOf String str) {
    System.out.println(str.toUpperCase());
}

3. Records 
     - Eliminate verbosity in creating Java Beans - public accessor methods, constructor, equals, hashcode, toString are automatically created 
     - Records improves developer productivity by providing a compact syntax for declaring classes which act as transparent carriers for immutable data 
     - new class called record, it is final class not abstract and all of its field are final
     - The record will automatically generate the tedious constructors, getter methods, equals, hashCode, toString during compile time. No setter methods for record class 
     - So whenever we create immutable class we have to provide constructors, getter methods, equals, hashCode, toString, instead we can use record class for creating immutable class 

public class RecordDemo {
  record UserRecord(String firstName, String lastName, int userId){ }
  public static void main(String[] args){
     UserRecord u=new UserRecord("ram","kumar",1234);
     UserRecord u1=new UserRecord("ram","kumar",1234);
     System.out.println(u.firstName()); //ram
     System.out.println(u.equals(u1)); //true
  }
}

Internally if we decompile java class, compiler will provide methods related to fields provided 
   - We cant set the data as all fields are final. Inside  record we cant create instance variable but we can create static variable 

   - Compact constructors are only allowed in Records

public class Sample {
    record Person(String name, String email,String phone) {
         int number; //error instance variable
         static int num;
     Person {
         if(name==null) {
             throw new IllegalArgumentException("Name is null");
     }

     //instance method error
     /* public String name() {
                return "hello";
       } */
}
PSVM {
    Person p1=new Person("Ram","ram@gmail.com","34444");
    System.out.println(p1.name());
 }
}

  - You can add static fields, static initializer and static methods. But you cannot add instance variable.

4. Packaging tool
     - Creates Platform specific installers out of jar files, so we know installing java on machine is prerequiste whenever we want to run any java appl
     - With help of JPackage, no need to install Java on client machine to run any Java appl
     - JPackage tool to package java appl into a platform specific package 
     - To execute any software we need any exe file and exe file will be executed in windows. In Java we have java and class files and we package into jar file and those jar file will be executed only in Java env.
     - Any client who dont have java software cannot execute those jar files 
     - Now java came with new packaging tool called JPackage so that we can convert our jar files into env specific. For MacOS, we can convert jar file into pkg and dmg file so that it can install in client machine. In windows we can convert jar file into msi or exe file and in linux as deb and rpm file 

1. Create java project with simple java program
2. Create executable jar file
   src>jar -cfe Sample.jar com.pack.Sample com/pack/*.class
3. copy the jar file inside another folder and in that we create exe file
3. Install Wix(Windows Installer XML tool) 3.0 from wixtoolset.org wix311-binaries
set wix311-binaries path in env variable
4. Use JPackage tool 
newfolder>jpackage --input . --name SampleApp --main-jar Sample.jar --main-class com.pack.Sample --type exe --java-options '--enable-preview' --win-shortcut
5. Install into exe and check how it is working


5. Text blocks 
   - Which is released as preview feature for 2nd time, it was originally introduced in Java 13
   - With text blocks we can use multi line string in java without using string concatention
   - When u want to store any HTML, JS and SQL code inside string in Java,we want to manually use string concatentation to construct them. With Text blocks we can just multiline string with """ and indentation of string is preseved by Java
   - Change in Java14 is we can add trailing (\) in one of line inside multi line string which tells the Java compiler to ignore the next coming line break

public class Sample { PSVM  {
   String html="<html>\n" +
               "  <body>\n" +
               "    <p>Hello world</p>\n"+
               "  </body>\n" +
               "</html>";
   String java13="""
                <html>
                   <body>
                      <p>Hello world</p>
                   </body>
                </html>""";
   String java14="""
                  <html>
                   <body>\
                      <p>Hello world</p>\
                   </body>
                </html>""";
System.out.println("Before Java 13");
System.out.println(html);
System.out.println("From Java 13");
System.out.println(java13);
System.out.println("From Java 14");
System.out.println(java14);
}}

Output:
Before Java 13
 <html>
    <body>
       <p>Hello world</p>
    </body>
 </html>

From Java 13
 <html>
    <body>
       <p>Hello world</p>
    </body>
 </html>

From Java 14
 <html>
    <body> <p>Hello world</p> </body>
 </html>


6. General JVM Improvements

1. G1 Garbage collector Improvements
       - Default garbage collector in Java which was introduced in Java9 
       - In Java14, this GC has been made NUMA aware(Non uniform memory access)
       - Goal is to improve performance of GC over lareg machines
       - Can be enabled by -XX+UseNUMA flag

2. Z Garbage Collector
      - Introduced in Java11 and in Java14, the pause time of GC is reduced to under 10ms. This was originally available only for Linux but with Java14 their ports avialable for Mac and windows 

3. CMS(Concurrent Mark Sweep) GC completely removed from Java14 




Java Mission Control 
https://github.com/cameronmcnz/Java-Mission-Control-Tutorial/tree/main/projects

1. Mission Control Plugin in Eclipse
       - If ur in eclipse, only plugin u can install is version 6 which is oracles which requires a commercial license. So we use open source AdoptOpenJDK plugin installed so u dont need that commercial license at all.
     In Eclipse Market Place, we can search Java Mission Control, but it is license version. So we get the latest version of JMC which build it from OpenJDK. 

1. Goto https://github.com/openjdk/jmc and try to clone to the jmc repo inside a folder
2. folder> git clone https://github.com/openjdk/jmc.git
    It created a folder jmc
3. Goto jmc/releng/third-party folder, where we can see bunch of third party lib that u need to build in order to get Java Mission Control and Java Flight Recorder plugin working
    Open gitbash inside third-party folder 
thirdparty>mvn p2:site
   - Which will set up whole website that going to host a maven repo with all these third party libraries.
    
4. After build success, Now hosts this site on jetty 
thirdparty>mvn jetty:run
This is all configured to host maven repo on localhost:8080 which is going to give the core build of JMC JFR eclipse plug-in access to the 3rd party libraries that it needs
    Let the prompt runs on Jetty server

5. Now go to jmc/core folder and open gitbash and need to build again
jmc/core> mvn clean install
    - compiles the code, run some test and then package all of the core stuff into appropriate jar file 

6. Now in same gitbash go to jmc folder
jmc/core>cd..
jmc> mvn package
    - So everything build in previous maven install will package it up into various jar files, one of jar file is java flight recorder maven plugin 

7. Once build sucess, under jmc folder we can see the folder called application.
  Inside that goto org.openjdk.jmc.updatesite.ide/target/ we can see the plugin for Java flight recorder
  org.openjdk.jmc.updatesite.ide-8.0.0.SNAPSHOT.zip

8. Now we need to install that plugin in Eclipse

Goto Eclipse - Help - Install New Software - Click Add - Click Archive - select the zip file from jmc/application/org.openjdk.jmc.updatesite.ide/target/  folder
  - Click Add - Select all checkboxes 
  - Click Next - Accept the agreement - Click Finish 
  - Restart eclipse ide

9. In eclipse we can see Java Mission Control icon in top
Under Local - Select Jetty server running - Start Flight Recording - click Finish 

localhost:8080/site/ - to see all available server running 

Which open Flight recording in that we can select memory, garbage collection , Threads(all class loading the thread that were in use and were blocked the memory the file socket, io etc)

2. Java Mission Control Overview
     We going to download it and install it and show you how to connect to an existing JVM and then do a Java Flight Recorder and take a look at some of the memory used and some of the cpu usage 
    To work with JMC u have to download it, it dosent come packaged with JDK anymore. 

1. Goto https://adoptopenjdk.net/jmc.html and download 
org.openjdk.jmc-8.0.0-win32.win32.x86_64.zip
    Extract it - Inside client jmc.exe file to start JMC
   Once started,it will load all the JVM's which is running on my local system, one of which is Jetty server which is already running.
   Under JVM browsing Tab we can see jvms running on the machine, under that we select Jetty server, under that we can see MBean Server and Flight Recorder
   Mbean server gives feedback on how your jvm is running right now, we got jetty server as we already running jetty server 
   Now if we refresh localhost:8080/site/, we can see needle moving as increase in memory 

2. Now we do flight recording
Right click Flight Recorder - Start Flight Recording - Finish 
    It gathers bunch of info about this jvm hosting, when u click refresh on jetty server we can see some sort of load and number of megs being used is increasing. This is MBean server this is giving us some live feedback on howour jvm is behaving. We will get JMC report once flight recorder is completed
   This will show information about the threads, memory, garbage collection all sorts of info about just what happened during that run. You can see little bit of cpu peaking  


3 ways to Start Java Flight Recorder in Eclipse

First way:
1. Configure DoSomething project in eclipse
2. Right click project - Run as Java application
3. Goto JVM Browser tab - Right click Flight Recorder - Start Flight Recording 
   Recording Time: 10s - Click Finish
4. Once recording is compelted, it show the result in JMC which provide info abt memory, abt thread and in Automated Analyse Result it show the completed result 
   Under Environment - Click ^ - we can see the number of completing resources running on my computer  

Second way:
1. In the same project we can provide Launchers, in that we use DoNothing Auto Record.launch, in this launcher we set some JVM arguments like flight recorder arguments
    We specify that the recordings starts after 5sec delay and 20s duration and the file would be saved in DoNothing folder 
2. Run as Java Application - Select Launcher - click ok
    It will start the recording for 20s duration, once complete, u just refresh the project 
    You can see the recording file, just double click it will open automated analysis of that appl with threads, memory and with feedback 

Third way:
1. Right click project - Run as Java application
2. Goto package of DoSomething.java - Right click package - show in local terminal 
  > jcmd 
which displays process id of that appl

>jcmd 1886 JFR.start duration=10s filename=recording.jfr 

It will take 10s to create the recording. Once done, just refresh the project, u can see the recording. Just double click the recording which generates the flight recording of the application.

LinkedList vs HashSet Performance Problem in JMC 
    - Here we see difference between LinkedList and HashSet when we have large number of elements in Java Collection. Now we see difference in performance between a linked list versus HashSet by using example

http://missioncontrol.mcnz.com/2020/12/10/Java_LinkedList_vs_HashSet_Performance.html

public class HotJavaMethodRunner implements Runnable {
	
	private static final int NUMBER_OF_THREADS = 8;

	public static void main(String[] args) throws Exception {
		ThreadGroup threadGroup = new ThreadGroup("Workers");
		Thread[] threads = new Thread[NUMBER_OF_THREADS];
		for (int i = 0; i < threads.length; i++) {
			threads[i] = new Thread(threadGroup, new HotJavaMethodRunner(), "Worker Thread " + i);
			threads[i].setDaemon(true);
			threads[i].start();
		}
		System.out.print("Press enter to quit!");
		System.out.flush();
		System.in.read();
	}
	
	public void run() {
		while (true) {
			WorkEvent event = new WorkEvent();
			Collection<Integer> firstBunch = new LinkedList<>();
			Collection<Integer> secondBunch = new LinkedList<>();
			
			//Collection<Integer> firstBunch = new HashSet<>();
			//Collection<Integer> secondBunch = new HashSet<>();
			
			event.begin();
			
			initialize(firstBunch, 3);
			initialize(secondBunch, 2);
			int intersectionSize = countMatches(firstBunch, secondBunch);
			
			event.setIntersectionSize(intersectionSize);
			event.commit();
			Thread.yield();
		}
	}
	
	public void initialize(Collection<Integer> collection, int modulus) {
		collection.clear();
		for (int i = 1; i < 100000; i++) {
			if ((i % modulus) != 0)
				collection.add(i);
		}
	}
	
	public int countMatches(Collection<Integer> first, Collection<Integer> second) {
		int count = 0;
		for (Integer i : first) {
			if (second.contains(i)) {
				count++;
			}
		}
		System.out.println(count);
		return count;
	}
	
}


1. In the above example we create 2 collection firstBunch and secondBunch which contains collection of Integers. FirstBunch is numbers from 1 to 100000 and mod by 3 and secondbunch is between 1 to 100000 and mod by 2 using initialize() method
   Once we got those two collection of numbers that are linkedlist initialized,we want to find the intersection (ie) how many numbers are same between first list and second list using countMatches()
    This example causes lot of computation and we are going to run this with JFR and take a look at how cpu and memory behaves. This kicks off 8 threads in my example and every time a thread kicks off we create a new work event 

import jdk.jfr.*;

@Label("Work")
@Category("02_JFR_HotMethods")
@Description("Data from one loop run in the worker thread")
public class WorkEvent extends jdk.jfr.Event {
	@Label("Intersection Size")
	@Description("The number of values that were the same in the two collections")
	private int intersectionSize;

	public int getIntersectionSize() {
		return intersectionSize;
	}

	public void setIntersectionSize(int intersectionSize) {
		this.intersectionSize = intersectionSize;
	}
}


We created a work called "Work", we started at the beginning of run() as event.begin() and we terminate at the end, this will keep track of how long it takes to actually run all of these  methods

2. Run the main class, we have Launcher confgiured here which will automatically run JFR and we made recording to save inside Recording folder, just refresh u can see  the recording 
  You click the recording and u can see it displays 

3. Instead of LinkedList we use HashSet. In linkedlist the larger the list is more difficult it is to process and bigger the performance implication. Hashset tends to have linear performace
Collection<Integer> firstBunch = new HashSet<>();
Collection<Integer> secondBunch = new HashSet<>();

4. Run the application, now u can see it was taking very less time to process compare to LinkedList 
   Now look at flight recorder in Recording folder, now it says high CPU load because my threads are running so quickly 





Soap UI
   - It is open source tool to perform any kind of API testing related to SOAP request as well as RETS request 
   - SOAP is used by large cooperation like Apple, Microsoft, Cisco, Oracle, HP, NASA, ebay, MasterCard, Intel, FedEx etc, so SOAP is basically made for large enterprise appl
   - It basically provides an easy interface and provides couple of drag and drop operations which will definitely help to create any kind of API, collection of worl with api testing
   - It is preferred for both SOAP and REST api 
   - SOAP Ui is a  heavy full fledged tool providing facility of data driven testing, since it supports programming language like Groovy  where u have more leverage over the tool
   - If u r not starter or u have advance level of knowledge expecially related to apis definitely go with SOAP UI and again totally depend on ur company level

Postman
   - It is not api testing tool, it is api development suite and it provides lot of different features like sharing your collection(set of apis), performing api testing, monitoring, documentation  of apis 
   - Easy for sharing reports, it is not made for large appl, it is considered to be work only with rest apis most of the time, but it will support soap request also in postman 
   - Postman is mostly made for small based companies 

			SoapUI			Postman
1. REST API testing	  yes			   yes
2. Soap API Testing	  yes			   no
3. Scripting lang	Groovy,js           Javascript


SoapUI 

What is SOAPUI?
   - API Testing Tool
   - For manual and automation testing of SOAP and REST APIs
   - Cross-platform tool
   - Built entirely over Java platform
   - uses Swing for GUI

Why to use SoapUI
1. To create quick and efficient API tests
2. To create API functional, performance and security tests
3. To create API Testing automation framework


Downloads and Installation
1. https://www.soapui.org/downloads/latest-release/
   - Download SOAP UI Open scource
2. create empty project
3. Right click project - Click New Rest Service From URI
4. Under URI: http://thomas-bayer.com/sqlrest/CUSTOMER/10
   Click OK
We can see Request Editor and Response editor
5. Click Run (green color icon) - we can see the response on response editor, where we can see response in xml, json and html format 
6. In the down we can see log section 


OCP - 1Z0-819 

To create jar file 
   >jar -cvf myFile.jar

To run Jar file
   >java -cp ".;c:\folder\myFile.jar" Animal(mainclass name)


package packagea;
public class ClassA{

}

package packageb;
import packagea.ClassA;
public class ClassB{
   PSVM(){
     ClassA a;
     System.out.println("Got it");
   }
}

>mkdir classes
   - create classes folder

>javac -d classes packagea/ClassA.java packageb/ClassB.java
   -Move class file to classes folder

To run :
>java -cp classes packageb.ClassB
           or
>java -classpath classes packageb.ClassB
           or
>java --class-path classes packageb.ClassB


Options u need to know for exam while compile:  javac

Option		          Description
1. -cp               Location of classes needed to --classpath compile
--class-path

2. -d <dirname>      Directory to place generated class file

3. -m <modulename>   Module name to compile
--module <name>

4. -p <path>         Location of jars in module prg
--module-path <path>

5. --module-source-path   Specify the location of module source files


Options u need to know for exam while running: java

Option 				Description
1. -cp <classpath>       Location of classes needed to run the program
-classpath <classpath>
--class-path <classpath>

2. -p <path>        Location of Jars in modular prg
--module-path <path>

3. -m <name>        Module name to run
--module <name>

4. -d              Describe the details of a module
--descrobe-module

5.--list-modules   List observable modules without running the program

6.--show-module-resolution      Shows module when running program


Option u need to know for exam for archieving: jar

Option 				Description
1. -c                 Create new JAR file
  --create

2. -v		      Prints details when working with jar
   --verbose

3. -f <filename>           JAR filename
--file <filename>

4. -C <directory>        Directory containing files to be used to create JAR

5. -d               Describe the details of module
--describe-module


Stack - methods, local variable, reference variables
Heap - Object, string pool


We can store char in any datatype

Datatype:

boolean b1=true;  

byte b=1;
b='a';  //97

short s=1;
s='a';
s=b;
b=s;   //error

int i=1;
i='a';
i=b;
i=s;
b=i;  //error
s=i;  //error


8E2 * 0 + 8E1 * 1 + 7E1 * 1
64 * 0 + 8 * 1 + 7 * 1 = 15

Literal and Underscore character
   Add underscore except
  1. at the beginning of literal
  2. end of literal
  3. right before decimal point 
  4. right after decimal point

int million=1_000_000; //1000000
int million=_1000.00;  //error
int million=1000.00_;  //error
int million=1000_.00;  //error
int million=1000._00;  //error
int million=1_00_0.0_0;  //1000.0

Identifier
    - name of variable, method, class, interface, pkg
    - must begin with letter, $ or _
    - Include numbers but not start with them
    - single underscore is not allowed
    - no keyword
    - Method and variable names are written in camelCase with first letter in lowercase
    - Class and interface are written with CamelCase
    - Constant, enum,static, final are capitial case

long l1=1;
l1=2147483648l;
l1='a';

float f=1;
f=2147483648L;  //2.14748365E9
f=3.14f;
f='a';

double d=1;
d=2147483648L;   //2.14748365E9
d=3.14f;
d=3.14;
d='a';

char c='a';
c=1;


Autoboxing - convert primitive to wrapper class
Unboxing - convert wrapper class to primitive

Order of Precedence
POST
PRE
Unary
Multi Div
Add Sub
Shift Relational Equalto Logical Shortcirucit Ternary Assignment

public class Primitive {

    //autoboxing in primitive types is allowed in literals
    long primitive() {
        boolean bo = true; //false

        byte b = (byte) 1;
        b = (short) 1;
        b = 1;//int (-128 to 127)
        b = (int) 1L;
        b = (int) 1.2345f;
        b = (int) 1.245;
        b = 'a'; //97

        short s = (byte) 1;
        s = (short) 1;
        s = 1; //int (-32,768 to 32,767)
        s = (int) 1L;
        s = (int) 1.2345f;
        s = (int) 1.245;
        s = 'a';

        s = b;
//        b = s;

        int i = (byte) 1;
        i = (short) 1;
        i = 1; //(-2,147,483,648 to 2,147,483,647)
        i = (int) 1L;
        i = (int) 1.2345f;
        i = (int) 1.245;
        i = 'a';

        i = b;
        i = s;
//        b = i;
//        s = i;

        long lo = (byte) 1;
        lo = (short) 1;
        lo = 1;
        lo = 2147483648L;
        lo = (long) 3.14f;
        lo = (long) 3.14;
        lo = 'a';

        float f = (byte) 1;
        f = (short) 1;
        f = 1;
        f = 2147483648L;//2.14748365E9
        f = 3.14f;
        f = (float) 3.14;
        f = 'a';

        double d = (byte) 1;
        d = (short) 1;
        d = 1;
        d = 2147483648L;//2.14748365E9
        d = 3.14f;
        d = 3.14; //double
        d = 'a';

        char c = 'a'; //97
        c = (byte) 1;
        c = (short) 1;
        c = 1; //int (0 to 65,535)
        c = (short) 1L;
        c = (short) 3.14f;
        c = (short) 3.14;
        return 1L;
    }

    public Long wrapper() {
        Boolean bo = false; //Autoboxing
        boolean boo = Boolean.valueOf(true); //unboxing

        //Before Java 5.0
        bo = Boolean.valueOf(true);
        bo = Boolean.valueOf("FALSE");

        boo = Boolean.parseBoolean("false");

        Byte b = (byte) 1;
        b = (short) 1;
        b = 1; //int
        b = (byte) 1L;
        b = (short) 1.2345f;
        b = (int) 1.245;
        b = 'a';

        Short s = (byte) 1;
        s = (short) 1;
        s = 1;
        s = (int) 1L;
        s = (int) 1.2345f;
        s = (int) 1.245;
        s = 'a';

        Integer i = 1;
        i = (int) 1L;
        i = (int) 1.2345f;
        i = (int) 1.245;
        i = (int) 'a';

        Long lo = (long) 1;
        lo = 1L;
        lo = (long) 3.14f;
        lo = (long) 3.14;
        lo = (long) 'a';

        Float f = (float) 1;
        f = 3.14f;
        f = (float) 2147483648L;//2.14748365E9
        f = (float) 3.14;
        f = (float)'a';

        Double d = (double)1;
        d = (double) 1L;
        d = (double)3.14f;
        d = 3.14;
        d = (double)'a';

        Character c = 'a';
        c = 1; //int (0 to 65,535)
        c = (int)1;
        c = (byte) 1L;
        c = (short) 3.14f;
        c = (char) 3.14;

        return 1L;
    }
}

boolean monkey = true == 3; //error
boolean ape = false != "Grape";  //error
boolean a = 10.2 == "koko"; //error


String and StringBuilder

https://github.com/mhussainshah1/HandleStrings/blob/master/StringPool.jsh

String Pool - intern pool
    There are 2 parts of memory, stack and heap. Stack is part of memory which loads the method data in form of stack one on the other 
    So first method load in stack is main(), in main() if we initialize any local variable or make any object, then local variable will go to stack and object in heap
    Consider we have 3 string objects like
String name="Fluffy";
String name1="Fluffy";
String name2=new String("Fluffy");

       Stack                                 Heap
      100 - name                                          String Pool
      100 - name1                  Object                 100 - Fluffy
      201 - name2                  201 - 100

100,201 - memory address
   So object reference name  will stay in stack and value will store in heap 
   So whenever we create string without  new keyword it goes in the string pool and string pool is a location in JVM contains reusable literal values and constants for fast memory processing.
       String name="Fluffy";
       String name1="Fluffy";
   So benefit of this if we make another string object and it has same value so instead of creating a new object it goes and check the string pool, if it is there then it provides the memory address to this reference, so both these objects point to same location in the memory 

  String name2=new String("Fluffy");
     So whenever we use a new keyword, compiler creates an new object in the memory for name2 and it first checks the string pool and if that string value is present it  copy the address of that string in that object as value and provide its memory address to the reference variable in the stack.

String name="Fluffy";
String name1="Fluffy";
String name2=new String("Fluffy");
name == name1;  //true
name == name2; //false

But at time of concatentation, consider we have

String  name3="Fluf"+"fy";
String name4="Fluf";
name4 += "fy";

So name3 and name4 will have same string "Fluffy" but one is pointing to String pool and other created the object.
   name3 is determine at the compile time, the complete string is "Fluffy" and stored in string pool as address 100 will be stored (ie) to name.
   But for name4, first time it is Fluf and Fluf goes to string pool, then we added "fy" and store back to name4 which is same like calling concat() which return string, so whenever we call a method so it creates a new object so name4 is not same because name4 created new object rather than going to string pool

String name3="Fluf"+"fy";
String name4="Fluf";
name4 += "fy";
name==name3; //true
name==name4; //false

String x="Hello World";
String y=" Hello World".trim();
x==y; //false
   Because first x will store in string pool and y is called with trim() so it create new object so it refers different object 


String s1="hello world";
String s2=new String("hello world");
s2=s2.intern(); //hello world, because it checks with string pool whether value already present so it copy the address of that value

s1==s2; //true

String s3="rat"+1;  //rat1 stored in string pool
String s4="r"+"a"+"t"+"1"; //rat1 stored in string pool
String s5="r"+"a"+"t"+new String("1"); //rat1 but new object created

s3==s4; //true
s3==s4.intern(); //true
s3==s5; //false
s3==s5.intern(); //true


Local Variable Type Inference - Var
    - It introduced in Java10 and purpose is to infer datatype at compile time. We can only use them in constructor, method and initializer block 
    - var is keyword used as local variable in constructor, method, initializer block, loops. The value of var can change but type cannot change 
    - var will check the value and assign the related datatype

Important notes:
    1. var can't declare without initial value. It is always initialized on same line or statment where it is declared
    2. var can be declared in first like and initialized in next line, because it is compile of two lines however it is 1 statement 
    3. var cannot be initialized with null value without a type 
    4. var is not permitted in multiple variable declartion
    5. var cannot be used to initialize array

public class Main {
    {
        var num = 1.0;
    }
    Main(){
        var name = "Main";
    }
    public static void main(String[] args) {
       var size = 7;

       for (var i = 0; i < 10; i++) {

       }

        for (var arg: args) {

        }

        size = 4;
       //size = "five"; //error we cant change its datatype

        //Can't do
        //1. Same line
//        var question;
/*        question =1;
        var answer;
        if(size == 4){
            answer = 2;
        } else {
            answer =3;
        }*/

        //Note 2
        var silly
                = 1;


        //Note 3
        //var n = null;  //error
        var o = (String) null;    //here we specify type before null

        var n = "my string";
        n = null;

        var m = 4;
        //m = null;  //error

        //Note 4 Compound Declaration
//        var a = 2 , b = 3;
//        int a, var b =3;

        //Note 5 Array
//        var prices = {9.95, 8.86};
    }
}


    6. var cant be used in parameters, return type and fields

public class VarKeyword {
/*    var name = "Hello";
    static var counter =0; //error
    public VarKeyword(var name) {  //error
        this.name = name;
    }
    public var getName() {  //error
        return name;
    }
    public var setName(var name) { //error
        this.name = name;
    }*/
}

    7. var is reserved type name but not reserved word (ie) it can used as an identifier except as a class interface or enum name
public class Var {
    public void var(){
        var var = "var";
    }
    public void Var(){
        Var var = new Var();
    }
}

/*class var{}
interface var{}
enum var{}*/

Important Points

1. Choose a variable name that provides useful information

public class Guideline1 {
    public static void main(String[] args) {
        List<String> result = List.of("hello", "how", "are", "you", "?");

        var stringsList = List.of("hello", "how", "are", "you", "?");

    }
}

2. Minimize the scope of local variable 

3. Consider var when the initializer provides sufficient information, so  here in below example right side provide sufficient information 

public class Guideline3 {
    public static void main(String[] args) throws IOException {
        var outputStream = new ByteArrayOutputStream();
        var reader = Files.newBufferedReader(Path.of(""));
        var list = List.of("a", "b", "c");

    }
}

4. Consider var to split chained or nested expression

 List<String> strings = List.of("hello", "hello", "how", "are", "you", "?");

    public Optional<String> getMaxEntry() {
        return strings.stream()
          .collect(groupingBy(s -> s, counting()))
                .entrySet()
                .stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey);


public class Guideline4 {
    List<String> strings = List.of("hello", "hello", "how", "are", "you", "?");

    public Optional<String> getMaxEntry() {
        var collect = strings.stream()
                .collect(groupingBy(s -> s, counting()));
        var max = collect
                .entrySet()
                .stream()
                .max(Map.Entry.comparingByValue());
        return max
                .map(Map.Entry::getKey);


    }
}

5. Do not worry too much programming to the interface with local variable 

public class Guideline5 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list = new CopyOnWriteArrayList<>();
        list = new LinkedList<>();

        var list1 = new ArrayList<>();
//        list1 = new CopyOnWriteArrayList<>();
//        list1 = new LinkedList<>();
    }
}

6. Take care using var with diamond or generic methods 

public class Guideline6 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();

        var list1 = new ArrayList<>();//since we didnt give it ArrayList<Object>()
        var list2 = new ArrayList<String>();

        var list3 = new ArrayList<>(list);//since we pass list which is ArrayList<String>(), so list3 is ArrayList<String>()
    }
}

7.Take care var with literals 

public class Guideline7 {
    public static void main(String[] args) {
        //No issue with Boolean, character, long, String and Floating Point
        var ready = true;//boolean
        var ch = '\ufffd';//char
        var sum = 0L;//long
        var label = "wombat";//String
        var f1 = 1.0f;//float
        var d1 = 3.0;//double

        //Whole number inferred as integer
        byte flags = 0;
        short mask = 0x7fff;
        long base = 17;

        var flags1 = 0; //int
        var mask1 = 0x7fff;//int
        var base1 = 17;//int

        var flags2 = (byte)0; //byte
        var mask2 = (short)0x7fff;//short
        var base2 = (long)17;//long
    }
}

var in Lambda Expression 
    - Lambda expr can also be implicitly typed with var syntax
           (var num) -> num+1;

public class LambdaExpression {
    public static void main(String[] args) {
        Function<Integer,Integer> f = (var num) -> 1;

//        var f1 = (var num) -> 1;

        BiFunction<Integer,Integer,String> f2 = (@Notnull var a,var b) -> "Hello";
    }
}
    - var can be used with annotation 
           (@NotNull var a,var b) -> a+b;
    - var can be used for non-denotable (anonymous class and intersection)

public class NonDenotable {
    public static void main(String[] args) {
        //Anonymous Class
        var productInfo = new Object() {
            String name = "Apple";
            int total = 0;
        };
        System.out.println("name = " + productInfo.name + ", total = " + productInfo.total);

}}

Cant do
1. you cant mix var and non var parameters
        (var a,Integer b)-> true;  //error
        (var a,var b)-> true; //correct
        (String x,var y,Integer z)->true; //error
        (var x,var y,var z)->3.14159; //correct

2. you cant mix var and explicit type parameters
        (var x, y) -> "goodbye"; //error
3. you cant omit parenthesis for single var parameter
        var w-> 99;  //error


Lambda Expression and Functional programming

Deferred Execution - in lambda object will not be created unless we call the implementation of method


Anonymous class			                 Lambda
1. It is an inner class                     1. Lambda is static 
It has an instance in memory                method in memory

2. keyword this represent inner             2. keyword this 
anonymous class                                represent enclosing class

3. It can have more than                    3. only one method
one method 

public class ConvenienceMethod {
    public static void main(String[] args) {
        //Predicate
        Predicate<String> egg = str -> str.contains("egg");
        Predicate<String> brown = str -> str.contains("brown");

//        Predicate<String> brownEggs = str -> str.contains("egg") && str.contains("brown");
        Predicate<String> brownEggs = egg.and(brown);
        System.out.println(brownEggs.test("eggbrown"));

//        Predicate<String> otherEggs = str -> str.contains("egg") && !str.contains("brown");
        Predicate<String> otherEggs = egg.and(brown.negate());

        //Consumer
        Consumer<String> c1 = x -> System.out.print("1: " + x);
        Consumer<String> c2 = x -> System.out.println(",2: " + x);
        Consumer<String> combined = c1.andThen(c2);
        combined.accept("Annie");

        //Function
        Function<Integer, Integer> before = x -> x + 1;
        Function<Integer, Integer> after = x -> x * 2;
        Function<Integer, Integer> combined2 = after.andThen(before);
        System.out.println(combined2.apply(3));//( 3 x 2) +1 = 7

        combined2 = after.compose(before);
        System.out.println(combined2.apply(3));//(3 + 1) x 2 = 8
    }
}


Variable in lambda expression

1. Parameter list

What is type of x in below code?

Predicate<String> p=x->true;   //string
---------------------------------------------------
public void whatAmI(){
   test((var x)->x>2,123);   //x is integer
}
public void test(Predicate<Integer> c,int num){
   c.test(num);
}
---------------------------------------------------
public void counts(List<Integer> list){
   list.sort((var x,var y)->x.compareTo(y));  //x is integer
}


2. Local variable inside lambda body
       Cannot create a local variable with the same name as one already declared in scope

(a,b) -> { int c=0; return 5;}  //correct
(a,b) -> { int a=0; return 5;}  //error

public void variables(int a){   //error 
    int b=1;
   Predicate<Integer> p1=a->{
             int b=0;
             int c=0;
             return b==c;};
}

3. Variable Reference from Lambda body
    Rules for accessing a variable from a lambda body inside a method

Variable Type				Rule
Instance Variable			Allowed
Static variable 			Allowed
Local variable			Allowed if effectively final
Method parameter                Allowed if effectively final
Lambda parameter		        Allowed

Effectively final - value cannot change and dont need to explicitly declare final

public class Closure {
    private static String staticVariable;
    private String instanceVariable;

    public void instanceMethod(final String parameter) {
        final String localVariable = "local";
        staticVariable ="allowed";

        Predicate<String> p = str -> (instanceVariable + parameter + localVariable + staticVariable).length() == 10;

//        parameter ="not allowed";
//        localVariable ="not allowed";

        staticVariable ="allowed";
        instanceVariable ="allowed";
    }
}


Optional class

public class MyOptional {

    public static Optional<Double> average(int... scores) {
        if (scores.length == 0)
            return Optional.empty();

        int sum = 0;
        for (int score : scores) {
            sum += score;
        }
        return Optional.of((double) sum / scores.length);
    }

    public static void main(String[] args) {
        System.out.println(average(90, 100));
        System.out.println(average());

        Optional<Double> opt = average(90, 100);
        if (opt.isPresent())
            System.out.println(opt.get());

        //or
        opt.ifPresent(System.out::println);

        opt = average();
//        System.out.println(opt.get());//NoSuchElementException

        String value = "";
        Optional o = (value == null) ? Optional.empty() : Optional.of(value);
        //or
        o = Optional.ofNullable(value);

        opt = average();
        System.out.println(opt.orElse(Double.NaN));
        System.out.println(opt.orElseGet(Math::random));// () -> Math.random()
//        System.out.println(opt.orElseThrow());//NoSuchElementException
//        System.out.println(opt.orElseThrow(IllegalAccessError::new));//() -> new IllegalAccessError()
//        System.out.println(opt.orElseGet(IllegalStateException::new));//Does not compile

        opt = average(90, 100);
        System.out.println(opt.orElse(Double.NaN));
        System.out.println(opt.orElseGet(Math::random));
        System.out.println(opt.orElseThrow());
    }
}


Stream API
    Sequence of data, it can be used only once
Types:  Finite and infinite

Lazy evaluation: delay execution until necessary - we pass lambda expr/method reference in the function and processor calls the method at its own

https://www.rapid7.com/blog/post/2017/01/13/java-8-lazy-argument-evaluation/

public class EagerVsLazyEvaluation {

    static boolean compute(String str) {
        System.out.println("executing...");
        // expensive computation here
        return str.contains("a");
    }

    static String eagerMatch(boolean b1, boolean b2) {
        return b1 && b2 ? "match" : "incompatible!";
    }

    static String lazyMatch(Supplier<Boolean> a, Supplier<Boolean> b) {
        return a.get() && b.get() ? "match" : "incompatible!";
        //call function here - if first part returns false then other doesn`t execute
    }

    public static void main(String[] args) {
        System.out.println(eagerMatch(compute("bb"), compute("aa")));//call function
        System.out.println(lazyMatch(() -> compute("bb"), () -> compute("aa")));
    }
}

When we call eagerMatch() it prints 
executing...
executing...
incompatible!
But when we call lazyMatch() it prints
executing...
incompatible!

When it comes to lazyMatch(), we call a.get() goes to compute() and get false and && which is short circuit operator, so if one is false it wont execute the next one. So in eagerMatch() we have 2 method calls but in lazyMatch() it is 1 method call  and it happens only at execution 

Intermediate vs Terminal operation
Scenario		Intermediate     Terminal
1. can exist multiple	    yes		    no
times in pipeline

2. Return type is stream    yes	 	    no

3. Executed upon method     no              yes
call

4. Stream valid after       yes             no
call


Advanced Stream Pipeline Concept

1. Linking streams to the underlying data

public class Linking {
    public static void main(String[] args) {
        var cats = new ArrayList<String>();
        cats.add("Annie");
        cats.add("Ripley");

        var stream = cats.stream();
        cats.add("KC");
        System.out.println(stream.count());
    }
}

2. Chaining Optional - calls one optional to another optional 

public class ChainingOptionals {
    public static void main(String[] args) {
        threeDigit_Java7(Optional.empty());
        threeDigit_Java7(Optional.of(4));
        threeDigit_Java7(Optional.of(123));

        threeDigit_Java8(Optional.empty());
        threeDigit_Java8(Optional.of(4));
        threeDigit_Java8(Optional.of(123));

        Optional<String> optional = Optional.of("123");
        Optional<Integer> result = optional.map(String::length);
        System.out.println(result.get());

        Optional<Optional<Integer>> result1 = optional.map(ChainingOptionals::calculator);
        System.out.println(result1.get().get());

        Optional<Integer> result2 = optional.flatMap(ChainingOptionals::calculator);
        System.out.println(result2.get());
    }

    private static Optional<Integer> calculator(String s) {
        return Optional.of(s.length());
    }

    private static void threeDigit_Java8(Optional<Integer> optional) {
        optional.map(n -> "" + n)
                .filter(s -> s.length() == 3)
                .ifPresent(System.out::println);
    }

    private static void threeDigit_Java7(Optional<Integer> optional) {
        if (optional.isPresent()) {
            Integer num = optional.get();
            String string = "" + num;
            if (string.length() == 3) {
                System.out.println(string);
            }
        }
    }
}

3. Collecting Results - used to group the results

1. Collecting using Basic Collectors
public class CollectingCollectors {
    public static void main(String[] args) {
        String result = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.joining(","));
        System.out.println(result);

        Double results = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.averagingInt(String::length));
        System.out.println(results);

        Set<String> result1 = Stream.of("lions","toads", "tigers", "bears")
                .filter(s -> s.startsWith("t"))
                .collect(Collectors.toSet());
        System.out.println(result1);

        TreeSet<String> result2 = Stream.of("lions", "toads", "tigers", "bears")
                .filter(s -> s.startsWith("t"))
                .collect(Collectors.toCollection(TreeSet::new));
        System.out.println(result2);
    }
}

2. Collecting into Maps using toMap()
       To create map we need to specify 2 functions
1). How to create key
2). How to create value 

public class CollectingMaps {
    public static void main(String[] args) {
        Map<String, Integer> map = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.toMap(s -> s, String::length));
        System.out.println(map);

        //reverse key into values
        Map<Integer, String> map1 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.toMap(String::length, s -> s, (s1, s2) -> s1 + "," + s2));
        System.out.println(map1);
        System.out.println(map1.getClass());

        TreeMap<Integer, String> map2 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.toMap(String::length,
                        s->s,
                        (s1, s2) -> s1 + "," + s2,
                        TreeMap::new));
        System.out.println(map2);
        System.out.println(map2.getClass());
    }
}

3). Grouping - group all the elements of the stream into Map using groupingBy()
   groupingBy(Function f)
   groupingBy(Function f, Collector c)
   groupingBy(Function f, Supplier s,Collector c)

public class Grouping {
    public static void main(String[] args) {
        Map<Integer, List<String>> map = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length));
        System.out.println(map);

        Map<Integer, Set<String>> map1 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length, Collectors.toSet()));
        System.out.println(map1);

        TreeMap<Integer, Set<String>> map2 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length, TreeMap::new, Collectors.toSet()));
        System.out.println(map2);

        TreeMap<Integer, List<String>> map3 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length, TreeMap::new, Collectors.toList()));
        System.out.println(map3);
    }
}

4. Partitioning - splitting list into 2 parts - true and false
      partitioningBy(Predicate p)
      partitioningBy(Predicate p, Collector c)

public class Partitioning {
    public static void main(String[] args) {
        Map<Boolean, List<String>> map = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.partitioningBy(s -> s.length() <= 5));
        System.out.println(map);

        map = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.partitioningBy(s -> s.length() <= 7));
        System.out.println(map);

        Map<Boolean, Set<String>> map1 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.partitioningBy(s -> s.length() <= 7, Collectors.toSet()));
        System.out.println(map1);

        Map<Integer, Long> map3 = Stream.of("lions", "tigers", "bears")
                .collect(Collectors.groupingBy(String::length, Collectors.counting()));
        System.out.println(map3);

    }


Interface

1. Interface contains public static final constant variable
2. Interface contains abstract method
3. Interface contains default,static method from Java8
4. Interface contains private, private static method from Java9

public /*abstract*/ interface InterfaceSummary {
    /*public static final*/ int CONSTANT = 1;

    /*public abstract*/ int abstractMethod();

    /*public*/ default int defaultMethod(){abstractMethod(); privateMethod();staticMethod();  privateStaticMethod();return CONSTANT; }

    private int privateMethod(){abstractMethod();defaultMethod();staticMethod();privateStaticMethod();return CONSTANT;}

    /*public*/ static int staticMethod(){ privateStaticMethod(); return CONSTANT; }

    private static int privateStaticMethod(){ return CONSTANT;}

}

Instance method in interface can access static method
   - abstract
   - default
   - non static private

Class/static method in interface cant access instance method (ie) static and static private 

Interface Member access
1. Accessible from default and private methods within interface defination
    constant variable - yes
    abstract method-yes
    default method - yes
    private method - yes
    static method - yes
    private static method - yes

2. Accessible from static methods within interface defination
    constant variable - yes
    abstract method-no
    default method - no
    private method - no
    static method - yes
    private static method - yes

3. Accessible from instance methods implementing or extending the interface - Refer WithInterface.java
     constant variable - yes
    abstract method-yes
    default method - yes
    private method - no
    static method - yes
    private static method - no

4.Accessible outside interface without an instance of interface - Refer WithoutInterface.java
     constant variable - yes
    abstract method-no
    default method - no
    private method - no
    static method - yes
    private static method - no


public class WithInterface implements InterfaceSummary{
    @Override
    public int abstractMethod() {
        defaultMethod();
        InterfaceSummary.staticMethod();
        return CONSTANT;
    }
}


public class WithoutInterface {
    public int instantMethod() {
        InterfaceSummary.staticMethod();
        return InterfaceSummary.CONSTANT;
    }
}


Create and use Enumeration
     - It is type of class that mainly contains constants or fixed set of values
     - It implicitly extends from abstract class java.lang.Enum
     - It is implicitly final (ie) it cannot extend but implements interface
     - It provides type-safe checking, invalid enum value introduce compiler error


public enum Day /*implements MyInterface*/{
    SUNDAY,
    MONDAY,
    TUESDAY ,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY;
}
interface MyInterface{

}

/*public enum ExtendedEnum extends Day{
}*/


public class Main {
    public static void main(String[] args) {
        Day d = Day.TUESDAY;
        //Day d=2;  //error
        Day d1 = Day.valueOf("TUESDAY");
      // d1 = Day.valueOf("tuesday"); //compiler error because no enum tuesday

        System.out.println(d == d1);
        System.out.println(d.equals(d1));
        System.out.println(Day.SUNDAY);
        System.out.println(d.toString());

        for (Day day: Day.values() ) {
            System.out.println(day.name() + " " + day.ordinal());
        }

        /*if (Day.THURSDAY == 4){    //compiler error

       }*/
}


Important notes
1. Values are declare first
2. Values end with semicolon,if there is anything besides value show compiler error

public enum Day {
    int i=4; //compiler error

    SUNDAY,
    MONDAY,
    TUESDAY ,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY;
   
    private String temparature; //correct but previously u should end with semicolon
}

3. A non final enum method can be overridden by any enum value

public enum Day {
    int i=4; //compiler error

    SUNDAY {
      public void printTemperature(){            System.out.println(75);
    }},
    MONDAY,
    TUESDAY ,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY;
   
    private String temparature; 

    public void printTemperature(){                     System.out.println(65);
    }
}
So sunday have overridden method and rest of days have default value 

public class Main {
    public static void main(String[] args) {
       d.printTemperature();  //prints 65
       Day.SUNDAY.printTemperature(); //prints 75
    }
}

4. If we have abstract method then it should be implemented 

public enum Day {
    int i=4; //compiler error

    SUNDAY {
      public void printTemperature(){            
           System.out.println(75);
    }},
    MONDAY{
      public void printTemperature(){            
           System.out.println(65);
    }},
    TUESDAY{
      public void printTemperature(){            
           System.out.println(75);
    }} ,
    WEDNESDAY{
      public void printTemperature(){            
           System.out.println(85);
    }},
    THURSDAY{
      public void printTemperature(){            
           System.out.println(65);
    }},
    FRIDAY{
      public void printTemperature(){            
           System.out.println(75);
    }},
    SATURDAY{
      public void printTemperature(){            
           System.out.println(85);
    }};
   
    private String temparature; 

    public abstract void printTemperature();
}


Constructor
  - Implicitly private 
  - Called once in the beginning to create enum values.


public enum Day{
    SUNDAY("High"){ public void printTemperature(){ System.out.println(75); }},
    MONDAY ("Moderate"){ @Override public void printTemperature() {System.out.println(65);}},
    TUESDAY ("High"){ @Override public void printTemperature() {System.out.println(75);}},
    WEDNESDAY("High") { @Override public void printTemperature() {System.out.println(85);}},
    THURSDAY ("Moderate"){ @Override public void printTemperature() {System.out.println(65);}},
    FRIDAY ("High"){ @Override public void printTemperature() {System.out.println(75);}},
    SATURDAY ("High"){ @Override public void printTemperature() {System.out.println(85);}};

    private String temperature;

    /*private*/ Day (String temperature){
        this.temperature = temperature;
    }

    public  abstract void printTemperature();

}

5. Enum can also used in switch

switch (d){
            case SUNDAY:
                System.out.println("Go to beach");
                break;
            case MONDAY:
                System.out.println("Go back to work");
                break;
            case TUESDAY://Error- Day.TUESDAY: , 2
                System.out.println("I am at work");
                break;
            default:
                System.out.println("Are you at work?");
        }


Compiler error
   Code will not compile if 
     1. Values are not declared first
     2. Constructor contains public or protected modifier
     3. Switch block - contains case as Enum.TYPE
     4. extends an enum
     5. compare enum value with integer
