Java Versioning
    - There is new java release coming in every 6 month, this is recent development, because of this there are 2 java release every year 

1. JDK1.0 in Jan1996 and there is subsequent release of JDK 2,3,4 after that major release was JDK5

2. J2SE5.0 in sep 2004 and there are 5 releases in almost 8 years 

3. The next major release is JavaSE 8(LTS-Long Term Support) on march 2014 which is most important Java release which bought functional programming, Lambda, Streams

4. Java SE9 in sep 2017 and again 4 release in 13 yrs (from 2004 to 2017 from 5 to 9 version)

5. Java SE10 in mar 2018 which is time based release versioning which means the release will happen for every 6 months and wht are features are ready that would be the part of that specific release

8. JavaSE 11(LTS) on sep 2018
        Java11 is paid versions, only for corporate users it is paid versions and for individual development it is free version. Oracle people have given open jdk for all members and use it

https://jdk.java.net/11/ - just download and extract u get jdk-11, no need to install jre separately and set the path 
9. Java SE 12 on mar 2019 etc
10. JavaSE 16 on mar 2021

Previously there is huge difference between each Java releases however from Java 10 onwards the new features introduced are far less as it coming in every 6 months. Java prefer to use long term support release because they have support for very long time.

Java new features
1. J2SE5.0 - Enhanced forloop,Generics, Enums, Autoboxing
2. Java SE8(LTS) - Functional programming
3. Java SE9 - Modularization(Java Platform Module System)
     Where Modularization of Java is introduced, where entire JDK is now modularized into multiple modules, not only that u can also build appl in modularized way
4. Java SE10 - Local variable type Inference - variable declaration is really complex, java can automatically infer the type of local variable in Java10
5. Java SE14 - Switch expression (Preview in 12 and 13)
      - Instead using switch as statement, from java 14 we can use switch as expression
6. Java SE 15 - Text blocks(Preview in 13)
      - If we want to write complex piece of text having multiple lines with ",', escape characters in Java is very difficult and text blocks make it easier
7. Java SE16 - Record classes (Preview in 14 and 15)
      - We have created many Java beans in previous versions with getter, setter, constructor, toString, equals  etc. In Java 16 we have record classes which makes it easy to create this type of bean classes 
8. All Java versions - There are new api is introduced and almost every version of Java has performance improvements expecially in Garbage collection
    

1. List,Set,Map copyOf method

Java 10 features
1. Local Variable Type Inference
      - Declaring local variable without type
      - Whenever we declare any variable we have to provide its datatype so only Java is called statically typed language, but Angular, Python, Javascript and all is called as dynamically typed one because depending upon the value its datatype is fixed 
     - So from JDK10 we can define any variable with "var" keyword, so compiler will understand depending upon the value it will take up datatype. 
 var a=1234; - So at compile time it will infers as int
After compile time variable "a" becomes of type int
   var b="hello"; //b infers as string at compilation

Limitations
   1. Only local variable will be declared with "var"
   2. var is reserved keyword
   3. var is not allowed in method, constructor arguments, method return types
   4. We cant assign null to var type, because null is generic (ie) it can be any object 
   5. var should be with declaration and initialization
      var a = 10;  //correct

      var a;
      a=10;  //wrong

Example:
public class Sample { PSVM {
    List<String> l1=List.of("One","two");
    List<String> l2=List.of("three","four");
    
    var names=List.of(l1,l2);
    names.stream().forEach(System.out::println);
    //whatever methods avaiable in List will now available in names also. Even when we make some mistake in methods also it will show
}

   -Java compiler infers the type of the variable at compile time
   - Introduced in Java10
   - You can add final if you want, but by default it is not final 
      final var names=List.of(l1,l2);
   - var can also be used in loops
        for(var name:names)
            System.out.println(name);
   - You cannot assign to null
            var abc=null;
   - var is not a keyword
   - Improved readability for chained expression
   var filter=List.of("one","two:).stream().filter(s->s.length()<5);
      filter.forEach(System.out::println);


2. API for creating unmodifiable Collection
     - From util package there are many methods introduce to support unmodifiable collection
     - List.copyOf, Set.copyOf, Map.copyOf used to create immutable list of values from existing list or set or map which cant be changed. If map we are passing is already immutable then it will return map back, it wont create copy
     - New methods toUnmodifiableList, toUnmodifiableSet, toUnmodifiableMap have been added to the Collectors class in stream package, which allow the elements of a stream to be collected into an unmodifiable collection

List<Integer> li=Arrays.asList(1,2,4,6,8);
List<Integer> l1=List.copyOf(li); //creates immutable object
SOP(l1); //[1,2,4,6,8]
l1.add(10); //throws UnsupportedOperationException

Stream<String> s2=Stream.of("a","b","c","d");
List<String> l2=s2.collect(Collectors.toUnmodifiableList());
Set<String> s=s2.collect(Collectors.toUnmodifiableSet());

Java 11 Features  
https://www.youtube.com/watch?v=gjr92jxiEd8
    
1. JRE Updates
      - From JDK11 onwards there is no jre install in the user machines. When u install JDK, JRE was getting install in our machines. But now onwards we wont get any JRE. So JDK and JRE are together installed. 
     - JDK itself contains Java development software and JRE 
     - In windows and Mac OS, installing the JDK in previous releases optionally installed JRE, this is no longer an option. Because Java is gradually moving towards Modularization we can create modules using JLink and we can reduces the size of software and ship that software to client  
     - Mainly JRE is install in client machine and top of that Java software is installed. Using JLink we can create small packages and u can ship that one 
     - Using JPackage also we can create exe files for windows so that the software can simply install in client machine. We can make exe file from jar file and install that jar into our client machine without any JRE

    1. Upto Java10 version, we need to compile and execute the java program. From Java11 version onwards we can execute java file directly without compiling 
   > java Test.java
  Whenever we give "java Test.java" internally first compilation perform then execution will take place, so in case any compilation failed it will show error also, which is some what similar to python execution like "python Test.py"

   2. In single java program, when we provide more than one class with main method, then JVM will search for main() in the order in which we provided from top to bottom, in which class JVM identifies main() first time then JVM will treat that class as the actual main class and JVM will execute that main class

Test.java
class C { PSVM  {
   SOP("C-Main");
}}
class A { PSVM  {
   SOP("A-Main");
}}
class B { PSVM  {
   SOP("B-Main");
}}
>java Test.java
Output: C-Main

No class file will be generated, it means which class is loaded and the respective other class are compiled but not loaded in memory
   Java11 provide backward compatibility (ie) here also we can compile and execute as previous version also 

Rules:
  1. We not have .class file for this Java file inside the folder
public class Test {
   PSVM {
      SOP("Hello world");
   }
}
>java Test.java
>java -verbose Test.java
     To check complete functionality of JVM, first it will load all classes into JVM and then at last we can see our class. JVM background uses compiler to do check

  2. If main() is not present in java file it will throw error
public class Test {
   
}
>java Test.java

  If in this folder we have .class file and if we run java Test.java then it will show error, so in Java11 we need only java file should be present
   This feature provide slow execution since both compilation and execution got combined so it is not used in production env, only for beginners or new learners we can use this. 

  3. We must place main method in first class in Java, because Java11 executes from top to bottom, so main class should be first class otherwise it will show compiler error
class Test { PSVM {
   SOP("Test-Main");
}}
public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
class B {
    static void m2() {  SOP("m2"); }
}
>java Test.java
Test-Main

  4. No need to be class name and java file name to be same, even if it is public. So u can create filename any and class name any. Because java command not verifying the class and java file same or not. We given this java file going into the file and check first class contain main method or not, if it is available it will execute 

class C{ PSVM {
   SOP("C-Main");
}}
public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
class B {
    static void m2() {  SOP("m2"); }
}
>java Test.java
C-Main

  5. Even if we have multiple main method in call, no problem JVM will execute the first main method 

class C { PSVM {
   SOP("C-Main");
   A.m1();
   B.m2();
   A.main(new String[0]);
}}
public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
class B {
    static void m2() {  SOP("m2"); }
}

>java Test.java
C-Main
m1
m2
A Main

  6. Even in single program, we have multiple classes to be public
  7. In single java program, we have multiple classes but when we run it will execute only main class, other classes will not load into JVM until u call those classes, to check that
    > java -verbose Test.java
Now we can it will load only C class into JVM
[class,load] C source: __JVM Defines___
  In case, if we call A.m1() inside main(), then if we check u can see C as well as A classes will be loaded in JVM 
   In source file, we can define multiple classes then first class should contain main() to launch the class, then when u running this java file we can have multiple classes compiler will compile all classes if no mistake are there it will generate the byte code and give to JVM. JVM making all this classes store in buffer, it is not loading in memory and storing somewhere in buffer. So whichever class we are accessing that class from buffer is loading in JVM 
   Previously the buffer is nothing but .class file that it is in harddisk, whenever we access the class that time class loading from harddisk to JVM and executed. But harddisk cannot be used thats why it uses internal RAM level buffer it uses, so RAM level buffer stores all this classes bytecode whenever we access methods from the class then at that time it load class to JVM.

    8. Now we copy class A separately into another java file
Test.java
class C { PSVM {
   SOP("C-Main");
   A.m1();
   B.m2();
   A.main(new String[0]);
}}
class B {
    static void m2() {  SOP("m2"); }
}  

A.java

public class A {
   static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}

>java Test.java
    - It will show error

But we can access other program if it has a class file 
>javac A.java
   - It creates A.class
Now we can execute 
>java Test.java
    It will execute main class, but when we try to access A.m1() it will show an IllegalAccessError. So if u want to access any class outside means it should be present in a package   

package p1;
public class A {
   public static void m1() {  SOP("m1"); }
   PSVM {  SOP("A Main"); }
}
>javac -d . A.java

Test.java
class C { PSVM {
   SOP("C-Main");
   p1.A.m1();
   B.m2();
   A.main(new String[0]);
}}
class B {
    static void m2() {  SOP("m2"); }
}  

>java Test.java
C main
A m1
B m2

We cannot access another java file classes, but we can access the classes which are already compiled and has .class with package 

CommandLine argument
>java Test.java 10 20 30

2. No language translations for Java release - From JDK11 onwards java releases available only in english

3. Updated packaging format for Windows has changed from .tar.gz to .zip and for MacOS it is changed from .app to .dmg

4. JavaFx, Java Mission Control(JMC) is shipped separately
     - Previously these where part of JDK itself, JavaFx is updates related to flash works, java effects api 

5. Deployment stack for applets, webstart apps deprecated in Java9 and now it is remove from Java 11

2. Launch single file programs without compilation 
       - When new developer want to start developing a program, he have study so many thing how to compile and execute the program
       - Here developer can write simple file and execute that single file without compiling (ie) without generating .class file we can execute the program
        >java sample.java
Without giving .class file we can run our file. Here java interpreter enhanced to take the responsbility of compilation without generating .class file. So internally maintaining some stack so directly running java file and give the output 

3. java.util.Collection - toArray(intFunction)

ArrayList<String> list=new ArrayList<>();
list.add("one");
list.add("two");

list.stream().toArray(s->new String[s]); //old version

String a[]=list.toArray(size->new String[size]);
SOP(Arrays.toString(arr));

Previously we have to create stream object and pass but now we can dynamically pass some lambda expr and generate the array 

String a[]=list.toArray(String[]::new); //using method refernece
SOP(Arrays.toString(arr));

4. Local Variable syntax for Lambda parameters
      -You either define the type var on all the parameters or none

interface Example {
    int operation(int a,int b);
}

Example e=(int a,int b) -> a+b;
Example e=(var a,var b) -> a+b;

(var a,var b) -> a+b;  //correct
(var a,b) -> a+b; //wrong
(a,var b) -> a+b; //wrong
(var a,String b)-> a+b; //wrong
var a -> a; //wrong,we have to use the parenthesis

5. String API changes
      - certain enhancement in String API
isBlank() - check whether string is blank or not
lines() - based on \n extract list of strings. From multi line string if we want to extract substring of each line
strip() - removes leading and trailing spaces
stripLeading()
stripTrailing()
   In general both method removes leading and trailing spaces from string. However the difference comes when we work with unicode charaters or multilingual features.New method strip which is added in java 11 usage this Character.isWhitespace(int) method to cover wide range of white space characters and remove them.

repeat() - repeat string for particular times

Example2: 

String a=" Welcome ";
SOP(a.isBlank()); //false
String a1="    ";
SOP(a.isBlank()); //true since it emply spaces

String b= "one \n"
         + "two \n"
         + "three \n";
a.lines().forEach(System.out::println);

String c="welcome"
SOP(c.repeat(5)); //welcome will repeat 5 times


SOP(" ".isBlank()); //true
SOP(" L R ".strip().replace(" ","@")); //L@R
SOP(" L R ".stripLeadig().replace(" ","@")); //L@R@
SOP(" L R ".stripTrailing().replace(" ","@")); //@L@R
"Line1\nLine2\nLine3\nLine4".lines().forEach(System.out::println);

String string = '\u2001'+"String    with    space"+ '\u2001';
   System.out.println("Before: \"" + string+"\"");
   System.out.println("After trim: \"" + string.trim()+"\"");
   System.out.println("After strip: \"" + string.strip()+"\"");
   }
}

//take specific set of string and transform it
SOP("UPPER".transform(s->s.substring(2))); //PER

//takes string and format it
SOP("My name is %s. My age is %d.".formatted("Ram",24));

//additional info for NullPointerException
String str=null;
System.out.println(str.isBlank()); //In Java14 it gives additional info about the NPE 

Example2:
public class Sample { PSVM {
  String name="";
  sop(name.isEmpty()); //true
  String name1=" ";
  sop(name1.isEmpty()); //false
  String name2=" ";
  sop(name2.isBlank()); //true
  String name3="";
  sop(name3.isBlank());  //true

  String name4="One\nTwo";
  List<String> l=name4.lines().collect(Collectors.toList());
  sop(l);  //[one,two]

  String s="test string\u205F";
  String s1=s.strip();
  sop(s1+"*****");
  String t1=s.trim();
  sop(t1+"*****");

  String n5=" Ram Kumar ";
  sop(n5.strip()); 
  String n6=" Ram Kumar ";
  sop(n6.stripLeading()); 
  String n7=" Ram Kumar ";
  sop(n7.stripTrailing()); 
  sop(n7.repeat(4));

6. Optional.isEmpty()
       - to check whether optional class is empty or not
       - If we want to do something if value is absent, in that case we use negation. It wont make it very readable. Normally ifPresent() gives value if value is present so for negation purpose we use !ifPresent() so for that we can use isEmpty()

 
Optional o=Optional.of("hello");
o=o.empty();
o.ifPresent(s->System.out.println(s));
SOP(o.isEmpty());  //true

7. Files read string and write string
     - When we write something to text files or read from file, we use BufferedReader, BufferedWriter, FileWriter etc. From Java11 onwards oracle introduce few methods which made easy to write few context and read from text file 
     - read and write string data from files - writeString(), readString(), isSameFile()-compare the contents of 2 file

Program 1:
var uri="C:\\data.txt";
try{
  Files.writeString(Path.of(uri),"hello",StandardOpenOption.APPEND);

  String data=Files.readString(Path.of(uri));
  System.out.println(data);
}
catch(IOException e){
    e.printStackTrace();
}

Now the data will be appended into file and prints the data

Program 2:
1. Create sample.txt inside resources folder
Sample
Line 2
Line 3
2. Now we read the content from file and write to another file

Path path=Paths.get("./resources/sample.txt");
String f=Files.readString(path);
System.out.println(f);
String n=f.replace("Line","Lines");
Path n1=Paths.get("./resources/sample1.txt");
Files.writeString(n1,n);

8. HTTP Client API
       - used to give post, get and delete request 
       - Alternate to HttpURLConnection,  we are using HttpURLConnection to deal with http connection, to read and perform operation on HTTP protocol. Now we use HTTP Client API to do all this things 
       - The advantage is it can perform sync and async operations and can handle multiple urls at same time on Http 1 as well as Http2

String uri="https://postman-echo.com/get?uname=java&pwd=121";
HttpRequest req=HttpRequest.newBuilder().uri(URI.create(uri)).GET().version(Version.HTTP_2).build();

HttpClient client=HttpClient.newBuilder().build();
try{
  HttpResponse<String> res=client.send(req,BodyHandlers.ofString());
   SOP(resp.statusCode());
   SOP(resp.body());
}
catch(IOException | InterruptedException e) {
   e.printStackTrace();
}

Example 2: synchronous get request 
public class Sample { 
//create http client with http version 1.1
private static final HttpClient httpClient=HttpClient.newBuilder()
          .version(HttpClient.Version.HTTP_1_1)
          .connectTimeout(Duration.ofSeconds(10))
          .build();

     PSVM() throws Exception {
   //Synchronous get request 
   HttpRequest req=HttpRequest.newBuilder()
                   .GET()
                   .uri(URI.create("https://httpbin.org/get"))
                   .setHeader("User-Agent","Java 11 HttpClient")
                   .build();

//using httpclient send the request 
HttpResponse<String> res=httpClient.send(req,HttpResponse.BodyHandlers.ofString());

HttpHeaders headers=res.headers();
headers.map().forEach((k,v)->System.out.println(k +":"+v));
   System.out.println(res.statusCode());
   System.out.println(res.body());

}
}

Example 3: For Asynchrounous GET request 
public class Sample { 
//create http client with http version 2
private static final HttpClient httpClient=HttpClient.newBuilder()
          .version(HttpClient.Version.HTTP_2)
          .connectTimeout(Duration.ofSeconds(10))
          .build();

     PSVM() throws Exception {
   //Synchronous get request 
   HttpRequest req=HttpRequest.newBuilder()
                   .GET()
                   .uri(URI.create("https://httpbin.org/get"))
                   .setHeader("User-Agent","Java 11 HttpClient")
                   .build();

CompletableFuture<HttpResponse<String>> res=httpClient.sendAsync(req,HttpResponse.BodyHandlers.ofString());

String result=res.thenApply(HttpResponse::body).get(5, TimeUnit.SECONDS);
System.out.println(result);
}
}

Example 4: we can send multiple request at same time

public class Sample {
   private static final ExecutorService exe=Executors.newFixedThreadPool(3);

private static final HttpClient httpClient=HttpClient.newBuilder()
          .executor(exe)
          .version(HttpClient.Version.HTTP_2)
          .connectTimeout(Duration.ofSeconds(10))
          .build();
PSVM() throws Exception  {
   List<URI> targets = Arrays.asList(
       new URI("https://httpbin.org/get?name=ram"),
       new URI("https://httpbin.org/get?name=kumar"),
       new URI("https://httpbin.org/get?name=sam"));

List<CompletableFuture<String>> res=target.stream().
       map(url->httpClient.sendAsync(
           HttpRequest.newBuilder(url)
             .GET()
             .setHeader("User-Agent","Java HttpClient")
             .build(),
         HttpResponse.BodyHandlers.ofString())
        .thenApply(HttpResponse::body))
        .collect(Collectors.toList());

for(CompletableFuture<String> f:res) {
     sop(f.join());
  {
}
}

9. Predicate.not
      - Returns a predicate that is the negation of the supplier predicate 

public class Sample {
    public static boolean isEven(Integer number) {
         return number%2==0;
    }
    public static void main(String[] a){
        List<Integer> l=List.of(3,4,5,67,89,88);
    //Predicate<Integer> p1=n->n%2==0;
    //l.stream().filter(p1).forEach(System.out::println);  //4, 88
    //l.stream().filter(p1.negate()).forEach(System.out::println);  //3,5,67,89

   l.stream().filter(Predicate.not(Sample::isEven)).forEach(System.out::println); //4 88


10. Nested based access control
       - This is the feature 

Example 1:

public class Main {
    static class Blog {
         private String name;
    }
    PSVM {
      Blog b=new Blog();
      Field bName=Blog.class.getDeclaredField("name");
      bName.set(b,"hello world");
      SOP(b.name);
   }
}

Example 2:

public class Test {
     private static int x=5;
     public static class NestedTest {
         public static void doSomething() {
             System.out.println(x);
         }
     }
}

>javac Test.java
>javap -v Test.class

Before Java11 we we compile such type of file,here we can see extra method will be added for nested class called static int access$000(). This is the private bridge created between two classes, when we compile a class which contains another class so for that 2 class file will be created, one for outer and one for inner, so there should be some bridge between the outer class can access the method of another .class file 

>javap -v Test$NestedTest.class

Here we can see when we invoke doSomething(), it have provide like Test.access$000(), stating the outerclass can access this method by specifying the bridge between  both of the classes

But from Java11 onwards another access control is introduced which is "nest" and in nest we have nestHost and nestMembers. Basically outer class is nest host and inner classes are nest members or nest mate of that class
  When we compile the code in Java11 and see
>javac Test.java
>javap -v Test.class
    Here we have static int access$000() which will act as bridge between outer and inner class so that we can access private members of the outer class. So in Java11 onwards we have nesthost and nestmembers, so the outer class contains nest members as "Test$NestedTest.class"
    When we try to access inner class
>javap -v Test$NestedTest.class
    Here we can see nest host as "class Test" which is outer class 

So basically in this feature there is no impact on development or enduser but just enhancement on JVM level. 

Basically, the nest term defines a new access control context that allows classes that are logically part of the same code entity, but which are compiled with distinct class files, to access each others private members without the need for compilers to insert accessibiltity bridge methods
   Earlier version to access private members of class we need to specify the brigding method, but from java11 onwards no need to specify in compiled class instead we need to mention nesthost and nest members


11. TimeUnit Conversion
       - used to convert DAY, HOURS, MINUTES 

TimeUnit c=TimeUnit.DAYS;
c.convert(Duration.ofHours(24));
Output: 1 //convert 24hrs to day

TimeUnit c1=TimeUnit.MINUTES;
c1.convert(Duration.ofHours(60));
Output: 3600

13. Pattern recognizing method
      - used to generate the pattern and test against the string 

asMatchPredicate() - will create a predicate if pattern matches with input string 



14. Java Flight Recorder
       - Used tool for running Java appl and capturing diagnostic for further analysis. So when ur appl crashes or not perform as expected, u can monitor or troubleshoot it using the data collected by flight recorder
       - It is used for black box analysis as it continuously save state data into circular buffer and this information can be accessed when a problem is detected. You can use JFR for unexpected events.
       - For example if we get OutOfMemoryError in ur code or VM crashes, we can get all details and root causes with help of JFR

Introduction to Flight Recorder
   1. JFR provides best possible visibility into the JVM since it is build into JVM itself
   2. JFR has low performance overhead when used in heavily loaded production appl. We have overhead when we have profilers because profilers are attached to JVM and they consume heaps and create their own threads. When we use in production system u should carefully choose which event u should use with profiling
   3. It is event based profiling engine, when we say event that could be garbage collection or CPU load increase by threshold value or heap space consume more than 90%. JFR collects data from more than 500 events and we can create custom events also 
   4. JFR has binary recordings and we cant open and look into them. Events are written in binary formats, all the recordings are .jfr extension 
   5. We have Java API also to load and read data through Java code, you can trigger events through Java API calls. Java API is introduced in Java9 in jdfk.jfr package 

Events
   - Event occurs in JVM at specific point in time. Each event has name, timestamp and optional payload(the data associated with event)
   - For eg, CPU usage or Java heap size before and after the event or thread id 

3 types of events
   1. Duration events
   2. Instant events
   3. Sample events

Removed Features
1. Removal of com.sun.awt.AWTUtilities class
2. Removal of appletviewer launcher
3. Removal of Thread.destroy() and Thread.stop() methods
4. Removal of JVM-Managemebt-MIB.mib
5. Removal of Java Deployment Technologies like Java plugins, Java webstart, JRE 
6. Removal of JAVA FX from Oracle JDK
7. Remove JavaEE and CORBA Modules

Migration to Java 11
1. Eclipse : Photon 4.9RC2 with Java 11 plugin
Maven :3.5.0
Compiler plugin: 3.8.0
surefire and failsafe:2.22.0



Java 12 features
1. Compact Number Format 
     - Compact number formatting refers to the representation of a number in a short or human readable form
     - For eg, 1000 can be represent as 1k, 100000 can be represent as 1L, depending on the style specified by NumberFormat.Style
     - The compact number formats are defined by LDML(Local Data Markup Language) specification
     - NumberFormat adds suppory for formatting a number in its compact form

NumberFormat fmt=NumberFormat.getCompactNumberInstance(Locale.US,Style.SHORT);
String s=fmt.format(1000);
SOP(s); //output: 1K

String s1=fmt.format(100000000);
SOP(s1); //output: 100M

String s=fmt.format(100000000000000L);
SOP(s); //output: 1OOT

String s=fmt.format(9999);
SOP(s); //output: 10K - will display the nearest value 

2.  Switch Expression
       - new form of switch statement, normally we cant return value directly from switch stmt, instead we can go for switch expr
       - Syntax:  label -> logic
       - break is not required here
       - If we want to return multiple value we can use yeild keyword
   
class Sample {  PSVM {
   String msg=perOfDailyTask("SATURDAY");
   System.out.println(msg);
}

public static String perOfDailyTask(String day) {
     String msg=null;
     msg= switch(day) {
        case "MONDAY" -> {
                      System.out.println("hii");
                      yield "A";
                      }
        case "TUESDAY" -> "B";
        case "WEDNESDAY" -> "C";
        case "THURSDAY" -> "D";
        case "FRIDAY" -> "E";
        case "SATURDAY" -> "F";
        default -> "wrong input";
        };
    return msg;
}
}
Output: F

We can have multiple case in single line 

public static String perOfDailyTask(String day) {
     String msg=null;
     msg= switch(day) {
        case "MONDAY" -> {
                      System.out.println("hii");
                      yield "A";
                      }
        case "TUESDAY","WEDNESDAY","THURSDAY" -> "B";
        case "FRIDAY" -> "E";
        case "SATURDAY" -> "F";
        default -> "wrong input";
        };
    return msg;
}


Java 13 features
1. Text Blocks
       - A text block is a multi line literal. Avoids the need for most escape sequences automatically formats the string in a predictable way 

String email="hello welcome,\n"
             + " to java \"bean\"....\n"
             + "welcome\n"
             + "hello world\n";

email="""
        hello welcome,
        to Java "bean"....
        welcome
        hello world
      """;

   String s="""
       Line 1: %s
       Line 2: %s
       Line 3
       Line 4
       """.formatted("Some value","Some other value");
   SOP(s);

  - u cannot have text block in single line
      String s="""abcejjdjd"""; 

Java 14 features
1. Helpful NullPointerException 
     - Whenever we write big code in java, and when this code throws NullPointerException, it can become difficlt to know from where the exception originates.
     - Gives developers control over the format when desired
     - Aims to improve the readability of NullPointerExceptions, generated by JVM, by describing which variable is null

2. Pattern matching for instanceOf
      - instanceOf operator is enhanced to support pattern matching 

Object obj=(Object)"hello";

//lower version
if(obj instanceOf String) {
    String str=(String)obj;
    System.out.println(str);
}

//latest version
if(obj instanceOf String str) {
    System.out.println(str);
}

3. Records 
     - Eliminate verbosity in creating Java Beans - public accessor methods, constructor, equals, hashcode, toString are automatically created 
     - Records improves developer productivity by providing a compact syntax for declaring classes which act as transparent carriers for immutable data 
     - new class called record, it is final class not abstract and all of its field are final
     - The record will automatically generate the tedious constructors, getter,setter methods, equals, hashCode, toString during compile time 
     - So whenever we create immutable class we have to provide constructors, getter methods, equals, hashCode, toString, instead we can use record class for creating immutable class 

public class RecordDemo {
  record UserRecord(String firstName, String lastName, int userId){ }
  public static void main(String[] args){
     UserRecord u=new UserRecord("ram","kumar",1234);
     UserRecord u1=new UserRecord("ram","kumar",1234);
     System.out.println(u.firstName()); //ram
     System.out.println(u.equals(u1)); //true
  }
}

Internally if we decompile java class, compiler will provide methods related to fields provided 
   - We cant set the data as all fields are final. Inside  record we cant create instance variable but we can create static variable 

   - Compact constructors are only allowed in Records

public class Sample {
    record Person(String name, String email,String phone) {
         int number; //error instance variable
         static int num;
     Person {
         if(name==null) {
             throw new IllegalArgumentException("Name is null");
     }

     //instance method error
     /* public String name() {
                return "hello";
       } */
}
PSVM {
    Person p1=new Person("Ram","ram@gmail.com","34444");
    System.out.println(p1.name());
 }
}

  - You can add static fields, static initializer and static methods. But you cannot add instance variable.

4. Packaging tool
     - JPackage tool to package java appl into a platform specific package 
     - To execute any software we need any exe file and exe file will be executed in windows. In Java we have java and class files and we package into jar file and those jar file will be executed only in Java env.
     - Any client who dont have java software cannot execute those jar files 
     - Now java came with new packaging tool called JPackage so that we can convert our jar files into env specific. For MacOS, we can convert jar file into pkg and dmg file so that it can install in client machine. In windows we can convert jar file into msi or exe file and in linux as deb and rpm file 

1. Create java project with simple java program
2. Create executable jar file
   src>jar -cfe Sample.jar com.pack.Sample com/pack/*.class
3. copy the jar file inside another folder and in that we create exe file
3. Install Wix(Windows Installer XML tool) 3.0 from wixtoolset.org wix311-binaries
set wix311-binaries path in env variable
4. Use JPackage tool 
newfolder>jpackage --input . --name SampleApp --main-jar Sample.jar --main-class com.pack.Sample --type exe --java-options '--enable-preview' --win-shortcut
5. Install into exe and check how it is working


Java Mission Control 
https://github.com/cameronmcnz/Java-Mission-Control-Tutorial/tree/main/projects

1. Mission Control Plugin in Eclipse
       - If ur in eclipse, only plugin u can install is version 6 which is oracles which requires a commercial license. So we use open source AdoptOpenJDK plugin installed so u dont need that commercial license at all.
     In Eclipse Market Place, we can search Java Mission Control, but it is license version. So we get the latest version of JMC which build it from OpenJDK. 

1. Goto https://github.com/openjdk/jmc and try to clone to the jmc repo inside a folder
2. folder> git clone https://github.com/openjdk/jmc.git
    It created a folder jmc
3. Goto jmc/releng/third-party folder, where we can see bunch of third party lib that u need to build in order to get Java Mission Control and Java Flight Recorder plugin working
    Open gitbash inside third-party folder 
thirdparty>mvn p2:site
   - Which will set up whole website that going to host a maven repo with all these third party libraries.
    
4. After build success, Now hosts this site on jetty 
thirdparty>mvn jetty:run
This is all configured to host maven repo on localhost:8080 which is going to give the core build of JMC JFR eclipse plug-in access to the 3rd party libraries that it needs
    Let the prompt runs on Jetty server

5. Now go to jmc/core folder and open gitbash and need to build again
jmc/core> mvn clean install
    - compiles the code, run some test and then package all of the core stuff into appropriate jar file 

6. Now in same gitbash go to jmc folder
jmc/core>cd..
jmc> mvn package
    - So everything build in previous maven install will package it up into various jar files, one of jar file is java flight recorder maven plugin 

7. Once build sucess, under jmc folder we can see the folder called application.
  Inside that goto org.openjdk.jmc.updatesite.ide/target/ we can see the plugin for Java flight recorder
  org.openjdk.jmc.updatesite.ide-8.0.0.SNAPSHOT.zip

8. Now we need to install that plugin in Eclipse

Goto Eclipse - Help - Install New Software - Click Add - Click Archive - select the zip file from jmc/application/org.openjdk.jmc.updatesite.ide/target/  folder
  - Click Add - Select all checkboxes 
  - Click Next - Accept the agreement - Click Finish 
  - Restart eclipse ide

9. In eclipse we can see Java Mission Control icon in top
Under Local - Select Jetty server running - Start Flight Recording - click Finish 

localhost:8080/site/ - to see all available server running 

Which open Flight recording in that we can select memory, garbage collection , Threads(all class loading the thread that were in use and were blocked the memory the file socket, io etc)

2. Java Mission Control Overview
     We going to download it and install it and show you how to connect to an existing JVM and then do a Java Flight Recorder and take a look at some of the memory used and some of the cpu usage 
    To work with JMC u have to download it, it dosent come packaged with JDK anymore. 

1. Goto https://adoptopenjdk.net/jmc.html and download 
org.openjdk.jmc-8.0.0-win32.win32.x86_64.zip
    Extract it - Inside client jmc.exe file to start JMC
   Once started,it will load all the JVM's which is running on my local system, one of which is Jetty server which is already running.
   Under JVM browsing Tab we can see jvms running on the machine, under that we select Jetty server, under that we can see MBean Server and Flight Recorder
   Mbean server gives feedback on how your jvm is running right now, we got jetty server as we already running jetty server 
   Now if we refresh localhost:8080/site/, we can see needle moving as increase in memory 

2. Now we do flight recording
Right click Flight Recorder - Start Flight Recording - Finish 
    It gathers bunch of info about this jvm hosting, when u click refresh on jetty server we can see some sort of load and number of megs being used is increasing. This is MBean server this is giving us some live feedback on howour jvm is behaving. We will get JMC report once flight recorder is completed
   This will show information about the threads, memory, garbage collection all sorts of info about just what happened during that run. You can see little bit of cpu peaking  


3 ways to Start Java Flight Recorder in Eclipse

First way:
1. Configure DoSomething project in eclipse
2. Right click project - Run as Java application
3. Goto JVM Browser tab - Right click Flight Recorder - Start Flight Recording 
   Recording Time: 10s - Click Finish
4. Once recording is compelted, it show the result in JMC which provide info abt memory, abt thread and in Automated Analyse Result it show the completed result 
   Under Environment - Click ^ - we can see the number of completing resources running on my computer  

Second way:
1. In the same project we can provide Launchers, in that we use DoNothing Auto Record.launch, in this launcher we set some JVM arguments like flight recorder arguments
    We specify that the recordings starts after 5sec delay and 20s duration and the file would be saved in DoNothing folder 
2. Run as Java Application - Select Launcher - click ok
    It will start the recording for 20s duration, once complete, u just refresh the project 
    You can see the recording file, just double click it will open automated analysis of that appl with threads, memory and with feedback 

Third way:
1. Right click project - Run as Java application
2. Goto package of DoSomething.java - Right click package - show in local terminal 
  > jcmd 
which displays process id of that appl

>jcmd 1886 JFR.start duration=10s filename=recording.jfr 

It will take 10s to create the recording. Once done, just refresh the project, u can see the recording. Just double click the recording which generates the flight recording of the application.

LinkedList vs HashSet Performance Problem in JMC 
    - Here we see difference between LinkedList and HashSet when we have large number of elements in Java Collection. Now we see difference in performance between a linked list versus HashSet by using example

http://missioncontrol.mcnz.com/2020/12/10/Java_LinkedList_vs_HashSet_Performance.html

public class HotJavaMethodRunner implements Runnable {
	
	private static final int NUMBER_OF_THREADS = 8;

	public static void main(String[] args) throws Exception {
		ThreadGroup threadGroup = new ThreadGroup("Workers");
		Thread[] threads = new Thread[NUMBER_OF_THREADS];
		for (int i = 0; i < threads.length; i++) {
			threads[i] = new Thread(threadGroup, new HotJavaMethodRunner(), "Worker Thread " + i);
			threads[i].setDaemon(true);
			threads[i].start();
		}
		System.out.print("Press enter to quit!");
		System.out.flush();
		System.in.read();
	}
	
	public void run() {
		while (true) {
			WorkEvent event = new WorkEvent();
			Collection<Integer> firstBunch = new LinkedList<>();
			Collection<Integer> secondBunch = new LinkedList<>();
			
			//Collection<Integer> firstBunch = new HashSet<>();
			//Collection<Integer> secondBunch = new HashSet<>();
			
			event.begin();
			
			initialize(firstBunch, 3);
			initialize(secondBunch, 2);
			int intersectionSize = countMatches(firstBunch, secondBunch);
			
			event.setIntersectionSize(intersectionSize);
			event.commit();
			Thread.yield();
		}
	}
	
	public void initialize(Collection<Integer> collection, int modulus) {
		collection.clear();
		for (int i = 1; i < 100000; i++) {
			if ((i % modulus) != 0)
				collection.add(i);
		}
	}
	
	public int countMatches(Collection<Integer> first, Collection<Integer> second) {
		int count = 0;
		for (Integer i : first) {
			if (second.contains(i)) {
				count++;
			}
		}
		System.out.println(count);
		return count;
	}
	
}


1. In the above example we create 2 collection firstBunch and secondBunch which contains collection of Integers. FirstBunch is numbers from 1 to 100000 and mod by 3 and secondbunch is between 1 to 100000 and mod by 2 using initialize() method
   Once we got those two collection of numbers that are linkedlist initialized,we want to find the intersection (ie) how many numbers are same between first list and second list using countMatches()
    This example causes lot of computation and we are going to run this with JFR and take a look at how cpu and memory behaves. This kicks off 8 threads in my example and every time a thread kicks off we create a new work event 

import jdk.jfr.*;

@Label("Work")
@Category("02_JFR_HotMethods")
@Description("Data from one loop run in the worker thread")
public class WorkEvent extends jdk.jfr.Event {
	@Label("Intersection Size")
	@Description("The number of values that were the same in the two collections")
	private int intersectionSize;

	public int getIntersectionSize() {
		return intersectionSize;
	}

	public void setIntersectionSize(int intersectionSize) {
		this.intersectionSize = intersectionSize;
	}
}


We created a work called "Work", we started at the beginning of run() as event.begin() and we terminate at the end, this will keep track of how long it takes to actually run all of these  methods

2. Run the main class, we have Launcher confgiured here which will automatically run JFR and we made recording to save inside Recording folder, just refresh u can see  the recording 
  You click the recording and u can see it displays 

3. Instead of LinkedList we use HashSet. In linkedlist the larger the list is more difficult it is to process and bigger the performance implication. Hashset tends to have linear performace
Collection<Integer> firstBunch = new HashSet<>();
Collection<Integer> secondBunch = new HashSet<>();

4. Run the application, now u can see it was taking very less time to process compare to LinkedList 
   Now look at flight recorder in Recording folder, now it says high CPU load because my threads are running so quickly 



